
FREERTOS_OLED_Wireless_Wip.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005054  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000024  20000000  00005054  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004124  20000024  00005078  00010024  2**2
                  ALLOC
  3 .stack        00002000  20004148  0000919c  00010024  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010024  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  0001004c  2**0
                  CONTENTS, READONLY
  6 .debug_info   000288d2  00000000  00000000  000100a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000465e  00000000  00000000  00038979  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000d172  00000000  00000000  0003cfd7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000a00  00000000  00000000  0004a149  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000e50  00000000  00000000  0004ab49  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000182a0  00000000  00000000  0004b999  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00015331  00000000  00000000  00063c39  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00069780  00000000  00000000  00078f6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001b34  00000000  00000000  000e26ec  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20006148 	.word	0x20006148
       4:	00002829 	.word	0x00002829
       8:	00002825 	.word	0x00002825
       c:	00002825 	.word	0x00002825
	...
      2c:	000029b1 	.word	0x000029b1
	...
      38:	00002a19 	.word	0x00002a19
      3c:	00002a5d 	.word	0x00002a5d
      40:	00002825 	.word	0x00002825
      44:	00002825 	.word	0x00002825
      48:	00002825 	.word	0x00002825
      4c:	00002825 	.word	0x00002825
      50:	00002825 	.word	0x00002825
      54:	00002825 	.word	0x00002825
      58:	00002825 	.word	0x00002825
      5c:	000013cd 	.word	0x000013cd
      60:	000013dd 	.word	0x000013dd
      64:	000013ed 	.word	0x000013ed
      68:	000013fd 	.word	0x000013fd
      6c:	0000140d 	.word	0x0000140d
      70:	0000141d 	.word	0x0000141d
      74:	00002825 	.word	0x00002825
      78:	00002825 	.word	0x00002825
      7c:	00002825 	.word	0x00002825
      80:	00002825 	.word	0x00002825
      84:	00002825 	.word	0x00002825
      88:	00002825 	.word	0x00002825
      8c:	00002825 	.word	0x00002825
      90:	00002825 	.word	0x00002825
      94:	00002825 	.word	0x00002825
      98:	00002825 	.word	0x00002825
      9c:	00002825 	.word	0x00002825
      a0:	00002825 	.word	0x00002825

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000024 	.word	0x20000024
      c4:	00000000 	.word	0x00000000
      c8:	00005054 	.word	0x00005054

000000cc <frame_dummy>:
      cc:	b508      	push	{r3, lr}
      ce:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4807      	ldr	r0, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4908      	ldr	r1, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd08      	pop	{r3, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	00005054 	.word	0x00005054
      f8:	20000028 	.word	0x20000028
      fc:	00005054 	.word	0x00005054
     100:	00000000 	.word	0x00000000

00000104 <DSPI_DRV_MasterTransferBlocking>:
	{
		Write_Register(0x11, SendArray, ReadArray, 1); // data payload widths for pipe0 5 bytes.
		//Delay_ms(100);
		delay_cycles_ms(100);
		//Read_Register(unsigned char RegisterNumber, unsigned char * RecieveArray, unsigned char NumOfBytesToRead)
		Read_Register(0x11, &TempValue, 1);
     104:	b5f0      	push	{r4, r5, r6, r7, lr}

	TempValue = 0;
	SendArray[0] = 0x05;
	while(!(0x05 == TempValue))
	{
		Write_Register(0x11, SendArray, ReadArray, 1); // data payload widths for pipe0 5 bytes.
     106:	b085      	sub	sp, #20
     108:	9001      	str	r0, [sp, #4]
     10a:	1c0e      	adds	r6, r1, #0
     10c:	9202      	str	r2, [sp, #8]
     10e:	9303      	str	r3, [sp, #12]
		//Delay_ms(100);
		delay_cycles_ms(100);
     110:	4d0a      	ldr	r5, [pc, #40]	; (13c <DSPI_DRV_MasterTransferBlocking+0x38>)
     112:	4c0b      	ldr	r4, [pc, #44]	; (140 <DSPI_DRV_MasterTransferBlocking+0x3c>)
		//Read_Register(unsigned char RegisterNumber, unsigned char * RecieveArray, unsigned char NumOfBytesToRead)
		Read_Register(0x11, &TempValue, 1);
     114:	1c28      	adds	r0, r5, #0
     116:	1c21      	adds	r1, r4, #0
     118:	2201      	movs	r2, #1
     11a:	4f0a      	ldr	r7, [pc, #40]	; (144 <DSPI_DRV_MasterTransferBlocking+0x40>)
     11c:	47b8      	blx	r7
     11e:	9801      	ldr	r0, [sp, #4]
		//Delay_ms(100);
		delay_cycles_ms(100);
     120:	1c31      	adds	r1, r6, #0
     122:	9a02      	ldr	r2, [sp, #8]
	//SendArray[0] = 0x01;
	//Write_Register(7, SendArray, ReadArray, 1); // status register..

	TempValue = 0;
	SendArray[0] = 0x05;
	while(!(0x05 == TempValue))
     124:	9b03      	ldr	r3, [sp, #12]
     126:	4e08      	ldr	r6, [pc, #32]	; (148 <DSPI_DRV_MasterTransferBlocking+0x44>)
     128:	47b0      	blx	r6
		//Read_Register(unsigned char RegisterNumber, unsigned char * RecieveArray, unsigned char NumOfBytesToRead)
		Read_Register(0x11, &TempValue, 1);
		//Delay_ms(100);
		delay_cycles_ms(100);
	}
}
     12a:	1c06      	adds	r6, r0, #0
     12c:	1c28      	adds	r0, r5, #0
     12e:	1c21      	adds	r1, r4, #0
     130:	2200      	movs	r2, #0
     132:	47b8      	blx	r7
     134:	1c30      	adds	r0, r6, #0
     136:	b005      	add	sp, #20
     138:	bdf0      	pop	{r4, r5, r6, r7, pc}
     13a:	46c0      	nop			; (mov r8, r8)
     13c:	20004118 	.word	0x20004118
	spi_select_slave(&spi_master_instance, &slave, true);
	//enum status_code spi_transceive_buffer_wait(struct spi_module *const module, uint8_t *tx_data, uint8_t *rx_data, uint16_t length);
	ReturnFlag = spi_transceive_buffer_wait(module, tx_data, rx_data, length);
	spi_select_slave(&spi_master_instance, &slave, false);
	return (ReturnFlag);
}
     140:	20004120 	.word	0x20004120
     144:	00001721 	.word	0x00001721
     148:	00001a19 	.word	0x00001a19

0000014c <configure_spi_master>:



void configure_spi_master(void)
{
     14c:	b510      	push	{r4, lr}
     14e:	b08e      	sub	sp, #56	; 0x38
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
     150:	4c24      	ldr	r4, [pc, #144]	; (1e4 <configure_spi_master+0x98>)
     152:	2311      	movs	r3, #17
     154:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
     156:	2300      	movs	r3, #0
     158:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
     15a:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     15c:	2201      	movs	r2, #1
     15e:	4669      	mov	r1, sp
     160:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
     162:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
     164:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
     166:	2011      	movs	r0, #17
     168:	4b1f      	ldr	r3, [pc, #124]	; (1e8 <configure_spi_master+0x9c>)
     16a:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
     16c:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     16e:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
     170:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     172:	2900      	cmp	r1, #0
     174:	d104      	bne.n	180 <configure_spi_master+0x34>
		return &(ports[port_index]->Group[group_index]);
     176:	095a      	lsrs	r2, r3, #5
     178:	01d2      	lsls	r2, r2, #7
     17a:	491c      	ldr	r1, [pc, #112]	; (1ec <configure_spi_master+0xa0>)
     17c:	468c      	mov	ip, r1
     17e:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
     180:	211f      	movs	r1, #31
     182:	400b      	ands	r3, r1
     184:	391e      	subs	r1, #30
     186:	1c08      	adds	r0, r1, #0
     188:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     18a:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
     18c:	aa01      	add	r2, sp, #4
     18e:	7011      	strb	r1, [r2, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
     190:	2300      	movs	r3, #0
     192:	6053      	str	r3, [r2, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
     194:	6093      	str	r3, [r2, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
     196:	7413      	strb	r3, [r2, #16]
	config->run_in_standby   = false;
     198:	7453      	strb	r3, [r2, #17]
	config->receiver_enable  = true;
     19a:	7491      	strb	r1, [r2, #18]
	config->select_slave_low_detect_enable= true;
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;
     19c:	311f      	adds	r1, #31
     19e:	5453      	strb	r3, [r2, r1]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
     1a0:	9307      	str	r3, [sp, #28]
     1a2:	9308      	str	r3, [sp, #32]

	/* Master config defaults */
	config->mode_specific.master.baudrate = 100000;
     1a4:	4b12      	ldr	r3, [pc, #72]	; (1f0 <configure_spi_master+0xa4>)
     1a6:	6153      	str	r3, [r2, #20]
	slave_dev_config.ss_pin = SLAVE_SELECT_PIN;
	spi_attach_slave(&slave, &slave_dev_config);
	/* Configure, initialize and enable SERCOM SPI module */
	spi_get_config_defaults(&config_spi_master);
	//config_spi_master.mux_setting = EXT1_SPI_SERCOM_MUX_SETTING;
	config_spi_master.mux_setting = EXT2_SPI_SERCOM_MUX_SETTING;
     1a8:	2380      	movs	r3, #128	; 0x80
     1aa:	025b      	lsls	r3, r3, #9
     1ac:	60d3      	str	r3, [r2, #12]
	/* Configure pad 0 for data in */
	//config_spi_master.pinmux_pad0 = EXT1_SPI_SERCOM_PINMUX_PAD0;
	config_spi_master.pinmux_pad0 = EXT2_SPI_SERCOM_PINMUX_PAD0;
     1ae:	4b11      	ldr	r3, [pc, #68]	; (1f4 <configure_spi_master+0xa8>)
     1b0:	6253      	str	r3, [r2, #36]	; 0x24
	/* Configure pad 1 as unused */
	//config_spi_master.pinmux_pad1 = PINMUX_UNUSED;
	config_spi_master.pinmux_pad1 = PINMUX_UNUSED;
     1b2:	2301      	movs	r3, #1
     1b4:	425b      	negs	r3, r3
     1b6:	6293      	str	r3, [r2, #40]	; 0x28
	/* Configure pad 2 for data out */
	//config_spi_master.pinmux_pad2 = EXT1_SPI_SERCOM_PINMUX_PAD2;
	config_spi_master.pinmux_pad2 = EXT2_SPI_SERCOM_PINMUX_PAD2;
     1b8:	4b0f      	ldr	r3, [pc, #60]	; (1f8 <configure_spi_master+0xac>)
     1ba:	62d3      	str	r3, [r2, #44]	; 0x2c
	/* Configure pad 3 for SCK */
	//config_spi_master.pinmux_pad3 = EXT1_SPI_SERCOM_PINMUX_PAD3;
	config_spi_master.pinmux_pad3 = EXT2_SPI_SERCOM_PINMUX_PAD3;
     1bc:	4b0f      	ldr	r3, [pc, #60]	; (1fc <configure_spi_master+0xb0>)
     1be:	6313      	str	r3, [r2, #48]	; 0x30
	//spi_init(&spi_master_instance, EXT1_SPI_MODULE, &config_spi_master);
	spi_init(&spi_master_instance, EXT2_SPI_MODULE, &config_spi_master);
     1c0:	4c0f      	ldr	r4, [pc, #60]	; (200 <configure_spi_master+0xb4>)
     1c2:	1c20      	adds	r0, r4, #0
     1c4:	490f      	ldr	r1, [pc, #60]	; (204 <configure_spi_master+0xb8>)
     1c6:	4b10      	ldr	r3, [pc, #64]	; (208 <configure_spi_master+0xbc>)
     1c8:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     1ca:	6822      	ldr	r2, [r4, #0]
#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
     1cc:	8a13      	ldrh	r3, [r2, #16]
     1ce:	0bdb      	lsrs	r3, r3, #15
     1d0:	03db      	lsls	r3, r3, #15

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
     1d2:	b29b      	uxth	r3, r3
     1d4:	2b00      	cmp	r3, #0
     1d6:	d1f9      	bne.n	1cc <configure_spi_master+0x80>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     1d8:	6811      	ldr	r1, [r2, #0]
     1da:	3302      	adds	r3, #2
     1dc:	430b      	orrs	r3, r1
     1de:	6013      	str	r3, [r2, #0]
	spi_enable(&spi_master_instance);
}
     1e0:	b00e      	add	sp, #56	; 0x38
     1e2:	bd10      	pop	{r4, pc}
     1e4:	20004120 	.word	0x20004120
     1e8:	00000f3d 	.word	0x00000f3d
     1ec:	41004400 	.word	0x41004400
     1f0:	000186a0 	.word	0x000186a0
     1f4:	00100002 	.word	0x00100002
     1f8:	00120002 	.word	0x00120002
     1fc:	00130002 	.word	0x00130002
     200:	20004118 	.word	0x20004118
     204:	42000c00 	.word	0x42000c00
     208:	0000142d 	.word	0x0000142d

0000020c <Read_Register>:

	return(ReturnFlag);
}

unsigned char Read_Register(unsigned char RegisterNumber, unsigned char * RecieveArray, unsigned char NumOfBytesToRead)
{
     20c:	b570      	push	{r4, r5, r6, lr}
     20e:	b09a      	sub	sp, #104	; 0x68
     210:	1c0d      	adds	r5, r1, #0
     212:	1c14      	adds	r4, r2, #0
	unsigned char ReturnFlag = 0;
	unsigned char TempSendArray[50];
	unsigned char TempReadArray[50];
	unsigned char Counter = 0;
	TempSendArray[0] = RegisterNumber;
     214:	a90d      	add	r1, sp, #52	; 0x34
     216:	7008      	strb	r0, [r1, #0]

	//DSPI_DRV_MasterTransferBlocking(FSL_DSPICOM1, NULL, &Send[0], Read, 5, 10000);
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
     218:	1c53      	adds	r3, r2, #1
     21a:	480a      	ldr	r0, [pc, #40]	; (244 <Read_Register+0x38>)
     21c:	466a      	mov	r2, sp
     21e:	4e0a      	ldr	r6, [pc, #40]	; (248 <Read_Register+0x3c>)
     220:	47b0      	blx	r6
	ReturnFlag = TempReadArray[0];
     222:	466b      	mov	r3, sp
     224:	7818      	ldrb	r0, [r3, #0]

	while(NumOfBytesToRead > Counter)
     226:	2c00      	cmp	r4, #0
     228:	d00a      	beq.n	240 <Read_Register+0x34>
     22a:	1e61      	subs	r1, r4, #1
     22c:	b2c9      	uxtb	r1, r1
     22e:	3101      	adds	r1, #1
     230:	2300      	movs	r3, #0
     232:	1c1a      	adds	r2, r3, #0
     234:	446a      	add	r2, sp
	{
		RecieveArray[Counter] = TempReadArray[Counter + 1];
     236:	7852      	ldrb	r2, [r2, #1]
     238:	54ea      	strb	r2, [r5, r3]
     23a:	3301      	adds	r3, #1
	//DSPI_DRV_MasterTransferBlocking(FSL_DSPICOM1, NULL, &Send[0], Read, 5, 10000);
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	ReturnFlag = TempReadArray[0];

	while(NumOfBytesToRead > Counter)
     23c:	428b      	cmp	r3, r1
     23e:	d1f8      	bne.n	232 <Read_Register+0x26>
		RecieveArray[Counter] = TempReadArray[Counter + 1];
		Counter++;
	}

	return (ReturnFlag);
}
     240:	b01a      	add	sp, #104	; 0x68
     242:	bd70      	pop	{r4, r5, r6, pc}
     244:	20004118 	.word	0x20004118
     248:	00000105 	.word	0x00000105

0000024c <Write_Register>:

unsigned char Write_Register(unsigned char RegisterNumber, unsigned char * SendArray, unsigned char * RecievedArray, unsigned char NumOfBytesToRead)
{
     24c:	b570      	push	{r4, r5, r6, lr}
     24e:	b09a      	sub	sp, #104	; 0x68
     250:	1c16      	adds	r6, r2, #0
	unsigned char ReturnFlag = 0;
	unsigned char TempSendArray[50];
	unsigned char TempReadArray[50];
	unsigned char Counter = 0;
	TempSendArray[0] = RegisterNumber + 0x20;
     252:	3020      	adds	r0, #32
     254:	aa0d      	add	r2, sp, #52	; 0x34
     256:	7010      	strb	r0, [r2, #0]

	while(NumOfBytesToRead > Counter)
     258:	2b00      	cmp	r3, #0
     25a:	d01d      	beq.n	298 <Write_Register+0x4c>
     25c:	1e5c      	subs	r4, r3, #1
     25e:	b2e4      	uxtb	r4, r4
     260:	3401      	adds	r4, #1
     262:	2200      	movs	r2, #0
     264:	a80d      	add	r0, sp, #52	; 0x34
     266:	1880      	adds	r0, r0, r2
	{
		TempSendArray[Counter + 1] = SendArray[Counter];
     268:	5c8d      	ldrb	r5, [r1, r2]
     26a:	7045      	strb	r5, [r0, #1]
     26c:	3201      	adds	r2, #1
	unsigned char TempSendArray[50];
	unsigned char TempReadArray[50];
	unsigned char Counter = 0;
	TempSendArray[0] = RegisterNumber + 0x20;

	while(NumOfBytesToRead > Counter)
     26e:	42a2      	cmp	r2, r4
     270:	d1f8      	bne.n	264 <Write_Register+0x18>
     272:	e007      	b.n	284 <Write_Register+0x38>
     274:	1c1a      	adds	r2, r3, #0
     276:	446a      	add	r2, sp

	Counter = 0;

	while(NumOfBytesToRead > Counter)
	{
		RecievedArray[Counter] = TempReadArray[Counter + 1];
     278:	7852      	ldrb	r2, [r2, #1]
     27a:	54f2      	strb	r2, [r6, r3]
     27c:	3301      	adds	r3, #1
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	ReturnFlag = TempReadArray[0];

	Counter = 0;

	while(NumOfBytesToRead > Counter)
     27e:	429c      	cmp	r4, r3
     280:	d1f8      	bne.n	274 <Write_Register+0x28>
     282:	e011      	b.n	2a8 <Write_Register+0x5c>
	
	//enum status_code DSPI_DRV_MasterTransferBlocking(struct spi_module *const module,
	//												 uint8_t *tx_data, uint8_t *rx_data, uint16_t length)
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	//DSPI_DRV_MasterTransferBlocking(FSL_DSPICOM1, NULL, &Send[0], Read, 5, 10000);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
     284:	3301      	adds	r3, #1
     286:	4809      	ldr	r0, [pc, #36]	; (2ac <Write_Register+0x60>)
     288:	a90d      	add	r1, sp, #52	; 0x34
     28a:	466a      	mov	r2, sp
     28c:	4d08      	ldr	r5, [pc, #32]	; (2b0 <Write_Register+0x64>)
     28e:	47a8      	blx	r5
	ReturnFlag = TempReadArray[0];
     290:	466b      	mov	r3, sp
     292:	7818      	ldrb	r0, [r3, #0]
     294:	2300      	movs	r3, #0
     296:	e7ed      	b.n	274 <Write_Register+0x28>
	
	//enum status_code DSPI_DRV_MasterTransferBlocking(struct spi_module *const module,
	//												 uint8_t *tx_data, uint8_t *rx_data, uint16_t length)
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	//DSPI_DRV_MasterTransferBlocking(FSL_DSPICOM1, NULL, &Send[0], Read, 5, 10000);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
     298:	4804      	ldr	r0, [pc, #16]	; (2ac <Write_Register+0x60>)
     29a:	a90d      	add	r1, sp, #52	; 0x34
     29c:	466a      	mov	r2, sp
     29e:	2301      	movs	r3, #1
     2a0:	4c03      	ldr	r4, [pc, #12]	; (2b0 <Write_Register+0x64>)
     2a2:	47a0      	blx	r4
	ReturnFlag = TempReadArray[0];
     2a4:	466b      	mov	r3, sp
     2a6:	7818      	ldrb	r0, [r3, #0]
		RecievedArray[Counter] = TempReadArray[Counter + 1];
		Counter++;
	}

	return (ReturnFlag);
}
     2a8:	b01a      	add	sp, #104	; 0x68
     2aa:	bd70      	pop	{r4, r5, r6, pc}
     2ac:	20004118 	.word	0x20004118
     2b0:	00000105 	.word	0x00000105

000002b4 <Write_Reg_Varified>:
	}
}


unsigned char Write_Reg_Varified(unsigned char RegisterNumber, unsigned char * SendArray, unsigned char NumOfBytesToRead)
{
     2b4:	b5f0      	push	{r4, r5, r6, r7, lr}
     2b6:	4657      	mov	r7, sl
     2b8:	b480      	push	{r7}
     2ba:	b086      	sub	sp, #24
	unsigned char ReturnFlag = 0;
	unsigned char TempValue = 0;
     2bc:	2400      	movs	r4, #0
     2be:	230f      	movs	r3, #15
     2c0:	ad02      	add	r5, sp, #8
     2c2:	46ac      	mov	ip, r5
     2c4:	4463      	add	r3, ip
     2c6:	701c      	strb	r4, [r3, #0]
	unsigned char ReadArray[10];

	while(!(SendArray[0] == TempValue))
     2c8:	780b      	ldrb	r3, [r1, #0]
     2ca:	2b00      	cmp	r3, #0
     2cc:	d01b      	beq.n	306 <Write_Reg_Varified+0x52>
     2ce:	9201      	str	r2, [sp, #4]
     2d0:	1c0d      	adds	r5, r1, #0
     2d2:	9000      	str	r0, [sp, #0]
	{
		Write_Register(RegisterNumber, SendArray, ReadArray, NumOfBytesToRead);
     2d4:	4b0e      	ldr	r3, [pc, #56]	; (310 <Write_Reg_Varified+0x5c>)
     2d6:	469a      	mov	sl, r3
		//Delay_ms(10);
		delay_cycles_ms(100);
     2d8:	4f0e      	ldr	r7, [pc, #56]	; (314 <Write_Reg_Varified+0x60>)
		Read_Register(RegisterNumber, &TempValue, NumOfBytesToRead);
     2da:	4e0f      	ldr	r6, [pc, #60]	; (318 <Write_Reg_Varified+0x64>)
	unsigned char TempValue = 0;
	unsigned char ReadArray[10];

	while(!(SendArray[0] == TempValue))
	{
		Write_Register(RegisterNumber, SendArray, ReadArray, NumOfBytesToRead);
     2dc:	9800      	ldr	r0, [sp, #0]
     2de:	1c29      	adds	r1, r5, #0
     2e0:	aa03      	add	r2, sp, #12
     2e2:	9b01      	ldr	r3, [sp, #4]
     2e4:	47d0      	blx	sl
		//Delay_ms(10);
		delay_cycles_ms(100);
     2e6:	2064      	movs	r0, #100	; 0x64
     2e8:	47b8      	blx	r7
		Read_Register(RegisterNumber, &TempValue, NumOfBytesToRead);
     2ea:	240f      	movs	r4, #15
     2ec:	ab02      	add	r3, sp, #8
     2ee:	469c      	mov	ip, r3
     2f0:	4464      	add	r4, ip
     2f2:	9800      	ldr	r0, [sp, #0]
     2f4:	1c21      	adds	r1, r4, #0
     2f6:	9a01      	ldr	r2, [sp, #4]
     2f8:	47b0      	blx	r6
		//Delay_ms(10);
		delay_cycles_ms(100);
     2fa:	2064      	movs	r0, #100	; 0x64
     2fc:	47b8      	blx	r7
{
	unsigned char ReturnFlag = 0;
	unsigned char TempValue = 0;
	unsigned char ReadArray[10];

	while(!(SendArray[0] == TempValue))
     2fe:	782a      	ldrb	r2, [r5, #0]
     300:	7823      	ldrb	r3, [r4, #0]
     302:	429a      	cmp	r2, r3
     304:	d1ea      	bne.n	2dc <Write_Reg_Varified+0x28>
		//Delay_ms(10);
		delay_cycles_ms(100);
	}

	return(ReturnFlag);
}
     306:	2000      	movs	r0, #0
     308:	b006      	add	sp, #24
     30a:	bc04      	pop	{r2}
     30c:	4692      	mov	sl, r2
     30e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     310:	0000024d 	.word	0x0000024d
     314:	000008d1 	.word	0x000008d1
     318:	0000020d 	.word	0x0000020d

0000031c <Read_Status>:

	return (ReturnFlag);
}

unsigned char Read_Status()
{
     31c:	b510      	push	{r4, lr}
     31e:	b082      	sub	sp, #8
	unsigned char ReturnFlag = 0;
	unsigned char ReadArray[2] = {0, 0};
     320:	ac01      	add	r4, sp, #4
     322:	2300      	movs	r3, #0
     324:	7023      	strb	r3, [r4, #0]
     326:	7063      	strb	r3, [r4, #1]
	//unsigned char Read_Register(unsigned char RegisterNumber, unsigned char * RecieveArray, unsigned char NumOfBytesToRead)
	Read_Register(0x07, ReadArray, 1);
     328:	2007      	movs	r0, #7
     32a:	1c21      	adds	r1, r4, #0
     32c:	2201      	movs	r2, #1
     32e:	4b02      	ldr	r3, [pc, #8]	; (338 <Read_Status+0x1c>)
     330:	4798      	blx	r3
	ReturnFlag = ReadArray[0];
     332:	7820      	ldrb	r0, [r4, #0]
	return (ReturnFlag);
}
     334:	b002      	add	sp, #8
     336:	bd10      	pop	{r4, pc}
     338:	0000020d 	.word	0x0000020d

0000033c <Clear_NRF_Int_Flags>:
	spi_enable(&spi_master_instance);
}


void Clear_NRF_Int_Flags(void)
{
     33c:	b510      	push	{r4, lr}
     33e:	b082      	sub	sp, #8
	unsigned char SendArray[2] = {0, 0};
     340:	ac01      	add	r4, sp, #4
     342:	2300      	movs	r3, #0
     344:	7023      	strb	r3, [r4, #0]
     346:	7063      	strb	r3, [r4, #1]
	unsigned char ReadArray[2];
	unsigned char TempStatus = 0;
	TempStatus = Read_Status();
     348:	4b06      	ldr	r3, [pc, #24]	; (364 <Clear_NRF_Int_Flags+0x28>)
     34a:	4798      	blx	r3
	SendArray[0] = TempStatus & 0xF0;
     34c:	230f      	movs	r3, #15
     34e:	4398      	bics	r0, r3
     350:	7020      	strb	r0, [r4, #0]
	Write_Register(7, SendArray, ReadArray, 1); //
     352:	2007      	movs	r0, #7
     354:	1c21      	adds	r1, r4, #0
     356:	466a      	mov	r2, sp
     358:	3b0e      	subs	r3, #14
     35a:	4c03      	ldr	r4, [pc, #12]	; (368 <Clear_NRF_Int_Flags+0x2c>)
     35c:	47a0      	blx	r4
}
     35e:	b002      	add	sp, #8
     360:	bd10      	pop	{r4, pc}
     362:	46c0      	nop			; (mov r8, r8)
     364:	0000031d 	.word	0x0000031d
     368:	0000024d 	.word	0x0000024d

0000036c <Flush_Tx>:

	return (ReturnFlag);
}

unsigned char Flush_Tx()
{
     36c:	b530      	push	{r4, r5, lr}
     36e:	b083      	sub	sp, #12
	unsigned char ReturnFlag = 0;
	unsigned char ReadArray[2] = {0, 0};
     370:	ac01      	add	r4, sp, #4
     372:	2300      	movs	r3, #0
     374:	7023      	strb	r3, [r4, #0]
     376:	7063      	strb	r3, [r4, #1]
	unsigned char SendArray[2] = {FLUSH_TX, 0};
     378:	22e1      	movs	r2, #225	; 0xe1
     37a:	4669      	mov	r1, sp
     37c:	700a      	strb	r2, [r1, #0]
     37e:	704b      	strb	r3, [r1, #1]
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, SendArray, ReadArray, 1);
     380:	4803      	ldr	r0, [pc, #12]	; (390 <Flush_Tx+0x24>)
     382:	1c22      	adds	r2, r4, #0
     384:	3301      	adds	r3, #1
     386:	4d03      	ldr	r5, [pc, #12]	; (394 <Flush_Tx+0x28>)
     388:	47a8      	blx	r5
	ReturnFlag = ReadArray[0];
     38a:	7820      	ldrb	r0, [r4, #0]
	return (ReturnFlag);
}
     38c:	b003      	add	sp, #12
     38e:	bd30      	pop	{r4, r5, pc}
     390:	20004118 	.word	0x20004118
     394:	00000105 	.word	0x00000105

00000398 <Flush_Rx>:

unsigned char Flush_Rx()
{
     398:	b530      	push	{r4, r5, lr}
     39a:	b083      	sub	sp, #12
	unsigned char ReturnFlag = 0;
	unsigned char ReadArray[2] = {0, 0};
     39c:	ac01      	add	r4, sp, #4
     39e:	2300      	movs	r3, #0
     3a0:	7023      	strb	r3, [r4, #0]
     3a2:	7063      	strb	r3, [r4, #1]
	unsigned char SendArray[2] = {FLUSH_RX, 0};
     3a4:	22e2      	movs	r2, #226	; 0xe2
     3a6:	4669      	mov	r1, sp
     3a8:	700a      	strb	r2, [r1, #0]
     3aa:	704b      	strb	r3, [r1, #1]
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, SendArray, ReadArray, 1);
     3ac:	4803      	ldr	r0, [pc, #12]	; (3bc <Flush_Rx+0x24>)
     3ae:	1c22      	adds	r2, r4, #0
     3b0:	3301      	adds	r3, #1
     3b2:	4d03      	ldr	r5, [pc, #12]	; (3c0 <Flush_Rx+0x28>)
     3b4:	47a8      	blx	r5
	ReturnFlag = ReadArray[0];
     3b6:	7820      	ldrb	r0, [r4, #0]
	return (ReturnFlag);
}
     3b8:	b003      	add	sp, #12
     3ba:	bd30      	pop	{r4, r5, pc}
     3bc:	20004118 	.word	0x20004118
     3c0:	00000105 	.word	0x00000105

000003c4 <Set_NRF24L_Rx_Mode>:
	Write_Register(7, SendArray, ReadArray, 1); //
}


void Set_NRF24L_Rx_Mode()
{
     3c4:	b570      	push	{r4, r5, r6, lr}
     3c6:	b084      	sub	sp, #16
	} else {
		port_base->OUTCLR.reg = pin_mask;
     3c8:	4d10      	ldr	r5, [pc, #64]	; (40c <Set_NRF24L_Rx_Mode+0x48>)
     3ca:	2680      	movs	r6, #128	; 0x80
     3cc:	0376      	lsls	r6, r6, #13
     3ce:	616e      	str	r6, [r5, #20]
	CE_OFF;
	//Delay_ms(100);
	delay_cycles_ms(100);
     3d0:	2064      	movs	r0, #100	; 0x64
     3d2:	4b0f      	ldr	r3, [pc, #60]	; (410 <Set_NRF24L_Rx_Mode+0x4c>)
     3d4:	4798      	blx	r3
	unsigned char SendArray[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     3d6:	ac01      	add	r4, sp, #4
     3d8:	2300      	movs	r3, #0
     3da:	7023      	strb	r3, [r4, #0]
     3dc:	7063      	strb	r3, [r4, #1]
     3de:	70a3      	strb	r3, [r4, #2]
     3e0:	70e3      	strb	r3, [r4, #3]
     3e2:	7123      	strb	r3, [r4, #4]
     3e4:	7163      	strb	r3, [r4, #5]
     3e6:	71a3      	strb	r3, [r4, #6]
     3e8:	71e3      	strb	r3, [r4, #7]
     3ea:	7223      	strb	r3, [r4, #8]
     3ec:	7263      	strb	r3, [r4, #9]

	Flush_Tx();
     3ee:	4b09      	ldr	r3, [pc, #36]	; (414 <Set_NRF24L_Rx_Mode+0x50>)
     3f0:	4798      	blx	r3
	Flush_Rx();
     3f2:	4b09      	ldr	r3, [pc, #36]	; (418 <Set_NRF24L_Rx_Mode+0x54>)
     3f4:	4798      	blx	r3

	SendArray[0] = 0x0F;
     3f6:	230f      	movs	r3, #15
     3f8:	7023      	strb	r3, [r4, #0]
	Write_Reg_Varified(0x00, SendArray, 1);
     3fa:	2000      	movs	r0, #0
     3fc:	1c21      	adds	r1, r4, #0
     3fe:	2201      	movs	r2, #1
     400:	4b06      	ldr	r3, [pc, #24]	; (41c <Set_NRF24L_Rx_Mode+0x58>)
     402:	4798      	blx	r3
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     404:	61ae      	str	r6, [r5, #24]

	CE_ON;
}
     406:	b004      	add	sp, #16
     408:	bd70      	pop	{r4, r5, r6, pc}
     40a:	46c0      	nop			; (mov r8, r8)
     40c:	41004400 	.word	0x41004400
     410:	000008d1 	.word	0x000008d1
     414:	0000036d 	.word	0x0000036d
     418:	00000399 	.word	0x00000399
     41c:	000002b5 	.word	0x000002b5

00000420 <Set_NRF24L_Tx_Mode>:

void Set_NRF24L_Tx_Mode()
{
     420:	b510      	push	{r4, lr}
     422:	b084      	sub	sp, #16
	} else {
		port_base->OUTCLR.reg = pin_mask;
     424:	2280      	movs	r2, #128	; 0x80
     426:	0352      	lsls	r2, r2, #13
     428:	4b0e      	ldr	r3, [pc, #56]	; (464 <Set_NRF24L_Tx_Mode+0x44>)
     42a:	615a      	str	r2, [r3, #20]
	CE_OFF;
	//Delay_ms(100);
	delay_cycles_ms(100);
     42c:	2064      	movs	r0, #100	; 0x64
     42e:	4b0e      	ldr	r3, [pc, #56]	; (468 <Set_NRF24L_Tx_Mode+0x48>)
     430:	4798      	blx	r3
	unsigned char SendArray[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     432:	ac01      	add	r4, sp, #4
     434:	2300      	movs	r3, #0
     436:	7023      	strb	r3, [r4, #0]
     438:	7063      	strb	r3, [r4, #1]
     43a:	70a3      	strb	r3, [r4, #2]
     43c:	70e3      	strb	r3, [r4, #3]
     43e:	7123      	strb	r3, [r4, #4]
     440:	7163      	strb	r3, [r4, #5]
     442:	71a3      	strb	r3, [r4, #6]
     444:	71e3      	strb	r3, [r4, #7]
     446:	7223      	strb	r3, [r4, #8]
     448:	7263      	strb	r3, [r4, #9]

	Flush_Tx();
     44a:	4b08      	ldr	r3, [pc, #32]	; (46c <Set_NRF24L_Tx_Mode+0x4c>)
     44c:	4798      	blx	r3
	Flush_Rx();
     44e:	4b08      	ldr	r3, [pc, #32]	; (470 <Set_NRF24L_Tx_Mode+0x50>)
     450:	4798      	blx	r3

	SendArray[0] = 0x0E;
     452:	230e      	movs	r3, #14
     454:	7023      	strb	r3, [r4, #0]
	Write_Reg_Varified(0x00, SendArray, 1);
     456:	2000      	movs	r0, #0
     458:	1c21      	adds	r1, r4, #0
     45a:	2201      	movs	r2, #1
     45c:	4b05      	ldr	r3, [pc, #20]	; (474 <Set_NRF24L_Tx_Mode+0x54>)
     45e:	4798      	blx	r3
}
     460:	b004      	add	sp, #16
     462:	bd10      	pop	{r4, pc}
     464:	41004400 	.word	0x41004400
     468:	000008d1 	.word	0x000008d1
     46c:	0000036d 	.word	0x0000036d
     470:	00000399 	.word	0x00000399
     474:	000002b5 	.word	0x000002b5

00000478 <Init_NRF24L_Reciever>:
	Write_Reg_Varified(0x00, SendArray, 1);
}


void Init_NRF24L_Reciever()
{
     478:	b5f0      	push	{r4, r5, r6, r7, lr}
     47a:	465f      	mov	r7, fp
     47c:	4656      	mov	r6, sl
     47e:	464d      	mov	r5, r9
     480:	4644      	mov	r4, r8
     482:	b4f0      	push	{r4, r5, r6, r7}
     484:	b087      	sub	sp, #28
     486:	2280      	movs	r2, #128	; 0x80
     488:	0352      	lsls	r2, r2, #13
     48a:	4b34      	ldr	r3, [pc, #208]	; (55c <Init_NRF24L_Reciever+0xe4>)
     48c:	615a      	str	r2, [r3, #20]

	//unsigned char TempValue = 0;

	CE_OFF;
	//Delay_ms(100);
	delay_cycles_ms(100);
     48e:	2064      	movs	r0, #100	; 0x64
     490:	4b33      	ldr	r3, [pc, #204]	; (560 <Init_NRF24L_Reciever+0xe8>)
     492:	4798      	blx	r3
	//Write_Register(unsigned char RegisterNumber, unsigned char * SendArray, unsigned char * RecievedArray, unsigned char NumOfBytesToRead)
	unsigned char SendArray[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     494:	ac03      	add	r4, sp, #12
     496:	2500      	movs	r5, #0
     498:	7065      	strb	r5, [r4, #1]
     49a:	70a5      	strb	r5, [r4, #2]
     49c:	70e5      	strb	r5, [r4, #3]
     49e:	7125      	strb	r5, [r4, #4]
     4a0:	7165      	strb	r5, [r4, #5]
     4a2:	71a5      	strb	r5, [r4, #6]
     4a4:	71e5      	strb	r5, [r4, #7]
     4a6:	7225      	strb	r5, [r4, #8]
     4a8:	7265      	strb	r5, [r4, #9]
	unsigned char ReadArray[10];


	SendArray[0] = 0x26; //TX not-power-up 2_byte_CRC EnableCRC
     4aa:	2326      	movs	r3, #38	; 0x26
     4ac:	7023      	strb	r3, [r4, #0]
	//
	//unsigned char Write_Reg_Varified(unsigned char RegisterNumber, unsigned char * SendArray, unsigned char NumOfBytesToRead)
	Write_Reg_Varified(6, SendArray, 1);
     4ae:	2006      	movs	r0, #6
     4b0:	1c21      	adds	r1, r4, #0
     4b2:	2201      	movs	r2, #1
     4b4:	4e2b      	ldr	r6, [pc, #172]	; (564 <Init_NRF24L_Reciever+0xec>)
     4b6:	47b0      	blx	r6

	SendArray[0] = 0x05;
     4b8:	2305      	movs	r3, #5
     4ba:	7023      	strb	r3, [r4, #0]
	Write_Reg_Varified(0x11, SendArray, 1);
     4bc:	2011      	movs	r0, #17
     4be:	1c21      	adds	r1, r4, #0
     4c0:	2201      	movs	r2, #1
     4c2:	47b0      	blx	r6

	SendArray[0] = 0x00;
     4c4:	7025      	strb	r5, [r4, #0]
	Write_Reg_Varified(0x05, SendArray, 1);
     4c6:	2005      	movs	r0, #5
     4c8:	1c21      	adds	r1, r4, #0
     4ca:	2201      	movs	r2, #1
     4cc:	47b0      	blx	r6

	SendArray[0] = 0x11;
     4ce:	2311      	movs	r3, #17
     4d0:	469b      	mov	fp, r3
     4d2:	7023      	strb	r3, [r4, #0]
	SendArray[1] = 0x22;
     4d4:	2322      	movs	r3, #34	; 0x22
     4d6:	469a      	mov	sl, r3
     4d8:	7063      	strb	r3, [r4, #1]
	SendArray[2] = 0x33;
     4da:	2333      	movs	r3, #51	; 0x33
     4dc:	4699      	mov	r9, r3
     4de:	70a3      	strb	r3, [r4, #2]
	SendArray[3] = 0x44;
     4e0:	2344      	movs	r3, #68	; 0x44
     4e2:	4698      	mov	r8, r3
     4e4:	70e3      	strb	r3, [r4, #3]
	SendArray[4] = 0x55;
     4e6:	2755      	movs	r7, #85	; 0x55
     4e8:	7127      	strb	r7, [r4, #4]
	Write_Register(0x0A, SendArray, ReadArray, 5);
     4ea:	200a      	movs	r0, #10
     4ec:	1c21      	adds	r1, r4, #0
     4ee:	466a      	mov	r2, sp
     4f0:	2305      	movs	r3, #5
     4f2:	4d1d      	ldr	r5, [pc, #116]	; (568 <Init_NRF24L_Reciever+0xf0>)
     4f4:	47a8      	blx	r5
	//Write_Reg_Varified(0x0A, SendArray, 5);

	SendArray[0] = 0x11;
     4f6:	465b      	mov	r3, fp
     4f8:	7023      	strb	r3, [r4, #0]
	SendArray[1] = 0x22;
     4fa:	4653      	mov	r3, sl
     4fc:	7063      	strb	r3, [r4, #1]
	SendArray[2] = 0x33;
     4fe:	464b      	mov	r3, r9
     500:	70a3      	strb	r3, [r4, #2]
	SendArray[3] = 0x44;
     502:	4643      	mov	r3, r8
     504:	70e3      	strb	r3, [r4, #3]
	SendArray[4] = 0x55;
     506:	7127      	strb	r7, [r4, #4]
	Write_Register(0x10, SendArray, ReadArray, 5);
     508:	2010      	movs	r0, #16
     50a:	1c21      	adds	r1, r4, #0
     50c:	466a      	mov	r2, sp
     50e:	2305      	movs	r3, #5
     510:	47a8      	blx	r5
	//Write_Reg_Varified(0x10, SendArray, 5);

	SendArray[0] = 0x01;
     512:	2501      	movs	r5, #1
     514:	7025      	strb	r5, [r4, #0]
	Write_Reg_Varified(0x02, SendArray, 1);
     516:	2002      	movs	r0, #2
     518:	1c21      	adds	r1, r4, #0
     51a:	2201      	movs	r2, #1
     51c:	47b0      	blx	r6

	Clear_NRF_Int_Flags();
     51e:	4b13      	ldr	r3, [pc, #76]	; (56c <Init_NRF24L_Reciever+0xf4>)
     520:	4798      	blx	r3

	SendArray[0] = 0x01;
     522:	7025      	strb	r5, [r4, #0]
	Write_Reg_Varified(0x01, SendArray, 1);
     524:	2001      	movs	r0, #1
     526:	1c21      	adds	r1, r4, #0
     528:	2201      	movs	r2, #1
     52a:	47b0      	blx	r6

	SendArray[0] = 0x2F;
     52c:	232f      	movs	r3, #47	; 0x2f
     52e:	7023      	strb	r3, [r4, #0]
	Write_Reg_Varified(0x04, SendArray, 1);
     530:	2004      	movs	r0, #4
     532:	1c21      	adds	r1, r4, #0
     534:	2201      	movs	r2, #1
     536:	47b0      	blx	r6

	Flush_Tx();
     538:	4b0d      	ldr	r3, [pc, #52]	; (570 <Init_NRF24L_Reciever+0xf8>)
     53a:	4798      	blx	r3
	Flush_Rx();
     53c:	4b0d      	ldr	r3, [pc, #52]	; (574 <Init_NRF24L_Reciever+0xfc>)
     53e:	4798      	blx	r3

	SendArray[0] = 0x0F;
     540:	230f      	movs	r3, #15
     542:	7023      	strb	r3, [r4, #0]
	Write_Reg_Varified(0x00, SendArray, 1);
     544:	2000      	movs	r0, #0
     546:	1c21      	adds	r1, r4, #0
     548:	2201      	movs	r2, #1
     54a:	47b0      	blx	r6
}
     54c:	b007      	add	sp, #28
     54e:	bc3c      	pop	{r2, r3, r4, r5}
     550:	4690      	mov	r8, r2
     552:	4699      	mov	r9, r3
     554:	46a2      	mov	sl, r4
     556:	46ab      	mov	fp, r5
     558:	bdf0      	pop	{r4, r5, r6, r7, pc}
     55a:	46c0      	nop			; (mov r8, r8)
     55c:	41004400 	.word	0x41004400
     560:	000008d1 	.word	0x000008d1
     564:	000002b5 	.word	0x000002b5
     568:	0000024d 	.word	0x0000024d
     56c:	0000033d 	.word	0x0000033d
     570:	0000036d 	.word	0x0000036d
     574:	00000399 	.word	0x00000399

00000578 <ReadPayload>:

	return (ReturnFlag);
}

unsigned char ReadPayload(unsigned char * ReadArray, unsigned char NumberOfBytesToRead)
{
     578:	b570      	push	{r4, r5, r6, lr}
     57a:	b0b2      	sub	sp, #200	; 0xc8
     57c:	1c05      	adds	r5, r0, #0
     57e:	1c0c      	adds	r4, r1, #0
	unsigned char ReturnFlag = 0;
	unsigned char TempSendArray[100];
	unsigned char TempReadArray[100];
	unsigned char Count = 0;
	TempSendArray[0] = R_RX_PAYLOAD;
     580:	a919      	add	r1, sp, #100	; 0x64
     582:	2361      	movs	r3, #97	; 0x61
     584:	700b      	strb	r3, [r1, #0]
	//(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	//DSPI_DRV_MasterTransferBlocking(FSL_DSPICOM1, NULL, TempSendArray, TempReadArray, NumberOfBytesToRead + 1, 10000);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumberOfBytesToRead + 1);
     586:	1c63      	adds	r3, r4, #1
     588:	480a      	ldr	r0, [pc, #40]	; (5b4 <ReadPayload+0x3c>)
     58a:	466a      	mov	r2, sp
     58c:	4e0a      	ldr	r6, [pc, #40]	; (5b8 <ReadPayload+0x40>)
     58e:	47b0      	blx	r6
	while(NumberOfBytesToRead > Count)
     590:	2c00      	cmp	r4, #0
     592:	d00a      	beq.n	5aa <ReadPayload+0x32>
     594:	1e61      	subs	r1, r4, #1
     596:	b2c9      	uxtb	r1, r1
     598:	3101      	adds	r1, #1
     59a:	2300      	movs	r3, #0
     59c:	1c1a      	adds	r2, r3, #0
     59e:	446a      	add	r2, sp
	{

		ReadArray[Count] = TempReadArray[Count + 1];
     5a0:	7852      	ldrb	r2, [r2, #1]
     5a2:	54ea      	strb	r2, [r5, r3]
     5a4:	3301      	adds	r3, #1
	unsigned char Count = 0;
	TempSendArray[0] = R_RX_PAYLOAD;
	//(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	//DSPI_DRV_MasterTransferBlocking(FSL_DSPICOM1, NULL, TempSendArray, TempReadArray, NumberOfBytesToRead + 1, 10000);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumberOfBytesToRead + 1);
	while(NumberOfBytesToRead > Count)
     5a6:	428b      	cmp	r3, r1
     5a8:	d1f8      	bne.n	59c <ReadPayload+0x24>

		ReadArray[Count] = TempReadArray[Count + 1];
		Count++;
	}

	Flush_Rx();
     5aa:	4b04      	ldr	r3, [pc, #16]	; (5bc <ReadPayload+0x44>)
     5ac:	4798      	blx	r3

	return (ReturnFlag);
}
     5ae:	2000      	movs	r0, #0
     5b0:	b032      	add	sp, #200	; 0xc8
     5b2:	bd70      	pop	{r4, r5, r6, pc}
     5b4:	20004118 	.word	0x20004118
     5b8:	00000105 	.word	0x00000105
     5bc:	00000399 	.word	0x00000399

000005c0 <SendNewPayload>:

unsigned char SendNewPayload(unsigned char * PayloadArrayToSend, unsigned char NumberOfBytesToSend)
{
     5c0:	b570      	push	{r4, r5, r6, lr}
     5c2:	b0a0      	sub	sp, #128	; 0x80
     5c4:	1c05      	adds	r5, r0, #0
     5c6:	1c0e      	adds	r6, r1, #0
	unsigned char TempReadArray[50];
	unsigned char SendArray[10];
	unsigned char ReadArray[10];
	unsigned char Counter = 0;

	SendArray[0] = 0x0E; //TX not-power-up 2_byte_CRC EnableCRC
     5c8:	a903      	add	r1, sp, #12
     5ca:	230e      	movs	r3, #14
     5cc:	700b      	strb	r3, [r1, #0]
	Write_Register(0, SendArray, ReadArray, 1); // power up rf mod.
     5ce:	2000      	movs	r0, #0
     5d0:	466a      	mov	r2, sp
     5d2:	3b0d      	subs	r3, #13
     5d4:	4c14      	ldr	r4, [pc, #80]	; (628 <SendNewPayload+0x68>)
     5d6:	47a0      	blx	r4
	Flush_Tx();
     5d8:	4b14      	ldr	r3, [pc, #80]	; (62c <SendNewPayload+0x6c>)
     5da:	4798      	blx	r3
	Flush_Rx();
     5dc:	4b14      	ldr	r3, [pc, #80]	; (630 <SendNewPayload+0x70>)
     5de:	4798      	blx	r3
	TempSendArray[0] = W_TX_PAYLOAD;
     5e0:	22a0      	movs	r2, #160	; 0xa0
     5e2:	ab13      	add	r3, sp, #76	; 0x4c
     5e4:	701a      	strb	r2, [r3, #0]

	while(NumberOfBytesToSend > Counter)
     5e6:	2e00      	cmp	r6, #0
     5e8:	d00a      	beq.n	600 <SendNewPayload+0x40>
     5ea:	1e74      	subs	r4, r6, #1
     5ec:	b2e4      	uxtb	r4, r4
     5ee:	3401      	adds	r4, #1
     5f0:	2200      	movs	r2, #0
     5f2:	ab13      	add	r3, sp, #76	; 0x4c
     5f4:	1899      	adds	r1, r3, r2
	{
		TempSendArray[Counter + 1] = PayloadArrayToSend[Counter];
     5f6:	5ca8      	ldrb	r0, [r5, r2]
     5f8:	7048      	strb	r0, [r1, #1]
     5fa:	3201      	adds	r2, #1
	Write_Register(0, SendArray, ReadArray, 1); // power up rf mod.
	Flush_Tx();
	Flush_Rx();
	TempSendArray[0] = W_TX_PAYLOAD;

	while(NumberOfBytesToSend > Counter)
     5fc:	42a2      	cmp	r2, r4
     5fe:	d1f8      	bne.n	5f2 <SendNewPayload+0x32>
		TempSendArray[Counter + 1] = PayloadArrayToSend[Counter];
		Counter++;
	}
	
	//DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumOfBytesToRead + 1);
	DSPI_DRV_MasterTransferBlocking(&spi_master_instance, TempSendArray, TempReadArray, NumberOfBytesToSend + 1);
     600:	ac06      	add	r4, sp, #24
     602:	1c73      	adds	r3, r6, #1
     604:	480b      	ldr	r0, [pc, #44]	; (634 <SendNewPayload+0x74>)
     606:	a913      	add	r1, sp, #76	; 0x4c
     608:	1c22      	adds	r2, r4, #0
     60a:	4d0b      	ldr	r5, [pc, #44]	; (638 <SendNewPayload+0x78>)
     60c:	47a8      	blx	r5
	ReturnFlag = TempReadArray[0];
     60e:	7826      	ldrb	r6, [r4, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     610:	4c0a      	ldr	r4, [pc, #40]	; (63c <SendNewPayload+0x7c>)
     612:	2580      	movs	r5, #128	; 0x80
     614:	036d      	lsls	r5, r5, #13
     616:	61a5      	str	r5, [r4, #24]

	CE_ON;
	//Delay_ms(1);
	delay_cycles_ms(1);
     618:	2001      	movs	r0, #1
     61a:	4b09      	ldr	r3, [pc, #36]	; (640 <SendNewPayload+0x80>)
     61c:	4798      	blx	r3
	} else {
		port_base->OUTCLR.reg = pin_mask;
     61e:	6165      	str	r5, [r4, #20]
	CE_OFF;

	return (ReturnFlag);
}
     620:	1c30      	adds	r0, r6, #0
     622:	b020      	add	sp, #128	; 0x80
     624:	bd70      	pop	{r4, r5, r6, pc}
     626:	46c0      	nop			; (mov r8, r8)
     628:	0000024d 	.word	0x0000024d
     62c:	0000036d 	.word	0x0000036d
     630:	00000399 	.word	0x00000399
     634:	20004118 	.word	0x20004118
     638:	00000105 	.word	0x00000105
     63c:	41004400 	.word	0x41004400
     640:	000008d1 	.word	0x000008d1

00000644 <ssd1306_write_command>:
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
void ssd1306_write_command(uint8_t command)
{
     644:	b5f0      	push	{r4, r5, r6, r7, lr}
     646:	b083      	sub	sp, #12
     648:	466b      	mov	r3, sp
     64a:	1ddf      	adds	r7, r3, #7
     64c:	71d8      	strb	r0, [r3, #7]
	spi_select_slave(&ssd1306_master, &ssd1306_slave, true);
     64e:	4c0b      	ldr	r4, [pc, #44]	; (67c <ssd1306_write_command+0x38>)
     650:	4e0b      	ldr	r6, [pc, #44]	; (680 <ssd1306_write_command+0x3c>)
     652:	1c20      	adds	r0, r4, #0
     654:	1c31      	adds	r1, r6, #0
     656:	2201      	movs	r2, #1
     658:	4d0a      	ldr	r5, [pc, #40]	; (684 <ssd1306_write_command+0x40>)
     65a:	47a8      	blx	r5
     65c:	2280      	movs	r2, #128	; 0x80
     65e:	05d2      	lsls	r2, r2, #23
     660:	4b09      	ldr	r3, [pc, #36]	; (688 <ssd1306_write_command+0x44>)
     662:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(SSD1306_DC_PIN, false);
	spi_write_buffer_wait(&ssd1306_master, &command, 1);
     664:	1c20      	adds	r0, r4, #0
     666:	1c39      	adds	r1, r7, #0
     668:	2201      	movs	r2, #1
     66a:	4b08      	ldr	r3, [pc, #32]	; (68c <ssd1306_write_command+0x48>)
     66c:	4798      	blx	r3
	spi_select_slave(&ssd1306_master, &ssd1306_slave, false);
     66e:	1c20      	adds	r0, r4, #0
     670:	1c31      	adds	r1, r6, #0
     672:	2200      	movs	r2, #0
     674:	47a8      	blx	r5
}
     676:	b003      	add	sp, #12
     678:	bdf0      	pop	{r4, r5, r6, r7, pc}
     67a:	46c0      	nop			; (mov r8, r8)
     67c:	20004124 	.word	0x20004124
     680:	2000412c 	.word	0x2000412c
     684:	00001721 	.word	0x00001721
     688:	41004480 	.word	0x41004480
     68c:	0000180d 	.word	0x0000180d

00000690 <ssd1306_init>:
 * Call this function to initialize the hardware interface and the OLED
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void ssd1306_init(void)
{
     690:	b510      	push	{r4, lr}
     692:	b08e      	sub	sp, #56	; 0x38
	// Initialize delay routine
	delay_init();
     694:	4b5c      	ldr	r3, [pc, #368]	; (808 <ssd1306_init+0x178>)
     696:	4798      	blx	r3
 *
 * This functions will reset the OLED controller by setting the reset pin low.
 */
static inline void ssd1306_hard_reset(void)
{
	uint32_t delay_10us = 10 * (system_gclk_gen_get_hz(0)/1000000);
     698:	2000      	movs	r0, #0
     69a:	4b5c      	ldr	r3, [pc, #368]	; (80c <ssd1306_init+0x17c>)
     69c:	4798      	blx	r3
     69e:	495c      	ldr	r1, [pc, #368]	; (810 <ssd1306_init+0x180>)
     6a0:	4b5c      	ldr	r3, [pc, #368]	; (814 <ssd1306_init+0x184>)
     6a2:	4798      	blx	r3
     6a4:	0083      	lsls	r3, r0, #2
     6a6:	1818      	adds	r0, r3, r0
     6a8:	0040      	lsls	r0, r0, #1
     6aa:	2280      	movs	r2, #128	; 0x80
     6ac:	0512      	lsls	r2, r2, #20
     6ae:	4b5a      	ldr	r3, [pc, #360]	; (818 <ssd1306_init+0x188>)
     6b0:	615a      	str	r2, [r3, #20]
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
     6b2:	2800      	cmp	r0, #0
     6b4:	d100      	bne.n	6b8 <ssd1306_init+0x28>
     6b6:	e094      	b.n	7e2 <ssd1306_init+0x152>
		SysTick->LOAD = n;
     6b8:	4b58      	ldr	r3, [pc, #352]	; (81c <ssd1306_init+0x18c>)
     6ba:	6058      	str	r0, [r3, #4]
		SysTick->VAL = 0;
     6bc:	2200      	movs	r2, #0
     6be:	609a      	str	r2, [r3, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
     6c0:	1c19      	adds	r1, r3, #0
     6c2:	2280      	movs	r2, #128	; 0x80
     6c4:	0252      	lsls	r2, r2, #9
     6c6:	680b      	ldr	r3, [r1, #0]
     6c8:	4213      	tst	r3, r2
     6ca:	d0fc      	beq.n	6c6 <ssd1306_init+0x36>
     6cc:	e08e      	b.n	7ec <ssd1306_init+0x15c>
     6ce:	680b      	ldr	r3, [r1, #0]
     6d0:	4213      	tst	r3, r2
     6d2:	d0fc      	beq.n	6ce <ssd1306_init+0x3e>
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
     6d4:	4c52      	ldr	r4, [pc, #328]	; (820 <ssd1306_init+0x190>)
     6d6:	2331      	movs	r3, #49	; 0x31
     6d8:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
     6da:	2300      	movs	r3, #0
     6dc:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
     6de:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     6e0:	a901      	add	r1, sp, #4
     6e2:	2201      	movs	r2, #1
     6e4:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
     6e6:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
     6e8:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
     6ea:	2031      	movs	r0, #49	; 0x31
     6ec:	4b4d      	ldr	r3, [pc, #308]	; (824 <ssd1306_init+0x194>)
     6ee:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
     6f0:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     6f2:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
     6f4:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     6f6:	2900      	cmp	r1, #0
     6f8:	d104      	bne.n	704 <ssd1306_init+0x74>
		return &(ports[port_index]->Group[group_index]);
     6fa:	095a      	lsrs	r2, r3, #5
     6fc:	01d2      	lsls	r2, r2, #7
     6fe:	4946      	ldr	r1, [pc, #280]	; (818 <ssd1306_init+0x188>)
     700:	468c      	mov	ip, r1
     702:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
     704:	211f      	movs	r1, #31
     706:	400b      	ands	r3, r1
     708:	391e      	subs	r1, #30
     70a:	1c08      	adds	r0, r1, #0
     70c:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     70e:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
     710:	aa01      	add	r2, sp, #4
     712:	7011      	strb	r1, [r2, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
     714:	2300      	movs	r3, #0
     716:	6053      	str	r3, [r2, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
     718:	6093      	str	r3, [r2, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
     71a:	7413      	strb	r3, [r2, #16]
	config->run_in_standby   = false;
     71c:	7453      	strb	r3, [r2, #17]
	config->receiver_enable  = true;
     71e:	7491      	strb	r1, [r2, #18]
	config->select_slave_low_detect_enable= true;
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;
     720:	311f      	adds	r1, #31
     722:	5453      	strb	r3, [r2, r1]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
     724:	9307      	str	r3, [sp, #28]
     726:	9308      	str	r3, [sp, #32]
	slave_config.ss_pin = SSD1306_CS_PIN;
	spi_attach_slave(&ssd1306_slave, &slave_config);

	spi_get_config_defaults(&config);

	config.mux_setting = SSD1306_SPI_PINMUX_SETTING;
     728:	2380      	movs	r3, #128	; 0x80
     72a:	025b      	lsls	r3, r3, #9
     72c:	60d3      	str	r3, [r2, #12]
	config.pinmux_pad0 = SSD1306_SPI_PINMUX_PAD0;
     72e:	4b3e      	ldr	r3, [pc, #248]	; (828 <ssd1306_init+0x198>)
     730:	6253      	str	r3, [r2, #36]	; 0x24
	config.pinmux_pad1 = SSD1306_SPI_PINMUX_PAD1;
     732:	2301      	movs	r3, #1
     734:	425b      	negs	r3, r3
     736:	6293      	str	r3, [r2, #40]	; 0x28
	config.pinmux_pad2 = SSD1306_SPI_PINMUX_PAD2;
     738:	4b3c      	ldr	r3, [pc, #240]	; (82c <ssd1306_init+0x19c>)
     73a:	62d3      	str	r3, [r2, #44]	; 0x2c
	config.pinmux_pad3 = SSD1306_SPI_PINMUX_PAD3;
     73c:	4b3c      	ldr	r3, [pc, #240]	; (830 <ssd1306_init+0x1a0>)
     73e:	6313      	str	r3, [r2, #48]	; 0x30
	config.mode_specific.master.baudrate = SSD1306_CLOCK_SPEED;
     740:	4b3c      	ldr	r3, [pc, #240]	; (834 <ssd1306_init+0x1a4>)
     742:	6153      	str	r3, [r2, #20]

	spi_init(&ssd1306_master, SSD1306_SPI, &config);
     744:	4c3c      	ldr	r4, [pc, #240]	; (838 <ssd1306_init+0x1a8>)
     746:	1c20      	adds	r0, r4, #0
     748:	493c      	ldr	r1, [pc, #240]	; (83c <ssd1306_init+0x1ac>)
     74a:	4b3d      	ldr	r3, [pc, #244]	; (840 <ssd1306_init+0x1b0>)
     74c:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     74e:	6822      	ldr	r2, [r4, #0]
#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
     750:	8a13      	ldrh	r3, [r2, #16]
     752:	0bdb      	lsrs	r3, r3, #15
     754:	03db      	lsls	r3, r3, #15

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
     756:	b29b      	uxth	r3, r3
     758:	2b00      	cmp	r3, #0
     75a:	d1f9      	bne.n	750 <ssd1306_init+0xc0>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     75c:	6811      	ldr	r1, [r2, #0]
     75e:	3302      	adds	r3, #2
     760:	430b      	orrs	r3, r1
     762:	6013      	str	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     764:	2301      	movs	r3, #1
     766:	466a      	mov	r2, sp
     768:	7053      	strb	r3, [r2, #1]
	config->powersave  = false;
     76a:	2200      	movs	r2, #0
     76c:	4669      	mov	r1, sp
     76e:	708a      	strb	r2, [r1, #2]
	spi_enable(&ssd1306_master);

	struct port_config pin;
	port_get_config_defaults(&pin);
	pin.direction = PORT_PIN_DIR_OUTPUT;
     770:	700b      	strb	r3, [r1, #0]

	port_pin_set_config(SSD1306_DC_PIN, &pin);
     772:	203e      	movs	r0, #62	; 0x3e
     774:	4c2b      	ldr	r4, [pc, #172]	; (824 <ssd1306_init+0x194>)
     776:	47a0      	blx	r4
	port_pin_set_config(SSD1306_RES_PIN, &pin);
     778:	201b      	movs	r0, #27
     77a:	4669      	mov	r1, sp
     77c:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     77e:	2280      	movs	r2, #128	; 0x80
     780:	0512      	lsls	r2, r2, #20
     782:	4b25      	ldr	r3, [pc, #148]	; (818 <ssd1306_init+0x188>)
     784:	619a      	str	r2, [r3, #24]

	// Set the reset pin to the default state
	port_pin_set_output_level(SSD1306_RES_PIN, true);

	// 1/32 Duty (0x0F~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
     786:	20a8      	movs	r0, #168	; 0xa8
     788:	4c2e      	ldr	r4, [pc, #184]	; (844 <ssd1306_init+0x1b4>)
     78a:	47a0      	blx	r4
	ssd1306_write_command(0x1F);
     78c:	201f      	movs	r0, #31
     78e:	47a0      	blx	r4

	// Shift Mapping RAM Counter (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
     790:	20d3      	movs	r0, #211	; 0xd3
     792:	47a0      	blx	r4
	ssd1306_write_command(0x00);
     794:	2000      	movs	r0, #0
     796:	47a0      	blx	r4

	// Set Mapping RAM Display Start Line (0x00~0x3F)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(0x00));
     798:	2040      	movs	r0, #64	; 0x40
     79a:	47a0      	blx	r4

	// Set Column Address 0 Mapped to SEG0
	ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
     79c:	20a1      	movs	r0, #161	; 0xa1
     79e:	47a0      	blx	r4

	// Set COM/Row Scan Scan from COM63 to 0
	ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
     7a0:	20c8      	movs	r0, #200	; 0xc8
     7a2:	47a0      	blx	r4

	// Set COM Pins hardware configuration
	ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
     7a4:	20da      	movs	r0, #218	; 0xda
     7a6:	47a0      	blx	r4
	ssd1306_write_command(0x02);
     7a8:	2002      	movs	r0, #2
     7aa:	47a0      	blx	r4
 *
 * \retval contrast the contrast value written to the OLED controller
 */
static inline uint8_t ssd1306_set_contrast(uint8_t contrast)
{
	ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
     7ac:	2081      	movs	r0, #129	; 0x81
     7ae:	47a0      	blx	r4
	ssd1306_write_command(contrast);
     7b0:	208f      	movs	r0, #143	; 0x8f
     7b2:	47a0      	blx	r4

	ssd1306_set_contrast(0x8F);

	// Disable Entire display On
	ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
     7b4:	20a4      	movs	r0, #164	; 0xa4
     7b6:	47a0      	blx	r4
 * This function will disable invert on all pixels on the OLED
 *
 */
static inline void ssd1306_display_invert_disable(void)
{
	ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
     7b8:	20a6      	movs	r0, #166	; 0xa6
     7ba:	47a0      	blx	r4

	ssd1306_display_invert_disable();

	// Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
     7bc:	20d5      	movs	r0, #213	; 0xd5
     7be:	47a0      	blx	r4
	ssd1306_write_command(0x80);
     7c0:	2080      	movs	r0, #128	; 0x80
     7c2:	47a0      	blx	r4

	// Enable charge pump regulator
	ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
     7c4:	208d      	movs	r0, #141	; 0x8d
     7c6:	47a0      	blx	r4
	ssd1306_write_command(0x14);
     7c8:	2014      	movs	r0, #20
     7ca:	47a0      	blx	r4

	// Set VCOMH Deselect Level
	ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
     7cc:	20db      	movs	r0, #219	; 0xdb
     7ce:	47a0      	blx	r4
	ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
     7d0:	2040      	movs	r0, #64	; 0x40
     7d2:	47a0      	blx	r4

	// Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
	ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
     7d4:	20d9      	movs	r0, #217	; 0xd9
     7d6:	47a0      	blx	r4
	ssd1306_write_command(0xF1);
     7d8:	20f1      	movs	r0, #241	; 0xf1
     7da:	47a0      	blx	r4
 *
 * This function will turn on the OLED.
 */
static inline void ssd1306_display_on(void)
{
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
     7dc:	20af      	movs	r0, #175	; 0xaf
     7de:	47a0      	blx	r4
     7e0:	e010      	b.n	804 <ssd1306_init+0x174>
     7e2:	2280      	movs	r2, #128	; 0x80
     7e4:	0512      	lsls	r2, r2, #20
     7e6:	4b0c      	ldr	r3, [pc, #48]	; (818 <ssd1306_init+0x188>)
     7e8:	619a      	str	r2, [r3, #24]
     7ea:	e773      	b.n	6d4 <ssd1306_init+0x44>
     7ec:	2280      	movs	r2, #128	; 0x80
     7ee:	0512      	lsls	r2, r2, #20
     7f0:	4b09      	ldr	r3, [pc, #36]	; (818 <ssd1306_init+0x188>)
     7f2:	619a      	str	r2, [r3, #24]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
     7f4:	4b09      	ldr	r3, [pc, #36]	; (81c <ssd1306_init+0x18c>)
     7f6:	6058      	str	r0, [r3, #4]
		SysTick->VAL = 0;
     7f8:	2200      	movs	r2, #0
     7fa:	609a      	str	r2, [r3, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
     7fc:	1c19      	adds	r1, r3, #0
     7fe:	2280      	movs	r2, #128	; 0x80
     800:	0252      	lsls	r2, r2, #9
     802:	e764      	b.n	6ce <ssd1306_init+0x3e>

	ssd1306_display_on();
}
     804:	b00e      	add	sp, #56	; 0x38
     806:	bd10      	pop	{r4, pc}
     808:	00000895 	.word	0x00000895
     80c:	000025b5 	.word	0x000025b5
     810:	000f4240 	.word	0x000f4240
     814:	00004aa9 	.word	0x00004aa9
     818:	41004400 	.word	0x41004400
     81c:	e000e010 	.word	0xe000e010
     820:	2000412c 	.word	0x2000412c
     824:	00000f3d 	.word	0x00000f3d
     828:	00300002 	.word	0x00300002
     82c:	00360003 	.word	0x00360003
     830:	00370003 	.word	0x00370003
     834:	01312d00 	.word	0x01312d00
     838:	20004124 	.word	0x20004124
     83c:	42001c00 	.word	0x42001c00
     840:	0000142d 	.word	0x0000142d
     844:	00000645 	.word	0x00000645

00000848 <ssd1306_write_data>:
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data)
{
     848:	b5f0      	push	{r4, r5, r6, r7, lr}
     84a:	b083      	sub	sp, #12
     84c:	466b      	mov	r3, sp
     84e:	1ddf      	adds	r7, r3, #7
     850:	71d8      	strb	r0, [r3, #7]
	spi_select_slave(&ssd1306_master, &ssd1306_slave, true);
     852:	4c0b      	ldr	r4, [pc, #44]	; (880 <ssd1306_write_data+0x38>)
     854:	4e0b      	ldr	r6, [pc, #44]	; (884 <ssd1306_write_data+0x3c>)
     856:	1c20      	adds	r0, r4, #0
     858:	1c31      	adds	r1, r6, #0
     85a:	2201      	movs	r2, #1
     85c:	4d0a      	ldr	r5, [pc, #40]	; (888 <ssd1306_write_data+0x40>)
     85e:	47a8      	blx	r5
     860:	2280      	movs	r2, #128	; 0x80
     862:	05d2      	lsls	r2, r2, #23
     864:	4b09      	ldr	r3, [pc, #36]	; (88c <ssd1306_write_data+0x44>)
     866:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(SSD1306_DC_PIN, true);
	spi_write_buffer_wait(&ssd1306_master, &data, 1);
     868:	1c20      	adds	r0, r4, #0
     86a:	1c39      	adds	r1, r7, #0
     86c:	2201      	movs	r2, #1
     86e:	4b08      	ldr	r3, [pc, #32]	; (890 <ssd1306_write_data+0x48>)
     870:	4798      	blx	r3
	spi_select_slave(&ssd1306_master, &ssd1306_slave, false);
     872:	1c20      	adds	r0, r4, #0
     874:	1c31      	adds	r1, r6, #0
     876:	2200      	movs	r2, #0
     878:	47a8      	blx	r5
}
     87a:	b003      	add	sp, #12
     87c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     87e:	46c0      	nop			; (mov r8, r8)
     880:	20004124 	.word	0x20004124
     884:	2000412c 	.word	0x2000412c
     888:	00001721 	.word	0x00001721
     88c:	41004480 	.word	0x41004480
     890:	0000180d 	.word	0x0000180d

00000894 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
     894:	b510      	push	{r4, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
     896:	2000      	movs	r0, #0
     898:	4b08      	ldr	r3, [pc, #32]	; (8bc <delay_init+0x28>)
     89a:	4798      	blx	r3
	cycles_per_ms /= 1000;
     89c:	4c08      	ldr	r4, [pc, #32]	; (8c0 <delay_init+0x2c>)
     89e:	21fa      	movs	r1, #250	; 0xfa
     8a0:	0089      	lsls	r1, r1, #2
     8a2:	47a0      	blx	r4
     8a4:	4b07      	ldr	r3, [pc, #28]	; (8c4 <delay_init+0x30>)
     8a6:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
     8a8:	21fa      	movs	r1, #250	; 0xfa
     8aa:	0089      	lsls	r1, r1, #2
     8ac:	47a0      	blx	r4
     8ae:	4b06      	ldr	r3, [pc, #24]	; (8c8 <delay_init+0x34>)
     8b0:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
     8b2:	2205      	movs	r2, #5
     8b4:	4b05      	ldr	r3, [pc, #20]	; (8cc <delay_init+0x38>)
     8b6:	601a      	str	r2, [r3, #0]
}
     8b8:	bd10      	pop	{r4, pc}
     8ba:	46c0      	nop			; (mov r8, r8)
     8bc:	000025b5 	.word	0x000025b5
     8c0:	00004aa9 	.word	0x00004aa9
     8c4:	20000004 	.word	0x20000004
     8c8:	20000000 	.word	0x20000000
     8cc:	e000e010 	.word	0xe000e010

000008d0 <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
     8d0:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
     8d2:	4b08      	ldr	r3, [pc, #32]	; (8f4 <delay_cycles_ms+0x24>)
     8d4:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
     8d6:	4a08      	ldr	r2, [pc, #32]	; (8f8 <delay_cycles_ms+0x28>)
		SysTick->VAL = 0;
     8d8:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
     8da:	2180      	movs	r1, #128	; 0x80
     8dc:	0249      	lsls	r1, r1, #9
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
     8de:	e006      	b.n	8ee <delay_cycles_ms+0x1e>
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
     8e0:	2c00      	cmp	r4, #0
     8e2:	d004      	beq.n	8ee <delay_cycles_ms+0x1e>
		SysTick->LOAD = n;
     8e4:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
     8e6:	6095      	str	r5, [r2, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
     8e8:	6813      	ldr	r3, [r2, #0]
     8ea:	420b      	tst	r3, r1
     8ec:	d0fc      	beq.n	8e8 <delay_cycles_ms+0x18>
     8ee:	3801      	subs	r0, #1
     8f0:	d2f6      	bcs.n	8e0 <delay_cycles_ms+0x10>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
     8f2:	bd30      	pop	{r4, r5, pc}
     8f4:	20000004 	.word	0x20000004
     8f8:	e000e010 	.word	0xe000e010

000008fc <gfx_mono_set_framebuffer>:
	gfx_mono_set_framebuffer(framebuffer);
\endcode
 */
void gfx_mono_set_framebuffer(uint8_t *framebuffer)
{
	fbpointer = framebuffer;
     8fc:	4b01      	ldr	r3, [pc, #4]	; (904 <gfx_mono_set_framebuffer+0x8>)
     8fe:	6018      	str	r0, [r3, #0]
}
     900:	4770      	bx	lr
     902:	46c0      	nop			; (mov r8, r8)
     904:	20000040 	.word	0x20000040

00000908 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     908:	4b02      	ldr	r3, [pc, #8]	; (914 <gfx_mono_framebuffer_put_byte+0xc>)
     90a:	681b      	ldr	r3, [r3, #0]
     90c:	01c0      	lsls	r0, r0, #7
     90e:	1841      	adds	r1, r0, r1
     910:	54ca      	strb	r2, [r1, r3]
}
     912:	4770      	bx	lr
     914:	20000040 	.word	0x20000040

00000918 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     918:	4b02      	ldr	r3, [pc, #8]	; (924 <gfx_mono_framebuffer_get_byte+0xc>)
     91a:	681b      	ldr	r3, [r3, #0]
     91c:	01c0      	lsls	r0, r0, #7
     91e:	1840      	adds	r0, r0, r1
     920:	5c18      	ldrb	r0, [r3, r0]
}
     922:	4770      	bx	lr
     924:	20000040 	.word	0x20000040

00000928 <gfx_mono_generic_draw_horizontal_line>:
 * \param[in]  length     Length of the line in pixels.
 * \param[in]  color      Pixel operation of the line.
 */
void gfx_mono_generic_draw_horizontal_line(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t length, enum gfx_mono_color color)
{
     928:	b5f0      	push	{r4, r5, r6, r7, lr}
     92a:	4657      	mov	r7, sl
     92c:	464e      	mov	r6, r9
     92e:	4645      	mov	r5, r8
     930:	b4e0      	push	{r5, r6, r7}
     932:	b082      	sub	sp, #8
	uint8_t page;
	uint8_t pixelmask;
	uint8_t temp;

	/* Clip line length if too long */
	if (x + length > GFX_MONO_LCD_WIDTH) {
     934:	1884      	adds	r4, r0, r2
     936:	2c80      	cmp	r4, #128	; 0x80
     938:	dd03      	ble.n	942 <gfx_mono_generic_draw_horizontal_line+0x1a>
		length = GFX_MONO_LCD_WIDTH - x;
     93a:	2480      	movs	r4, #128	; 0x80
     93c:	4264      	negs	r4, r4
     93e:	1a24      	subs	r4, r4, r0
     940:	b2e2      	uxtb	r2, r4
	}

	page = y / 8;
	pixelmask = (1 << (y - (page * 8)));

	if (length == 0) {
     942:	2a00      	cmp	r2, #0
     944:	d055      	beq.n	9f2 <gfx_mono_generic_draw_horizontal_line+0xca>
	/* Clip line length if too long */
	if (x + length > GFX_MONO_LCD_WIDTH) {
		length = GFX_MONO_LCD_WIDTH - x;
	}

	page = y / 8;
     946:	08cd      	lsrs	r5, r1, #3
	pixelmask = (1 << (y - (page * 8)));
     948:	00ec      	lsls	r4, r5, #3
     94a:	1b09      	subs	r1, r1, r4
     94c:	2401      	movs	r4, #1
     94e:	408c      	lsls	r4, r1
     950:	46a1      	mov	r9, r4
     952:	1c21      	adds	r1, r4, #0
     954:	466c      	mov	r4, sp
     956:	71e1      	strb	r1, [r4, #7]
     958:	79e1      	ldrb	r1, [r4, #7]
     95a:	4688      	mov	r8, r1
	if (length == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	switch (color) {
     95c:	2b01      	cmp	r3, #1
     95e:	d004      	beq.n	96a <gfx_mono_generic_draw_horizontal_line+0x42>
     960:	2b00      	cmp	r3, #0
     962:	d019      	beq.n	998 <gfx_mono_generic_draw_horizontal_line+0x70>
     964:	2b02      	cmp	r3, #2
     966:	d02e      	beq.n	9c6 <gfx_mono_generic_draw_horizontal_line+0x9e>
     968:	e043      	b.n	9f2 <gfx_mono_generic_draw_horizontal_line+0xca>
     96a:	1c14      	adds	r4, r2, #0
     96c:	1e47      	subs	r7, r0, #1
	case GFX_PIXEL_SET:
		while (length-- > 0) {
			temp = gfx_mono_get_byte(page, x + length);
     96e:	4b24      	ldr	r3, [pc, #144]	; (a00 <gfx_mono_generic_draw_horizontal_line+0xd8>)
     970:	469a      	mov	sl, r3
			temp |= pixelmask;
			gfx_mono_put_byte(page, x + length, temp);
     972:	4b24      	ldr	r3, [pc, #144]	; (a04 <gfx_mono_generic_draw_horizontal_line+0xdc>)
     974:	4699      	mov	r9, r3
     976:	19e6      	adds	r6, r4, r7
     978:	b2f6      	uxtb	r6, r6
	}

	switch (color) {
	case GFX_PIXEL_SET:
		while (length-- > 0) {
			temp = gfx_mono_get_byte(page, x + length);
     97a:	1c28      	adds	r0, r5, #0
     97c:	1c31      	adds	r1, r6, #0
     97e:	47d0      	blx	sl
			temp |= pixelmask;
     980:	4643      	mov	r3, r8
     982:	4318      	orrs	r0, r3
			gfx_mono_put_byte(page, x + length, temp);
     984:	b2c2      	uxtb	r2, r0
     986:	1c28      	adds	r0, r5, #0
     988:	1c31      	adds	r1, r6, #0
     98a:	2300      	movs	r3, #0
     98c:	47c8      	blx	r9
     98e:	3c01      	subs	r4, #1
     990:	b2e4      	uxtb	r4, r4
		return;
	}

	switch (color) {
	case GFX_PIXEL_SET:
		while (length-- > 0) {
     992:	2c00      	cmp	r4, #0
     994:	d1ef      	bne.n	976 <gfx_mono_generic_draw_horizontal_line+0x4e>
     996:	e02c      	b.n	9f2 <gfx_mono_generic_draw_horizontal_line+0xca>
	if (length == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	switch (color) {
     998:	1c14      	adds	r4, r2, #0
     99a:	1e47      	subs	r7, r0, #1
		}
		break;

	case GFX_PIXEL_CLR:
		while (length-- > 0) {
			temp = gfx_mono_get_byte(page, x + length);
     99c:	4b18      	ldr	r3, [pc, #96]	; (a00 <gfx_mono_generic_draw_horizontal_line+0xd8>)
     99e:	469a      	mov	sl, r3
			temp &= ~pixelmask;
			gfx_mono_put_byte(page, x + length, temp);
     9a0:	4b18      	ldr	r3, [pc, #96]	; (a04 <gfx_mono_generic_draw_horizontal_line+0xdc>)
     9a2:	4698      	mov	r8, r3
     9a4:	19e6      	adds	r6, r4, r7
     9a6:	b2f6      	uxtb	r6, r6
		}
		break;

	case GFX_PIXEL_CLR:
		while (length-- > 0) {
			temp = gfx_mono_get_byte(page, x + length);
     9a8:	1c28      	adds	r0, r5, #0
     9aa:	1c31      	adds	r1, r6, #0
     9ac:	47d0      	blx	sl
			temp &= ~pixelmask;
     9ae:	464b      	mov	r3, r9
     9b0:	4398      	bics	r0, r3
			gfx_mono_put_byte(page, x + length, temp);
     9b2:	b2c2      	uxtb	r2, r0
     9b4:	1c28      	adds	r0, r5, #0
     9b6:	1c31      	adds	r1, r6, #0
     9b8:	2300      	movs	r3, #0
     9ba:	47c0      	blx	r8
     9bc:	3c01      	subs	r4, #1
     9be:	b2e4      	uxtb	r4, r4
			gfx_mono_put_byte(page, x + length, temp);
		}
		break;

	case GFX_PIXEL_CLR:
		while (length-- > 0) {
     9c0:	2c00      	cmp	r4, #0
     9c2:	d1ef      	bne.n	9a4 <gfx_mono_generic_draw_horizontal_line+0x7c>
     9c4:	e015      	b.n	9f2 <gfx_mono_generic_draw_horizontal_line+0xca>
	if (length == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	switch (color) {
     9c6:	1c14      	adds	r4, r2, #0
     9c8:	1e47      	subs	r7, r0, #1
		}
		break;

	case GFX_PIXEL_XOR:
		while (length-- > 0) {
			temp = gfx_mono_get_byte(page, x + length);
     9ca:	4b0d      	ldr	r3, [pc, #52]	; (a00 <gfx_mono_generic_draw_horizontal_line+0xd8>)
     9cc:	469a      	mov	sl, r3
			temp ^= pixelmask;
			gfx_mono_put_byte(page, x + length, temp);
     9ce:	4b0d      	ldr	r3, [pc, #52]	; (a04 <gfx_mono_generic_draw_horizontal_line+0xdc>)
     9d0:	4699      	mov	r9, r3
     9d2:	19e6      	adds	r6, r4, r7
     9d4:	b2f6      	uxtb	r6, r6
		}
		break;

	case GFX_PIXEL_XOR:
		while (length-- > 0) {
			temp = gfx_mono_get_byte(page, x + length);
     9d6:	1c28      	adds	r0, r5, #0
     9d8:	1c31      	adds	r1, r6, #0
     9da:	47d0      	blx	sl
			temp ^= pixelmask;
     9dc:	4643      	mov	r3, r8
     9de:	4058      	eors	r0, r3
			gfx_mono_put_byte(page, x + length, temp);
     9e0:	b2c2      	uxtb	r2, r0
     9e2:	1c28      	adds	r0, r5, #0
     9e4:	1c31      	adds	r1, r6, #0
     9e6:	2300      	movs	r3, #0
     9e8:	47c8      	blx	r9
     9ea:	3c01      	subs	r4, #1
     9ec:	b2e4      	uxtb	r4, r4
			gfx_mono_put_byte(page, x + length, temp);
		}
		break;

	case GFX_PIXEL_XOR:
		while (length-- > 0) {
     9ee:	2c00      	cmp	r4, #0
     9f0:	d1ef      	bne.n	9d2 <gfx_mono_generic_draw_horizontal_line+0xaa>
		break;

	default:
		break;
	}
}
     9f2:	b002      	add	sp, #8
     9f4:	bc1c      	pop	{r2, r3, r4}
     9f6:	4690      	mov	r8, r2
     9f8:	4699      	mov	r9, r3
     9fa:	46a2      	mov	sl, r4
     9fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
     9fe:	46c0      	nop			; (mov r8, r8)
     a00:	00000e39 	.word	0x00000e39
     a04:	00000d2d 	.word	0x00000d2d

00000a08 <gfx_mono_generic_draw_vertical_line>:
 * \param[in]  length     Length of the line in pixels.
 * \param[in]  color      Pixel operation of the line.
 */
void gfx_mono_generic_draw_vertical_line(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t length, enum gfx_mono_color color)
{
     a08:	b5f0      	push	{r4, r5, r6, r7, lr}
     a0a:	4647      	mov	r7, r8
     a0c:	b480      	push	{r7}
     a0e:	b082      	sub	sp, #8
	if (length == 0) {
     a10:	2a00      	cmp	r2, #0
     a12:	d03d      	beq.n	a90 <gfx_mono_generic_draw_vertical_line+0x88>
     a14:	9301      	str	r3, [sp, #4]
     a16:	1c06      	adds	r6, r0, #0
     a18:	1e48      	subs	r0, r1, #1
		return;
	}

	gfx_coord_t y2 = y + length - 1;
     a1a:	1813      	adds	r3, r2, r0
     a1c:	b2db      	uxtb	r3, r3

	if (y == y2) {
     a1e:	4299      	cmp	r1, r3
     a20:	d104      	bne.n	a2c <gfx_mono_generic_draw_vertical_line+0x24>
		gfx_mono_draw_pixel(x, y, color);
     a22:	1c30      	adds	r0, r6, #0
     a24:	9a01      	ldr	r2, [sp, #4]
     a26:	4b1c      	ldr	r3, [pc, #112]	; (a98 <gfx_mono_generic_draw_vertical_line+0x90>)
     a28:	4798      	blx	r3
		return;
     a2a:	e031      	b.n	a90 <gfx_mono_generic_draw_vertical_line+0x88>
	}

	if (y2 >= GFX_MONO_LCD_HEIGHT - 1) {
     a2c:	2b3e      	cmp	r3, #62	; 0x3e
     a2e:	d900      	bls.n	a32 <gfx_mono_generic_draw_vertical_line+0x2a>
		y2 = GFX_MONO_LCD_HEIGHT - 1;
     a30:	233f      	movs	r3, #63	; 0x3f
	}

	gfx_coord_t y1page = y / 8;
     a32:	08cc      	lsrs	r4, r1, #3
	gfx_coord_t y2page = y2 / 8;
     a34:	08df      	lsrs	r7, r3, #3

	uint8_t y1bitpos = y & 0x07;
     a36:	2507      	movs	r5, #7
	uint8_t y2bitpos = y2 & 0x07;

	uint8_t y1pixelmask = 0xFF << y1bitpos;
     a38:	4029      	ands	r1, r5
     a3a:	20ff      	movs	r0, #255	; 0xff
     a3c:	1c02      	adds	r2, r0, #0
     a3e:	408a      	lsls	r2, r1
     a40:	b2d2      	uxtb	r2, r2
	uint8_t y2pixelmask = 0xFF >> (7 - y2bitpos);
     a42:	402b      	ands	r3, r5
     a44:	2107      	movs	r1, #7
     a46:	1acb      	subs	r3, r1, r3
     a48:	4118      	asrs	r0, r3
     a4a:	b2c3      	uxtb	r3, r0
     a4c:	4698      	mov	r8, r3

	/* The pixels are on the same page; combine masks */
	if (y1page == y2page) {
     a4e:	42bc      	cmp	r4, r7
     a50:	d106      	bne.n	a60 <gfx_mono_generic_draw_vertical_line+0x58>
		uint8_t pixelmask = y1pixelmask & y2pixelmask;
		gfx_mono_mask_byte(y1page, x, pixelmask, color);
     a52:	401a      	ands	r2, r3
     a54:	1c20      	adds	r0, r4, #0
     a56:	1c31      	adds	r1, r6, #0
     a58:	9b01      	ldr	r3, [sp, #4]
     a5a:	4c10      	ldr	r4, [pc, #64]	; (a9c <gfx_mono_generic_draw_vertical_line+0x94>)
     a5c:	47a0      	blx	r4
     a5e:	e017      	b.n	a90 <gfx_mono_generic_draw_vertical_line+0x88>
	} else {
		gfx_mono_mask_byte(y1page, x, y1pixelmask, color);
     a60:	1c20      	adds	r0, r4, #0
     a62:	1c31      	adds	r1, r6, #0
     a64:	9b01      	ldr	r3, [sp, #4]
     a66:	4d0d      	ldr	r5, [pc, #52]	; (a9c <gfx_mono_generic_draw_vertical_line+0x94>)
     a68:	47a8      	blx	r5

		while (++y1page < y2page) {
     a6a:	3401      	adds	r4, #1
     a6c:	42a7      	cmp	r7, r4
     a6e:	d909      	bls.n	a84 <gfx_mono_generic_draw_vertical_line+0x7c>
			gfx_mono_mask_byte(y1page, x, 0xFF, color);
     a70:	4d0a      	ldr	r5, [pc, #40]	; (a9c <gfx_mono_generic_draw_vertical_line+0x94>)
     a72:	1c20      	adds	r0, r4, #0
     a74:	1c31      	adds	r1, r6, #0
     a76:	22ff      	movs	r2, #255	; 0xff
     a78:	9b01      	ldr	r3, [sp, #4]
     a7a:	47a8      	blx	r5
		uint8_t pixelmask = y1pixelmask & y2pixelmask;
		gfx_mono_mask_byte(y1page, x, pixelmask, color);
	} else {
		gfx_mono_mask_byte(y1page, x, y1pixelmask, color);

		while (++y1page < y2page) {
     a7c:	3401      	adds	r4, #1
     a7e:	b2e4      	uxtb	r4, r4
     a80:	42a7      	cmp	r7, r4
     a82:	d8f6      	bhi.n	a72 <gfx_mono_generic_draw_vertical_line+0x6a>
			gfx_mono_mask_byte(y1page, x, 0xFF, color);
		}

		gfx_mono_mask_byte(y2page, x, y2pixelmask, color);
     a84:	1c38      	adds	r0, r7, #0
     a86:	1c31      	adds	r1, r6, #0
     a88:	4642      	mov	r2, r8
     a8a:	9b01      	ldr	r3, [sp, #4]
     a8c:	4c03      	ldr	r4, [pc, #12]	; (a9c <gfx_mono_generic_draw_vertical_line+0x94>)
     a8e:	47a0      	blx	r4
	}
}
     a90:	b002      	add	sp, #8
     a92:	bc04      	pop	{r2}
     a94:	4690      	mov	r8, r2
     a96:	bdf0      	pop	{r4, r5, r6, r7, pc}
     a98:	00000dd1 	.word	0x00000dd1
     a9c:	00000e45 	.word	0x00000e45

00000aa0 <gfx_mono_generic_draw_line>:
 * \param[in]  color       Pixel operation of the line.
 */
void gfx_mono_generic_draw_line(gfx_coord_t x1, gfx_coord_t y1,
		gfx_coord_t x2, gfx_coord_t y2,
		enum gfx_mono_color color)
{
     aa0:	b5f0      	push	{r4, r5, r6, r7, lr}
     aa2:	465f      	mov	r7, fp
     aa4:	4656      	mov	r6, sl
     aa6:	464d      	mov	r5, r9
     aa8:	4644      	mov	r4, r8
     aaa:	b4f0      	push	{r4, r5, r6, r7}
     aac:	b083      	sub	sp, #12
     aae:	1c04      	adds	r4, r0, #0
     ab0:	1c0d      	adds	r5, r1, #0
     ab2:	a90c      	add	r1, sp, #48	; 0x30
     ab4:	7809      	ldrb	r1, [r1, #0]
     ab6:	9100      	str	r1, [sp, #0]
	int8_t dx;
	int8_t dy;
	int8_t e;

	/* swap x1,y1  with x2,y2 */
	if (x1 > x2) {
     ab8:	4290      	cmp	r0, r2
     aba:	d904      	bls.n	ac6 <gfx_mono_generic_draw_line+0x26>
     abc:	1c29      	adds	r1, r5, #0
		dx = x1;
		x1 = x2;
		x2 = dx;
		dy = y1;
		y1 = y2;
     abe:	1c1d      	adds	r5, r3, #0
		y2 = dy;
     ac0:	1c0b      	adds	r3, r1, #0
	int8_t e;

	/* swap x1,y1  with x2,y2 */
	if (x1 > x2) {
		dx = x1;
		x1 = x2;
     ac2:	1c14      	adds	r4, r2, #0
		x2 = dx;
     ac4:	1c02      	adds	r2, r0, #0
		dy = y1;
		y1 = y2;
		y2 = dy;
	}

	dx = x2 - x1;
     ac6:	1b12      	subs	r2, r2, r4
     ac8:	b2d2      	uxtb	r2, r2
     aca:	b2d0      	uxtb	r0, r2
	dy = y2 - y1;
     acc:	1b5b      	subs	r3, r3, r5
     ace:	b2db      	uxtb	r3, r3
     ad0:	b2d9      	uxtb	r1, r3

	x = x1;
	y = y1;

	if (dx < 0) {
     ad2:	b246      	sxtb	r6, r0
		xinc = -1;
		dx = -dx;
	} else {
		xinc = 1;
     ad4:	2701      	movs	r7, #1
     ad6:	46ba      	mov	sl, r7
	dy = y2 - y1;

	x = x1;
	y = y1;

	if (dx < 0) {
     ad8:	2e00      	cmp	r6, #0
     ada:	da03      	bge.n	ae4 <gfx_mono_generic_draw_line+0x44>
		xinc = -1;
		dx = -dx;
     adc:	4252      	negs	r2, r2
     ade:	b2d0      	uxtb	r0, r2

	x = x1;
	y = y1;

	if (dx < 0) {
		xinc = -1;
     ae0:	22ff      	movs	r2, #255	; 0xff
     ae2:	4692      	mov	sl, r2
		dx = -dx;
	} else {
		xinc = 1;
	}

	if (dy < 0) {
     ae4:	b24a      	sxtb	r2, r1
		yinc = -1;
		dy = -dy;
	} else {
		yinc = 1;
     ae6:	2601      	movs	r6, #1
     ae8:	46b3      	mov	fp, r6
		dx = -dx;
	} else {
		xinc = 1;
	}

	if (dy < 0) {
     aea:	2a00      	cmp	r2, #0
     aec:	da03      	bge.n	af6 <gfx_mono_generic_draw_line+0x56>
		yinc = -1;
		dy = -dy;
     aee:	425b      	negs	r3, r3
     af0:	b2d9      	uxtb	r1, r3
	} else {
		xinc = 1;
	}

	if (dy < 0) {
		yinc = -1;
     af2:	23ff      	movs	r3, #255	; 0xff
     af4:	469b      	mov	fp, r3
		dy = -dy;
	} else {
		yinc = 1;
	}

	if (dx > dy) {
     af6:	b243      	sxtb	r3, r0
     af8:	b24a      	sxtb	r2, r1
     afa:	4293      	cmp	r3, r2
     afc:	dd21      	ble.n	b42 <gfx_mono_generic_draw_line+0xa2>
		e = dy - dx;
     afe:	b2cb      	uxtb	r3, r1
     b00:	4699      	mov	r9, r3
     b02:	b2c3      	uxtb	r3, r0
     b04:	9301      	str	r3, [sp, #4]
     b06:	464a      	mov	r2, r9
     b08:	1ad6      	subs	r6, r2, r3
     b0a:	b2f6      	uxtb	r6, r6
		for (i = 0; i <= dx; i++) {
     b0c:	b243      	sxtb	r3, r0
     b0e:	4698      	mov	r8, r3
     b10:	2b00      	cmp	r3, #0
     b12:	db37      	blt.n	b84 <gfx_mono_generic_draw_line+0xe4>
     b14:	2700      	movs	r7, #0
			gfx_mono_draw_pixel(x, y, color);
     b16:	1c20      	adds	r0, r4, #0
     b18:	1c29      	adds	r1, r5, #0
     b1a:	9a00      	ldr	r2, [sp, #0]
     b1c:	4b1d      	ldr	r3, [pc, #116]	; (b94 <gfx_mono_generic_draw_line+0xf4>)
     b1e:	4798      	blx	r3
			if (e >= 0) {
     b20:	b273      	sxtb	r3, r6
     b22:	2b00      	cmp	r3, #0
     b24:	db04      	blt.n	b30 <gfx_mono_generic_draw_line+0x90>
				e -= dx;
     b26:	9b01      	ldr	r3, [sp, #4]
     b28:	1af6      	subs	r6, r6, r3
     b2a:	b2f6      	uxtb	r6, r6
				y += yinc;
     b2c:	445d      	add	r5, fp
     b2e:	b2ed      	uxtb	r5, r5
			}

			e += dy;
     b30:	444e      	add	r6, r9
     b32:	b2f6      	uxtb	r6, r6
     b34:	4454      	add	r4, sl
     b36:	b2e4      	uxtb	r4, r4
		yinc = 1;
	}

	if (dx > dy) {
		e = dy - dx;
		for (i = 0; i <= dx; i++) {
     b38:	3701      	adds	r7, #1
     b3a:	b2ff      	uxtb	r7, r7
     b3c:	4547      	cmp	r7, r8
     b3e:	ddea      	ble.n	b16 <gfx_mono_generic_draw_line+0x76>
     b40:	e020      	b.n	b84 <gfx_mono_generic_draw_line+0xe4>

			e += dy;
			x += xinc;
		}
	} else {
		e = dx - dy;
     b42:	b2c3      	uxtb	r3, r0
     b44:	4698      	mov	r8, r3
     b46:	b2cb      	uxtb	r3, r1
     b48:	9301      	str	r3, [sp, #4]
     b4a:	4642      	mov	r2, r8
     b4c:	1ad6      	subs	r6, r2, r3
     b4e:	b2f6      	uxtb	r6, r6
		for (i = 0; i <= dy; i++) {
     b50:	b24b      	sxtb	r3, r1
     b52:	4699      	mov	r9, r3
     b54:	2b00      	cmp	r3, #0
     b56:	db15      	blt.n	b84 <gfx_mono_generic_draw_line+0xe4>
     b58:	2700      	movs	r7, #0
			gfx_mono_draw_pixel(x, y, color);
     b5a:	1c20      	adds	r0, r4, #0
     b5c:	1c29      	adds	r1, r5, #0
     b5e:	9a00      	ldr	r2, [sp, #0]
     b60:	4b0c      	ldr	r3, [pc, #48]	; (b94 <gfx_mono_generic_draw_line+0xf4>)
     b62:	4798      	blx	r3
			if (e >= 0) {
     b64:	b273      	sxtb	r3, r6
     b66:	2b00      	cmp	r3, #0
     b68:	db04      	blt.n	b74 <gfx_mono_generic_draw_line+0xd4>
				e -= dy;
     b6a:	9b01      	ldr	r3, [sp, #4]
     b6c:	1af6      	subs	r6, r6, r3
     b6e:	b2f6      	uxtb	r6, r6
				x += xinc;
     b70:	4454      	add	r4, sl
     b72:	b2e4      	uxtb	r4, r4
			}

			e += dx;
     b74:	4446      	add	r6, r8
     b76:	b2f6      	uxtb	r6, r6
     b78:	445d      	add	r5, fp
     b7a:	b2ed      	uxtb	r5, r5
			e += dy;
			x += xinc;
		}
	} else {
		e = dx - dy;
		for (i = 0; i <= dy; i++) {
     b7c:	3701      	adds	r7, #1
     b7e:	b2ff      	uxtb	r7, r7
     b80:	454f      	cmp	r7, r9
     b82:	ddea      	ble.n	b5a <gfx_mono_generic_draw_line+0xba>

			e += dx;
			y += yinc;
		}
	}
}
     b84:	b003      	add	sp, #12
     b86:	bc3c      	pop	{r2, r3, r4, r5}
     b88:	4690      	mov	r8, r2
     b8a:	4699      	mov	r9, r3
     b8c:	46a2      	mov	sl, r4
     b8e:	46ab      	mov	fp, r5
     b90:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b92:	46c0      	nop			; (mov r8, r8)
     b94:	00000dd1 	.word	0x00000dd1

00000b98 <gfx_mono_generic_draw_rect>:
 * \param[in] color       Pixel operation of the line.
 */
void gfx_mono_generic_draw_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     b98:	b5f0      	push	{r4, r5, r6, r7, lr}
     b9a:	b083      	sub	sp, #12
     b9c:	1c07      	adds	r7, r0, #0
     b9e:	1c0e      	adds	r6, r1, #0
     ba0:	9300      	str	r3, [sp, #0]
     ba2:	ab08      	add	r3, sp, #32
     ba4:	781d      	ldrb	r5, [r3, #0]
	gfx_mono_draw_horizontal_line(x, y, width, color);
     ba6:	9201      	str	r2, [sp, #4]
     ba8:	1c2b      	adds	r3, r5, #0
     baa:	4c0d      	ldr	r4, [pc, #52]	; (be0 <gfx_mono_generic_draw_rect+0x48>)
     bac:	47a0      	blx	r4
     bae:	9b00      	ldr	r3, [sp, #0]
     bb0:	1e59      	subs	r1, r3, #1
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);
     bb2:	1871      	adds	r1, r6, r1
     bb4:	b2c9      	uxtb	r1, r1
     bb6:	1c38      	adds	r0, r7, #0
     bb8:	9a01      	ldr	r2, [sp, #4]
     bba:	1c2b      	adds	r3, r5, #0
     bbc:	47a0      	blx	r4

	gfx_mono_draw_vertical_line(x, y, height, color);
     bbe:	1c38      	adds	r0, r7, #0
     bc0:	1c31      	adds	r1, r6, #0
     bc2:	9a00      	ldr	r2, [sp, #0]
     bc4:	1c2b      	adds	r3, r5, #0
     bc6:	4c07      	ldr	r4, [pc, #28]	; (be4 <gfx_mono_generic_draw_rect+0x4c>)
     bc8:	47a0      	blx	r4
     bca:	9801      	ldr	r0, [sp, #4]
     bcc:	3801      	subs	r0, #1
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
     bce:	1838      	adds	r0, r7, r0
     bd0:	b2c0      	uxtb	r0, r0
     bd2:	1c31      	adds	r1, r6, #0
     bd4:	9a00      	ldr	r2, [sp, #0]
     bd6:	1c2b      	adds	r3, r5, #0
     bd8:	47a0      	blx	r4
}
     bda:	b003      	add	sp, #12
     bdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
     bde:	46c0      	nop			; (mov r8, r8)
     be0:	00000929 	.word	0x00000929
     be4:	00000a09 	.word	0x00000a09

00000be8 <gfx_mono_generic_draw_filled_rect>:
 * \param[in]  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     be8:	b5f0      	push	{r4, r5, r6, r7, lr}
     bea:	b083      	sub	sp, #12
     bec:	ac08      	add	r4, sp, #32
     bee:	7827      	ldrb	r7, [r4, #0]
	if (height == 0) {
     bf0:	2b00      	cmp	r3, #0
     bf2:	d00e      	beq.n	c12 <gfx_mono_generic_draw_filled_rect+0x2a>
     bf4:	9201      	str	r2, [sp, #4]
     bf6:	9000      	str	r0, [sp, #0]
     bf8:	1c1c      	adds	r4, r3, #0
     bfa:	1e4e      	subs	r6, r1, #1
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     bfc:	4d06      	ldr	r5, [pc, #24]	; (c18 <gfx_mono_generic_draw_filled_rect+0x30>)
     bfe:	19a1      	adds	r1, r4, r6
     c00:	b2c9      	uxtb	r1, r1
     c02:	9800      	ldr	r0, [sp, #0]
     c04:	9a01      	ldr	r2, [sp, #4]
     c06:	1c3b      	adds	r3, r7, #0
     c08:	47a8      	blx	r5
     c0a:	3c01      	subs	r4, #1
     c0c:	b2e4      	uxtb	r4, r4
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c0e:	2c00      	cmp	r4, #0
     c10:	d1f5      	bne.n	bfe <gfx_mono_generic_draw_filled_rect+0x16>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c12:	b003      	add	sp, #12
     c14:	bdf0      	pop	{r4, r5, r6, r7, pc}
     c16:	46c0      	nop			; (mov r8, r8)
     c18:	00000929 	.word	0x00000929

00000c1c <gfx_mono_draw_char>:
 * \param[in] y        Y coordinate on screen.
 * \param[in] font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c1c:	b5f0      	push	{r4, r5, r6, r7, lr}
     c1e:	465f      	mov	r7, fp
     c20:	4656      	mov	r6, sl
     c22:	464d      	mov	r5, r9
     c24:	4644      	mov	r4, r8
     c26:	b4f0      	push	{r4, r5, r6, r7}
     c28:	b085      	sub	sp, #20
     c2a:	1c04      	adds	r4, r0, #0
     c2c:	4688      	mov	r8, r1
     c2e:	1c15      	adds	r5, r2, #0
     c30:	469b      	mov	fp, r3
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c32:	7a1a      	ldrb	r2, [r3, #8]
     c34:	7a5b      	ldrb	r3, [r3, #9]
     c36:	2100      	movs	r1, #0
     c38:	9100      	str	r1, [sp, #0]
     c3a:	4640      	mov	r0, r8
     c3c:	1c29      	adds	r1, r5, #0
     c3e:	4e25      	ldr	r6, [pc, #148]	; (cd4 <gfx_mono_draw_char+0xb8>)
     c40:	47b0      	blx	r6
			GFX_PIXEL_CLR);

	switch (font->type) {
     c42:	465b      	mov	r3, fp
     c44:	781b      	ldrb	r3, [r3, #0]
     c46:	2b00      	cmp	r3, #0
     c48:	d13c      	bne.n	cc4 <gfx_mono_draw_char+0xa8>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c4a:	465b      	mov	r3, fp
     c4c:	7a1b      	ldrb	r3, [r3, #8]
     c4e:	08de      	lsrs	r6, r3, #3
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c50:	075b      	lsls	r3, r3, #29
     c52:	d000      	beq.n	c56 <gfx_mono_draw_char+0x3a>
		char_row_size++;
     c54:	3601      	adds	r6, #1
	}

	glyph_data_offset = char_row_size * font->height *
     c56:	465b      	mov	r3, fp
     c58:	7a5b      	ldrb	r3, [r3, #9]
     c5a:	469a      	mov	sl, r3
			((uint8_t)ch - font->first_char);
     c5c:	465b      	mov	r3, fp
     c5e:	7a9b      	ldrb	r3, [r3, #10]
     c60:	1ae4      	subs	r4, r4, r3
     c62:	4653      	mov	r3, sl
     c64:	435c      	muls	r4, r3
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
     c66:	4366      	muls	r6, r4
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c68:	b2b6      	uxth	r6, r6
     c6a:	465b      	mov	r3, fp
     c6c:	685b      	ldr	r3, [r3, #4]
     c6e:	469c      	mov	ip, r3
     c70:	4466      	add	r6, ip

	/* Sanity check on parameters, assert if font is NULL. */
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;
     c72:	9503      	str	r5, [sp, #12]
	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     c74:	2307      	movs	r3, #7
     c76:	4699      	mov	r9, r3
	glyph_data = font->data.progmem + glyph_data_offset;
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     c78:	465b      	mov	r3, fp
     c7a:	7a1f      	ldrb	r7, [r3, #8]

		for (i = 0; i < pixelsToDraw; i++) {
     c7c:	2f00      	cmp	r7, #0
     c7e:	d017      	beq.n	cb0 <gfx_mono_draw_char+0x94>
     c80:	2500      	movs	r5, #0
     c82:	2400      	movs	r4, #0
     c84:	b2eb      	uxtb	r3, r5
     c86:	4642      	mov	r2, r8
     c88:	1898      	adds	r0, r3, r2
     c8a:	b2c0      	uxtb	r0, r0
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     c8c:	464a      	mov	r2, r9
     c8e:	421a      	tst	r2, r3
     c90:	d101      	bne.n	c96 <gfx_mono_draw_char+0x7a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     c92:	7834      	ldrb	r4, [r6, #0]
				glyph_data++;
     c94:	3601      	adds	r6, #1
			}

			if ((glyph_byte & 0x80)) {
     c96:	b263      	sxtb	r3, r4
     c98:	2b00      	cmp	r3, #0
     c9a:	da03      	bge.n	ca4 <gfx_mono_draw_char+0x88>
				gfx_mono_draw_pixel(inc_x, inc_y,
     c9c:	9903      	ldr	r1, [sp, #12]
     c9e:	2201      	movs	r2, #1
     ca0:	4b0d      	ldr	r3, [pc, #52]	; (cd8 <gfx_mono_draw_char+0xbc>)
     ca2:	4798      	blx	r3
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     ca4:	0064      	lsls	r4, r4, #1
     ca6:	b2e4      	uxtb	r4, r4
     ca8:	3501      	adds	r5, #1

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     caa:	b2eb      	uxtb	r3, r5
     cac:	429f      	cmp	r7, r3
     cae:	d8e9      	bhi.n	c84 <gfx_mono_draw_char+0x68>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cb0:	9b03      	ldr	r3, [sp, #12]
     cb2:	3301      	adds	r3, #1
     cb4:	b2db      	uxtb	r3, r3
     cb6:	9303      	str	r3, [sp, #12]
		inc_x = x;
		rows_left--;
     cb8:	4653      	mov	r3, sl
     cba:	3b01      	subs	r3, #1
     cbc:	b2db      	uxtb	r3, r3
     cbe:	469a      	mov	sl, r3
	} while (rows_left > 0);
     cc0:	2b00      	cmp	r3, #0
     cc2:	d1d9      	bne.n	c78 <gfx_mono_draw_char+0x5c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cc4:	b005      	add	sp, #20
     cc6:	bc3c      	pop	{r2, r3, r4, r5}
     cc8:	4690      	mov	r8, r2
     cca:	4699      	mov	r9, r3
     ccc:	46a2      	mov	sl, r4
     cce:	46ab      	mov	fp, r5
     cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cd2:	46c0      	nop			; (mov r8, r8)
     cd4:	00000be9 	.word	0x00000be9
     cd8:	00000dd1 	.word	0x00000dd1

00000cdc <gfx_mono_draw_string>:
 * \param[in] y         Y coordinate on screen.
 * \param[in] font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cdc:	b5f0      	push	{r4, r5, r6, r7, lr}
     cde:	4647      	mov	r7, r8
     ce0:	b480      	push	{r7}
     ce2:	b082      	sub	sp, #8
     ce4:	1c04      	adds	r4, r0, #0
     ce6:	9101      	str	r1, [sp, #4]
     ce8:	4690      	mov	r8, r2
     cea:	1c1f      	adds	r7, r3, #0
     cec:	1c0d      	adds	r5, r1, #0
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     cee:	7820      	ldrb	r0, [r4, #0]
     cf0:	280a      	cmp	r0, #10
     cf2:	d106      	bne.n	d02 <gfx_mono_draw_string+0x26>
     cf4:	7a7a      	ldrb	r2, [r7, #9]
     cf6:	3201      	adds	r2, #1
			x = start_of_string_position_x;
			y += font->height + 1;
     cf8:	4442      	add	r2, r8
     cfa:	b2d3      	uxtb	r3, r2
     cfc:	4698      	mov	r8, r3

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cfe:	9d01      	ldr	r5, [sp, #4]
     d00:	e009      	b.n	d16 <gfx_mono_draw_string+0x3a>
			y += font->height + 1;
		} else if (*str == '\r') {
     d02:	280d      	cmp	r0, #13
     d04:	d007      	beq.n	d16 <gfx_mono_draw_string+0x3a>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d06:	1c29      	adds	r1, r5, #0
     d08:	4642      	mov	r2, r8
     d0a:	1c3b      	adds	r3, r7, #0
     d0c:	4e06      	ldr	r6, [pc, #24]	; (d28 <gfx_mono_draw_string+0x4c>)
     d0e:	47b0      	blx	r6
			x += font->width;
     d10:	7a3b      	ldrb	r3, [r7, #8]
     d12:	18eb      	adds	r3, r5, r3
     d14:	b2dd      	uxtb	r5, r3
		}
	} while (*(++str));
     d16:	3401      	adds	r4, #1
     d18:	7823      	ldrb	r3, [r4, #0]
     d1a:	2b00      	cmp	r3, #0
     d1c:	d1e7      	bne.n	cee <gfx_mono_draw_string+0x12>
}
     d1e:	b002      	add	sp, #8
     d20:	bc04      	pop	{r2}
     d22:	4690      	mov	r8, r2
     d24:	bdf0      	pop	{r4, r5, r6, r7, pc}
     d26:	46c0      	nop			; (mov r8, r8)
     d28:	00000c1d 	.word	0x00000c1d

00000d2c <gfx_mono_ssd1306_put_byte>:
	gfx_mono_ssd1306_put_byte(0, 0, 0xFF, false);
\endcode
  */
 void gfx_mono_ssd1306_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data, bool force)
{
     d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d2e:	1c05      	adds	r5, r0, #0
     d30:	1c0c      	adds	r4, r1, #0
     d32:	1c16      	adds	r6, r2, #0
#ifdef CONFIG_SSD1306_FRAMEBUFFER
	if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
     d34:	2b00      	cmp	r3, #0
     d36:	d103      	bne.n	d40 <gfx_mono_ssd1306_put_byte+0x14>
     d38:	4b0d      	ldr	r3, [pc, #52]	; (d70 <gfx_mono_ssd1306_put_byte+0x44>)
     d3a:	4798      	blx	r3
     d3c:	42b0      	cmp	r0, r6
     d3e:	d015      	beq.n	d6c <gfx_mono_ssd1306_put_byte+0x40>
		return;
	}
	gfx_mono_framebuffer_put_byte(page, column, data);
     d40:	1c28      	adds	r0, r5, #0
     d42:	1c21      	adds	r1, r4, #0
     d44:	1c32      	adds	r2, r6, #0
     d46:	4b0b      	ldr	r3, [pc, #44]	; (d74 <gfx_mono_ssd1306_put_byte+0x48>)
     d48:	4798      	blx	r3
 * \param address the page address
 */
static inline void ssd1306_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
     d4a:	270f      	movs	r7, #15
     d4c:	403d      	ands	r5, r7
	ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
     d4e:	20b0      	movs	r0, #176	; 0xb0
     d50:	4328      	orrs	r0, r5
     d52:	4d09      	ldr	r5, [pc, #36]	; (d78 <gfx_mono_ssd1306_put_byte+0x4c>)
     d54:	47a8      	blx	r5
 */
static inline void ssd1306_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
     d56:	0660      	lsls	r0, r4, #25
     d58:	0f40      	lsrs	r0, r0, #29
     d5a:	2310      	movs	r3, #16
     d5c:	4318      	orrs	r0, r3
     d5e:	47a8      	blx	r5
	ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
     d60:	1c38      	adds	r0, r7, #0
     d62:	4020      	ands	r0, r4
     d64:	47a8      	blx	r5
#endif

	ssd1306_set_page_address(page);
	ssd1306_set_column_address(column);

	ssd1306_write_data(data);
     d66:	1c30      	adds	r0, r6, #0
     d68:	4b04      	ldr	r3, [pc, #16]	; (d7c <gfx_mono_ssd1306_put_byte+0x50>)
     d6a:	4798      	blx	r3
}
     d6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d6e:	46c0      	nop			; (mov r8, r8)
     d70:	00000919 	.word	0x00000919
     d74:	00000909 	.word	0x00000909
     d78:	00000645 	.word	0x00000645
     d7c:	00000849 	.word	0x00000849

00000d80 <gfx_mono_ssd1306_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_ssd1306_init(void)
{
     d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_SSD1306_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     d82:	480e      	ldr	r0, [pc, #56]	; (dbc <gfx_mono_ssd1306_init+0x3c>)
     d84:	4b0e      	ldr	r3, [pc, #56]	; (dc0 <gfx_mono_ssd1306_init+0x40>)
     d86:	4798      	blx	r3
#endif

	/* Initialize the low-level display controller. */
	ssd1306_init();
     d88:	4b0e      	ldr	r3, [pc, #56]	; (dc4 <gfx_mono_ssd1306_init+0x44>)
     d8a:	4798      	blx	r3
 */
static inline void ssd1306_set_display_start_line_address(uint8_t address)
{
	// Make sure address is 6 bits
	address &= 0x3F;
	ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(address));
     d8c:	2040      	movs	r0, #64	; 0x40
     d8e:	4b0e      	ldr	r3, [pc, #56]	; (dc8 <gfx_mono_ssd1306_init+0x48>)
     d90:	4798      	blx	r3

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     d92:	2500      	movs	r5, #0
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_ssd1306_init(void)
{
     d94:	2600      	movs	r6, #0
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
     d96:	4f0d      	ldr	r7, [pc, #52]	; (dcc <gfx_mono_ssd1306_init+0x4c>)
     d98:	e00c      	b.n	db4 <gfx_mono_ssd1306_init+0x34>
     d9a:	1c28      	adds	r0, r5, #0
     d9c:	1c21      	adds	r1, r4, #0
     d9e:	1c32      	adds	r2, r6, #0
     da0:	2301      	movs	r3, #1
     da2:	47b8      	blx	r7
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     da4:	3401      	adds	r4, #1
     da6:	b2e4      	uxtb	r4, r4
     da8:	2c80      	cmp	r4, #128	; 0x80
     daa:	d1f6      	bne.n	d9a <gfx_mono_ssd1306_init+0x1a>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     dac:	3501      	adds	r5, #1
     dae:	b2ed      	uxtb	r5, r5
     db0:	2d08      	cmp	r5, #8
     db2:	d001      	beq.n	db8 <gfx_mono_ssd1306_init+0x38>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_ssd1306_init(void)
{
     db4:	1c34      	adds	r4, r6, #0
     db6:	e7f0      	b.n	d9a <gfx_mono_ssd1306_init+0x1a>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
		}
	}
}
     db8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     dba:	46c0      	nop			; (mov r8, r8)
     dbc:	20000044 	.word	0x20000044
     dc0:	000008fd 	.word	0x000008fd
     dc4:	00000691 	.word	0x00000691
     dc8:	00000645 	.word	0x00000645
     dcc:	00000d2d 	.word	0x00000d2d

00000dd0 <gfx_mono_ssd1306_draw_pixel>:
	gfx_mono_ssd1306_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_ssd1306_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
     dd2:	4647      	mov	r7, r8
     dd4:	b480      	push	{r7}
     dd6:	1c04      	adds	r4, r0, #0
     dd8:	1c15      	adds	r5, r2, #0
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     dda:	b243      	sxtb	r3, r0
     ddc:	2b00      	cmp	r3, #0
     dde:	db23      	blt.n	e28 <gfx_mono_ssd1306_draw_pixel+0x58>
     de0:	293f      	cmp	r1, #63	; 0x3f
     de2:	d821      	bhi.n	e28 <gfx_mono_ssd1306_draw_pixel+0x58>
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     de4:	08cf      	lsrs	r7, r1, #3
	pixel_mask = (1 << (y - (page * 8)));
     de6:	00fb      	lsls	r3, r7, #3
     de8:	1ac9      	subs	r1, r1, r3
     dea:	2601      	movs	r6, #1
     dec:	408e      	lsls	r6, r1
     dee:	b2f3      	uxtb	r3, r6
     df0:	4698      	mov	r8, r3
\endcode
 */
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_SSD1306_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     df2:	1c38      	adds	r0, r7, #0
     df4:	1c21      	adds	r1, r4, #0
     df6:	4b0e      	ldr	r3, [pc, #56]	; (e30 <gfx_mono_ssd1306_draw_pixel+0x60>)
     df8:	4798      	blx	r3
     dfa:	1c02      	adds	r2, r0, #0
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     dfc:	2d01      	cmp	r5, #1
     dfe:	d004      	beq.n	e0a <gfx_mono_ssd1306_draw_pixel+0x3a>
     e00:	2d00      	cmp	r5, #0
     e02:	d006      	beq.n	e12 <gfx_mono_ssd1306_draw_pixel+0x42>
     e04:	2d02      	cmp	r5, #2
     e06:	d007      	beq.n	e18 <gfx_mono_ssd1306_draw_pixel+0x48>
     e08:	e009      	b.n	e1e <gfx_mono_ssd1306_draw_pixel+0x4e>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     e0a:	4643      	mov	r3, r8
     e0c:	4318      	orrs	r0, r3
     e0e:	b2c2      	uxtb	r2, r0
		break;
     e10:	e005      	b.n	e1e <gfx_mono_ssd1306_draw_pixel+0x4e>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     e12:	43b0      	bics	r0, r6
     e14:	b2c2      	uxtb	r2, r0
		break;
     e16:	e002      	b.n	e1e <gfx_mono_ssd1306_draw_pixel+0x4e>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     e18:	4643      	mov	r3, r8
     e1a:	4058      	eors	r0, r3
     e1c:	b2c2      	uxtb	r2, r0

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     e1e:	1c38      	adds	r0, r7, #0
     e20:	1c21      	adds	r1, r4, #0
     e22:	2300      	movs	r3, #0
     e24:	4c03      	ldr	r4, [pc, #12]	; (e34 <gfx_mono_ssd1306_draw_pixel+0x64>)
     e26:	47a0      	blx	r4
}
     e28:	bc04      	pop	{r2}
     e2a:	4690      	mov	r8, r2
     e2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e2e:	46c0      	nop			; (mov r8, r8)
     e30:	00000919 	.word	0x00000919
     e34:	00000d2d 	.word	0x00000d2d

00000e38 <gfx_mono_ssd1306_get_byte>:
 * \code
	data = gfx_mono_ssd1306_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column)
{
     e38:	b508      	push	{r3, lr}
#ifdef CONFIG_SSD1306_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     e3a:	4b01      	ldr	r3, [pc, #4]	; (e40 <gfx_mono_ssd1306_get_byte+0x8>)
     e3c:	4798      	blx	r3
	ssd1306_set_column_address(column);

	return ssd1306_read_data();

#endif
}
     e3e:	bd08      	pop	{r3, pc}
     e40:	00000919 	.word	0x00000919

00000e44 <gfx_mono_ssd1306_mask_byte>:
	gfx_mono_ssd1306_mask_byte(0,0,0xAA,GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_ssd1306_mask_byte(gfx_coord_t page, gfx_coord_t column,
		gfx_mono_color_t pixel_mask, gfx_mono_color_t color)
{
     e44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     e46:	1c05      	adds	r5, r0, #0
     e48:	1c0c      	adds	r4, r1, #0
     e4a:	1c17      	adds	r7, r2, #0
     e4c:	1c1e      	adds	r6, r3, #0
\endcode
 */
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_SSD1306_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     e4e:	4b0c      	ldr	r3, [pc, #48]	; (e80 <gfx_mono_ssd1306_mask_byte+0x3c>)
     e50:	4798      	blx	r3
     e52:	1c02      	adds	r2, r0, #0
void gfx_mono_ssd1306_mask_byte(gfx_coord_t page, gfx_coord_t column,
		gfx_mono_color_t pixel_mask, gfx_mono_color_t color)
{
	gfx_mono_color_t temp = gfx_mono_get_byte(page, column);

	switch (color) {
     e54:	2e01      	cmp	r6, #1
     e56:	d004      	beq.n	e62 <gfx_mono_ssd1306_mask_byte+0x1e>
     e58:	2e00      	cmp	r6, #0
     e5a:	d005      	beq.n	e68 <gfx_mono_ssd1306_mask_byte+0x24>
     e5c:	2e02      	cmp	r6, #2
     e5e:	d006      	beq.n	e6e <gfx_mono_ssd1306_mask_byte+0x2a>
     e60:	e007      	b.n	e72 <gfx_mono_ssd1306_mask_byte+0x2e>
	case GFX_PIXEL_SET:
		temp |= pixel_mask;
     e62:	4338      	orrs	r0, r7
     e64:	b2c2      	uxtb	r2, r0
		break;
     e66:	e004      	b.n	e72 <gfx_mono_ssd1306_mask_byte+0x2e>

	case GFX_PIXEL_CLR:
		temp &= ~pixel_mask;
     e68:	43b8      	bics	r0, r7
     e6a:	b2c2      	uxtb	r2, r0
		break;
     e6c:	e001      	b.n	e72 <gfx_mono_ssd1306_mask_byte+0x2e>

	case GFX_PIXEL_XOR:
		temp ^= pixel_mask;
     e6e:	4078      	eors	r0, r7
     e70:	b2c2      	uxtb	r2, r0

	default:
		break;
	}

	gfx_mono_put_byte(page, column, temp);
     e72:	1c28      	adds	r0, r5, #0
     e74:	1c21      	adds	r1, r4, #0
     e76:	2300      	movs	r3, #0
     e78:	4c02      	ldr	r4, [pc, #8]	; (e84 <gfx_mono_ssd1306_mask_byte+0x40>)
     e7a:	47a0      	blx	r4
}
     e7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     e7e:	46c0      	nop			; (mov r8, r8)
     e80:	00000919 	.word	0x00000919
     e84:	00000d2d 	.word	0x00000d2d

00000e88 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
     e88:	4b0c      	ldr	r3, [pc, #48]	; (ebc <cpu_irq_enter_critical+0x34>)
     e8a:	681b      	ldr	r3, [r3, #0]
     e8c:	2b00      	cmp	r3, #0
     e8e:	d110      	bne.n	eb2 <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     e90:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
     e94:	2b00      	cmp	r3, #0
     e96:	d109      	bne.n	eac <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     e98:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
     e9a:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
     e9e:	2200      	movs	r2, #0
     ea0:	4b07      	ldr	r3, [pc, #28]	; (ec0 <cpu_irq_enter_critical+0x38>)
     ea2:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
     ea4:	3201      	adds	r2, #1
     ea6:	4b07      	ldr	r3, [pc, #28]	; (ec4 <cpu_irq_enter_critical+0x3c>)
     ea8:	701a      	strb	r2, [r3, #0]
     eaa:	e002      	b.n	eb2 <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
     eac:	2200      	movs	r2, #0
     eae:	4b05      	ldr	r3, [pc, #20]	; (ec4 <cpu_irq_enter_critical+0x3c>)
     eb0:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
     eb2:	4a02      	ldr	r2, [pc, #8]	; (ebc <cpu_irq_enter_critical+0x34>)
     eb4:	6813      	ldr	r3, [r2, #0]
     eb6:	3301      	adds	r3, #1
     eb8:	6013      	str	r3, [r2, #0]
}
     eba:	4770      	bx	lr
     ebc:	20000444 	.word	0x20000444
     ec0:	20000014 	.word	0x20000014
     ec4:	20000448 	.word	0x20000448

00000ec8 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
     ec8:	4b08      	ldr	r3, [pc, #32]	; (eec <cpu_irq_leave_critical+0x24>)
     eca:	681a      	ldr	r2, [r3, #0]
     ecc:	3a01      	subs	r2, #1
     ece:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
     ed0:	681b      	ldr	r3, [r3, #0]
     ed2:	2b00      	cmp	r3, #0
     ed4:	d109      	bne.n	eea <cpu_irq_leave_critical+0x22>
     ed6:	4b06      	ldr	r3, [pc, #24]	; (ef0 <cpu_irq_leave_critical+0x28>)
     ed8:	781b      	ldrb	r3, [r3, #0]
     eda:	2b00      	cmp	r3, #0
     edc:	d005      	beq.n	eea <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
     ede:	2201      	movs	r2, #1
     ee0:	4b04      	ldr	r3, [pc, #16]	; (ef4 <cpu_irq_leave_critical+0x2c>)
     ee2:	701a      	strb	r2, [r3, #0]
     ee4:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     ee8:	b662      	cpsie	i
	}
}
     eea:	4770      	bx	lr
     eec:	20000444 	.word	0x20000444
     ef0:	20000448 	.word	0x20000448
     ef4:	20000014 	.word	0x20000014

00000ef8 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
     ef8:	b5f0      	push	{r4, r5, r6, r7, lr}
     efa:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     efc:	ac01      	add	r4, sp, #4
     efe:	2601      	movs	r6, #1
     f00:	7066      	strb	r6, [r4, #1]
	config->powersave  = false;
     f02:	2700      	movs	r7, #0
     f04:	70a7      	strb	r7, [r4, #2]
	port_get_config_defaults(&pin_conf);
	port_get_config_defaults(&pin_conf_in);


	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
     f06:	7026      	strb	r6, [r4, #0]
	pin_conf_in.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(LED_0_PIN, &pin_conf);
     f08:	200e      	movs	r0, #14
     f0a:	1c21      	adds	r1, r4, #0
     f0c:	4d09      	ldr	r5, [pc, #36]	; (f34 <system_board_init+0x3c>)
     f0e:	47a8      	blx	r5
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     f10:	2280      	movs	r2, #128	; 0x80
     f12:	01d2      	lsls	r2, r2, #7
     f14:	4b08      	ldr	r3, [pc, #32]	; (f38 <system_board_init+0x40>)
     f16:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
//#define CE_OFF port_pin_set_output_level(EXT2_PIN_GPIO_0, 0)
	port_pin_set_config(EXT2_PIN_GPIO_0, &pin_conf);
     f18:	2014      	movs	r0, #20
     f1a:	1c21      	adds	r1, r4, #0
     f1c:	47a8      	blx	r5

	//port_pin_set_config(EXT2_PIN_IRQ , &pin_conf_in);


	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
     f1e:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
     f20:	7066      	strb	r6, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
     f22:	200f      	movs	r0, #15
     f24:	1c21      	adds	r1, r4, #0
     f26:	47a8      	blx	r5
	port_pin_set_config(EXT2_PIN_IRQ , &pin_conf);
     f28:	202e      	movs	r0, #46	; 0x2e
     f2a:	1c21      	adds	r1, r4, #0
     f2c:	47a8      	blx	r5

	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
	
#endif
}
     f2e:	b003      	add	sp, #12
     f30:	bdf0      	pop	{r4, r5, r6, r7, pc}
     f32:	46c0      	nop			; (mov r8, r8)
     f34:	00000f3d 	.word	0x00000f3d
     f38:	41004400 	.word	0x41004400

00000f3c <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
     f3c:	b500      	push	{lr}
     f3e:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     f40:	ab01      	add	r3, sp, #4
     f42:	2280      	movs	r2, #128	; 0x80
     f44:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
     f46:	780a      	ldrb	r2, [r1, #0]
     f48:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
     f4a:	784a      	ldrb	r2, [r1, #1]
     f4c:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
     f4e:	788a      	ldrb	r2, [r1, #2]
     f50:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
     f52:	1c19      	adds	r1, r3, #0
     f54:	4b01      	ldr	r3, [pc, #4]	; (f5c <port_pin_set_config+0x20>)
     f56:	4798      	blx	r3
}
     f58:	b003      	add	sp, #12
     f5a:	bd00      	pop	{pc}
     f5c:	000027c5 	.word	0x000027c5

00000f60 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
     f60:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
     f62:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     f64:	2440      	movs	r4, #64	; 0x40
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
     f66:	4281      	cmp	r1, r0
     f68:	d30c      	bcc.n	f84 <_sercom_get_sync_baud_val+0x24>
     f6a:	2300      	movs	r3, #0
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
     f6c:	1a09      	subs	r1, r1, r0
		baud_calculated++;
     f6e:	3301      	adds	r3, #1
     f70:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
     f72:	4288      	cmp	r0, r1
     f74:	d9fa      	bls.n	f6c <_sercom_get_sync_baud_val+0xc>
		clock_value = clock_value - baudrate;
		baud_calculated++;
	}
	baud_calculated = baud_calculated - 1;
     f76:	3b01      	subs	r3, #1
     f78:	b29b      	uxth	r3, r3

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     f7a:	2440      	movs	r4, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
     f7c:	2bff      	cmp	r3, #255	; 0xff
     f7e:	d801      	bhi.n	f84 <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
     f80:	8013      	strh	r3, [r2, #0]
		return STATUS_OK;
     f82:	2400      	movs	r4, #0
	}
}
     f84:	1c20      	adds	r0, r4, #0
     f86:	bd10      	pop	{r4, pc}

00000f88 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
     f88:	b5f0      	push	{r4, r5, r6, r7, lr}
     f8a:	465f      	mov	r7, fp
     f8c:	4656      	mov	r6, sl
     f8e:	464d      	mov	r5, r9
     f90:	4644      	mov	r4, r8
     f92:	b4f0      	push	{r4, r5, r6, r7}
     f94:	b089      	sub	sp, #36	; 0x24
     f96:	1c1c      	adds	r4, r3, #0
     f98:	ab12      	add	r3, sp, #72	; 0x48
     f9a:	781b      	ldrb	r3, [r3, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
     f9c:	1c06      	adds	r6, r0, #0
     f9e:	435e      	muls	r6, r3
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
     fa0:	2540      	movs	r5, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
     fa2:	428e      	cmp	r6, r1
     fa4:	d900      	bls.n	fa8 <_sercom_get_async_baud_val+0x20>
     fa6:	e0c7      	b.n	1138 <_sercom_get_async_baud_val+0x1b0>
     fa8:	1c25      	adds	r5, r4, #0
     faa:	9207      	str	r2, [sp, #28]
     fac:	1c0c      	adds	r4, r1, #0
     fae:	1c02      	adds	r2, r0, #0
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
     fb0:	2d00      	cmp	r5, #0
     fb2:	d151      	bne.n	1058 <_sercom_get_async_baud_val+0xd0>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
     fb4:	1c18      	adds	r0, r3, #0
     fb6:	2100      	movs	r1, #0
     fb8:	2300      	movs	r3, #0
     fba:	4d63      	ldr	r5, [pc, #396]	; (1148 <_sercom_get_async_baud_val+0x1c0>)
     fbc:	47a8      	blx	r5
     fbe:	4683      	mov	fp, r0
		ratio = long_division(temp1, peripheral_clock);
     fc0:	1c26      	adds	r6, r4, #0
     fc2:	2700      	movs	r7, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
     fc4:	2300      	movs	r3, #0
     fc6:	2400      	movs	r4, #0
     fc8:	9302      	str	r3, [sp, #8]
     fca:	9403      	str	r4, [sp, #12]
     fcc:	2200      	movs	r2, #0
     fce:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
     fd0:	203f      	movs	r0, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
     fd2:	2120      	movs	r1, #32
     fd4:	468c      	mov	ip, r1
     fd6:	391f      	subs	r1, #31
     fd8:	9600      	str	r6, [sp, #0]
     fda:	9701      	str	r7, [sp, #4]
     fdc:	2420      	movs	r4, #32
     fde:	4264      	negs	r4, r4
     fe0:	1904      	adds	r4, r0, r4
     fe2:	d403      	bmi.n	fec <_sercom_get_async_baud_val+0x64>
     fe4:	1c0d      	adds	r5, r1, #0
     fe6:	40a5      	lsls	r5, r4
     fe8:	46a8      	mov	r8, r5
     fea:	e004      	b.n	ff6 <_sercom_get_async_baud_val+0x6e>
     fec:	4664      	mov	r4, ip
     fee:	1a24      	subs	r4, r4, r0
     ff0:	1c0d      	adds	r5, r1, #0
     ff2:	40e5      	lsrs	r5, r4
     ff4:	46a8      	mov	r8, r5
     ff6:	1c0c      	adds	r4, r1, #0
     ff8:	4084      	lsls	r4, r0
     ffa:	46a1      	mov	r9, r4

		r = r << 1;
     ffc:	1c14      	adds	r4, r2, #0
     ffe:	1c1d      	adds	r5, r3, #0
    1000:	18a4      	adds	r4, r4, r2
    1002:	415d      	adcs	r5, r3
    1004:	1c22      	adds	r2, r4, #0
    1006:	1c2b      	adds	r3, r5, #0

		if (n & bit_shift) {
    1008:	465e      	mov	r6, fp
    100a:	4647      	mov	r7, r8
    100c:	423e      	tst	r6, r7
    100e:	d003      	beq.n	1018 <_sercom_get_async_baud_val+0x90>
			r |= 0x01;
    1010:	1c0e      	adds	r6, r1, #0
    1012:	4326      	orrs	r6, r4
    1014:	1c32      	adds	r2, r6, #0
    1016:	1c2b      	adds	r3, r5, #0
		}

		if (r >= d) {
    1018:	9c01      	ldr	r4, [sp, #4]
    101a:	429c      	cmp	r4, r3
    101c:	d810      	bhi.n	1040 <_sercom_get_async_baud_val+0xb8>
    101e:	d102      	bne.n	1026 <_sercom_get_async_baud_val+0x9e>
    1020:	9c00      	ldr	r4, [sp, #0]
    1022:	4294      	cmp	r4, r2
    1024:	d80c      	bhi.n	1040 <_sercom_get_async_baud_val+0xb8>
			r = r - d;
    1026:	9c00      	ldr	r4, [sp, #0]
    1028:	9d01      	ldr	r5, [sp, #4]
    102a:	1b12      	subs	r2, r2, r4
    102c:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    102e:	464d      	mov	r5, r9
    1030:	9e02      	ldr	r6, [sp, #8]
    1032:	9f03      	ldr	r7, [sp, #12]
    1034:	4335      	orrs	r5, r6
    1036:	1c3c      	adds	r4, r7, #0
    1038:	4646      	mov	r6, r8
    103a:	4334      	orrs	r4, r6
    103c:	9502      	str	r5, [sp, #8]
    103e:	9403      	str	r4, [sp, #12]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    1040:	3801      	subs	r0, #1
    1042:	d2cb      	bcs.n	fdc <_sercom_get_async_baud_val+0x54>

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
    1044:	2200      	movs	r2, #0
    1046:	2301      	movs	r3, #1
    1048:	9802      	ldr	r0, [sp, #8]
    104a:	9903      	ldr	r1, [sp, #12]
    104c:	1a12      	subs	r2, r2, r0
    104e:	418b      	sbcs	r3, r1
		baud_calculated = (65536 * scale) >> SHIFT;
    1050:	0c11      	lsrs	r1, r2, #16
    1052:	041b      	lsls	r3, r3, #16
    1054:	4319      	orrs	r1, r3
    1056:	e06c      	b.n	1132 <_sercom_get_async_baud_val+0x1aa>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
    1058:	2100      	movs	r1, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    105a:	2d01      	cmp	r5, #1
    105c:	d169      	bne.n	1132 <_sercom_get_async_baud_val+0x1aa>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
    105e:	0f61      	lsrs	r1, r4, #29
    1060:	1c0f      	adds	r7, r1, #0
    1062:	00e1      	lsls	r1, r4, #3
    1064:	4688      	mov	r8, r1
			temp2 = ((uint64_t)baudrate * sample_num);
    1066:	1c18      	adds	r0, r3, #0
    1068:	2100      	movs	r1, #0
    106a:	2300      	movs	r3, #0
    106c:	4c36      	ldr	r4, [pc, #216]	; (1148 <_sercom_get_async_baud_val+0x1c0>)
    106e:	47a0      	blx	r4
    1070:	1c04      	adds	r4, r0, #0
    1072:	1c0d      	adds	r5, r1, #0
    1074:	2300      	movs	r3, #0
    1076:	469c      	mov	ip, r3
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
    1078:	3320      	adds	r3, #32
    107a:	469b      	mov	fp, r3
    107c:	2601      	movs	r6, #1
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
    107e:	4663      	mov	r3, ip
    1080:	9305      	str	r3, [sp, #20]
    1082:	46b9      	mov	r9, r7
    1084:	466b      	mov	r3, sp
    1086:	7d1b      	ldrb	r3, [r3, #20]
    1088:	9306      	str	r3, [sp, #24]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    108a:	2300      	movs	r3, #0
    108c:	469c      	mov	ip, r3
    108e:	2000      	movs	r0, #0
    1090:	2100      	movs	r1, #0
	for (i = 63; i >= 0; i--) {
    1092:	223f      	movs	r2, #63	; 0x3f
    1094:	9400      	str	r4, [sp, #0]
    1096:	9501      	str	r5, [sp, #4]
		bit_shift = (uint64_t)1 << i;
    1098:	2320      	movs	r3, #32
    109a:	425b      	negs	r3, r3
    109c:	18d3      	adds	r3, r2, r3
    109e:	d403      	bmi.n	10a8 <_sercom_get_async_baud_val+0x120>
    10a0:	1c34      	adds	r4, r6, #0
    10a2:	409c      	lsls	r4, r3
    10a4:	1c23      	adds	r3, r4, #0
    10a6:	e004      	b.n	10b2 <_sercom_get_async_baud_val+0x12a>
    10a8:	465b      	mov	r3, fp
    10aa:	1a9b      	subs	r3, r3, r2
    10ac:	1c34      	adds	r4, r6, #0
    10ae:	40dc      	lsrs	r4, r3
    10b0:	1c23      	adds	r3, r4, #0
    10b2:	1c37      	adds	r7, r6, #0
    10b4:	4097      	lsls	r7, r2

		r = r << 1;
    10b6:	1c04      	adds	r4, r0, #0
    10b8:	1c0d      	adds	r5, r1, #0
    10ba:	1824      	adds	r4, r4, r0
    10bc:	414d      	adcs	r5, r1
    10be:	1c20      	adds	r0, r4, #0
    10c0:	1c29      	adds	r1, r5, #0
    10c2:	9002      	str	r0, [sp, #8]
    10c4:	9103      	str	r1, [sp, #12]

		if (n & bit_shift) {
    10c6:	4644      	mov	r4, r8
    10c8:	403c      	ands	r4, r7
    10ca:	46a2      	mov	sl, r4
    10cc:	464c      	mov	r4, r9
    10ce:	4023      	ands	r3, r4
    10d0:	4654      	mov	r4, sl
    10d2:	4323      	orrs	r3, r4
    10d4:	d005      	beq.n	10e2 <_sercom_get_async_baud_val+0x15a>
			r |= 0x01;
    10d6:	9b02      	ldr	r3, [sp, #8]
    10d8:	9c03      	ldr	r4, [sp, #12]
    10da:	1c1d      	adds	r5, r3, #0
    10dc:	4335      	orrs	r5, r6
    10de:	1c28      	adds	r0, r5, #0
    10e0:	1c21      	adds	r1, r4, #0
		}

		if (r >= d) {
    10e2:	9b01      	ldr	r3, [sp, #4]
    10e4:	428b      	cmp	r3, r1
    10e6:	d80a      	bhi.n	10fe <_sercom_get_async_baud_val+0x176>
    10e8:	d102      	bne.n	10f0 <_sercom_get_async_baud_val+0x168>
    10ea:	9b00      	ldr	r3, [sp, #0]
    10ec:	4283      	cmp	r3, r0
    10ee:	d806      	bhi.n	10fe <_sercom_get_async_baud_val+0x176>
			r = r - d;
    10f0:	9b00      	ldr	r3, [sp, #0]
    10f2:	9c01      	ldr	r4, [sp, #4]
    10f4:	1ac0      	subs	r0, r0, r3
    10f6:	41a1      	sbcs	r1, r4
			q |= bit_shift;
    10f8:	4663      	mov	r3, ip
    10fa:	433b      	orrs	r3, r7
    10fc:	469c      	mov	ip, r3
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    10fe:	3a01      	subs	r2, #1
    1100:	d2ca      	bcs.n	1098 <_sercom_get_async_baud_val+0x110>
    1102:	9c00      	ldr	r4, [sp, #0]
    1104:	9d01      	ldr	r5, [sp, #4]
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
    1106:	4662      	mov	r2, ip
    1108:	9905      	ldr	r1, [sp, #20]
    110a:	1a53      	subs	r3, r2, r1
			baud_int = baud_int / BAUD_FP_MAX;
    110c:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
    110e:	4a0f      	ldr	r2, [pc, #60]	; (114c <_sercom_get_async_baud_val+0x1c4>)
    1110:	4293      	cmp	r3, r2
    1112:	d908      	bls.n	1126 <_sercom_get_async_baud_val+0x19e>
    1114:	9a06      	ldr	r2, [sp, #24]
    1116:	3201      	adds	r2, #1
    1118:	b2d2      	uxtb	r2, r2
    111a:	9206      	str	r2, [sp, #24]
    111c:	1c0a      	adds	r2, r1, #0
    111e:	3201      	adds	r2, #1
    1120:	9205      	str	r2, [sp, #20]
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
    1122:	2a08      	cmp	r2, #8
    1124:	d1ae      	bne.n	1084 <_sercom_get_async_baud_val+0xfc>
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    1126:	2540      	movs	r5, #64	; 0x40
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
    1128:	9a06      	ldr	r2, [sp, #24]
    112a:	2a08      	cmp	r2, #8
    112c:	d004      	beq.n	1138 <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
    112e:	0351      	lsls	r1, r2, #13
    1130:	4319      	orrs	r1, r3
	}

	*baudval = baud_calculated;
    1132:	9b07      	ldr	r3, [sp, #28]
    1134:	8019      	strh	r1, [r3, #0]
	return STATUS_OK;
    1136:	2500      	movs	r5, #0
}
    1138:	1c28      	adds	r0, r5, #0
    113a:	b009      	add	sp, #36	; 0x24
    113c:	bc3c      	pop	{r2, r3, r4, r5}
    113e:	4690      	mov	r8, r2
    1140:	4699      	mov	r9, r3
    1142:	46a2      	mov	sl, r4
    1144:	46ab      	mov	fp, r5
    1146:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1148:	00004bcd 	.word	0x00004bcd
    114c:	00001fff 	.word	0x00001fff

00001150 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    1150:	b510      	push	{r4, lr}
    1152:	b082      	sub	sp, #8
    1154:	1c04      	adds	r4, r0, #0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    1156:	4b0e      	ldr	r3, [pc, #56]	; (1190 <sercom_set_gclk_generator+0x40>)
    1158:	781b      	ldrb	r3, [r3, #0]
    115a:	2b00      	cmp	r3, #0
    115c:	d001      	beq.n	1162 <sercom_set_gclk_generator+0x12>
    115e:	2900      	cmp	r1, #0
    1160:	d00d      	beq.n	117e <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    1162:	a901      	add	r1, sp, #4
    1164:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    1166:	200c      	movs	r0, #12
    1168:	4b0a      	ldr	r3, [pc, #40]	; (1194 <sercom_set_gclk_generator+0x44>)
    116a:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    116c:	200c      	movs	r0, #12
    116e:	4b0a      	ldr	r3, [pc, #40]	; (1198 <sercom_set_gclk_generator+0x48>)
    1170:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    1172:	4b07      	ldr	r3, [pc, #28]	; (1190 <sercom_set_gclk_generator+0x40>)
    1174:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    1176:	2201      	movs	r2, #1
    1178:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    117a:	2000      	movs	r0, #0
    117c:	e006      	b.n	118c <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
    117e:	4b04      	ldr	r3, [pc, #16]	; (1190 <sercom_set_gclk_generator+0x40>)
    1180:	785b      	ldrb	r3, [r3, #1]
    1182:	4283      	cmp	r3, r0
    1184:	d001      	beq.n	118a <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    1186:	201d      	movs	r0, #29
    1188:	e000      	b.n	118c <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
    118a:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    118c:	b002      	add	sp, #8
    118e:	bd10      	pop	{r4, pc}
    1190:	2000044c 	.word	0x2000044c
    1194:	000026cd 	.word	0x000026cd
    1198:	00002641 	.word	0x00002641

0000119c <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    119c:	4b44      	ldr	r3, [pc, #272]	; (12b0 <_sercom_get_default_pad+0x114>)
    119e:	4298      	cmp	r0, r3
    11a0:	d033      	beq.n	120a <_sercom_get_default_pad+0x6e>
    11a2:	d806      	bhi.n	11b2 <_sercom_get_default_pad+0x16>
    11a4:	4b43      	ldr	r3, [pc, #268]	; (12b4 <_sercom_get_default_pad+0x118>)
    11a6:	4298      	cmp	r0, r3
    11a8:	d00d      	beq.n	11c6 <_sercom_get_default_pad+0x2a>
    11aa:	4b43      	ldr	r3, [pc, #268]	; (12b8 <_sercom_get_default_pad+0x11c>)
    11ac:	4298      	cmp	r0, r3
    11ae:	d01b      	beq.n	11e8 <_sercom_get_default_pad+0x4c>
    11b0:	e06f      	b.n	1292 <_sercom_get_default_pad+0xf6>
    11b2:	4b42      	ldr	r3, [pc, #264]	; (12bc <_sercom_get_default_pad+0x120>)
    11b4:	4298      	cmp	r0, r3
    11b6:	d04a      	beq.n	124e <_sercom_get_default_pad+0xb2>
    11b8:	4b41      	ldr	r3, [pc, #260]	; (12c0 <_sercom_get_default_pad+0x124>)
    11ba:	4298      	cmp	r0, r3
    11bc:	d058      	beq.n	1270 <_sercom_get_default_pad+0xd4>
    11be:	4b41      	ldr	r3, [pc, #260]	; (12c4 <_sercom_get_default_pad+0x128>)
    11c0:	4298      	cmp	r0, r3
    11c2:	d166      	bne.n	1292 <_sercom_get_default_pad+0xf6>
    11c4:	e032      	b.n	122c <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    11c6:	2901      	cmp	r1, #1
    11c8:	d006      	beq.n	11d8 <_sercom_get_default_pad+0x3c>
    11ca:	2900      	cmp	r1, #0
    11cc:	d063      	beq.n	1296 <_sercom_get_default_pad+0xfa>
    11ce:	2902      	cmp	r1, #2
    11d0:	d006      	beq.n	11e0 <_sercom_get_default_pad+0x44>
    11d2:	2903      	cmp	r1, #3
    11d4:	d006      	beq.n	11e4 <_sercom_get_default_pad+0x48>
    11d6:	e001      	b.n	11dc <_sercom_get_default_pad+0x40>
    11d8:	483b      	ldr	r0, [pc, #236]	; (12c8 <_sercom_get_default_pad+0x12c>)
    11da:	e067      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    11dc:	2000      	movs	r0, #0
    11de:	e065      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    11e0:	483a      	ldr	r0, [pc, #232]	; (12cc <_sercom_get_default_pad+0x130>)
    11e2:	e063      	b.n	12ac <_sercom_get_default_pad+0x110>
    11e4:	483a      	ldr	r0, [pc, #232]	; (12d0 <_sercom_get_default_pad+0x134>)
    11e6:	e061      	b.n	12ac <_sercom_get_default_pad+0x110>
    11e8:	2901      	cmp	r1, #1
    11ea:	d006      	beq.n	11fa <_sercom_get_default_pad+0x5e>
    11ec:	2900      	cmp	r1, #0
    11ee:	d054      	beq.n	129a <_sercom_get_default_pad+0xfe>
    11f0:	2902      	cmp	r1, #2
    11f2:	d006      	beq.n	1202 <_sercom_get_default_pad+0x66>
    11f4:	2903      	cmp	r1, #3
    11f6:	d006      	beq.n	1206 <_sercom_get_default_pad+0x6a>
    11f8:	e001      	b.n	11fe <_sercom_get_default_pad+0x62>
    11fa:	4836      	ldr	r0, [pc, #216]	; (12d4 <_sercom_get_default_pad+0x138>)
    11fc:	e056      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    11fe:	2000      	movs	r0, #0
    1200:	e054      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    1202:	4835      	ldr	r0, [pc, #212]	; (12d8 <_sercom_get_default_pad+0x13c>)
    1204:	e052      	b.n	12ac <_sercom_get_default_pad+0x110>
    1206:	4835      	ldr	r0, [pc, #212]	; (12dc <_sercom_get_default_pad+0x140>)
    1208:	e050      	b.n	12ac <_sercom_get_default_pad+0x110>
    120a:	2901      	cmp	r1, #1
    120c:	d006      	beq.n	121c <_sercom_get_default_pad+0x80>
    120e:	2900      	cmp	r1, #0
    1210:	d045      	beq.n	129e <_sercom_get_default_pad+0x102>
    1212:	2902      	cmp	r1, #2
    1214:	d006      	beq.n	1224 <_sercom_get_default_pad+0x88>
    1216:	2903      	cmp	r1, #3
    1218:	d006      	beq.n	1228 <_sercom_get_default_pad+0x8c>
    121a:	e001      	b.n	1220 <_sercom_get_default_pad+0x84>
    121c:	4830      	ldr	r0, [pc, #192]	; (12e0 <_sercom_get_default_pad+0x144>)
    121e:	e045      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    1220:	2000      	movs	r0, #0
    1222:	e043      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    1224:	482f      	ldr	r0, [pc, #188]	; (12e4 <_sercom_get_default_pad+0x148>)
    1226:	e041      	b.n	12ac <_sercom_get_default_pad+0x110>
    1228:	482f      	ldr	r0, [pc, #188]	; (12e8 <_sercom_get_default_pad+0x14c>)
    122a:	e03f      	b.n	12ac <_sercom_get_default_pad+0x110>
    122c:	2901      	cmp	r1, #1
    122e:	d006      	beq.n	123e <_sercom_get_default_pad+0xa2>
    1230:	2900      	cmp	r1, #0
    1232:	d036      	beq.n	12a2 <_sercom_get_default_pad+0x106>
    1234:	2902      	cmp	r1, #2
    1236:	d006      	beq.n	1246 <_sercom_get_default_pad+0xaa>
    1238:	2903      	cmp	r1, #3
    123a:	d006      	beq.n	124a <_sercom_get_default_pad+0xae>
    123c:	e001      	b.n	1242 <_sercom_get_default_pad+0xa6>
    123e:	482b      	ldr	r0, [pc, #172]	; (12ec <_sercom_get_default_pad+0x150>)
    1240:	e034      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    1242:	2000      	movs	r0, #0
    1244:	e032      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    1246:	482a      	ldr	r0, [pc, #168]	; (12f0 <_sercom_get_default_pad+0x154>)
    1248:	e030      	b.n	12ac <_sercom_get_default_pad+0x110>
    124a:	482a      	ldr	r0, [pc, #168]	; (12f4 <_sercom_get_default_pad+0x158>)
    124c:	e02e      	b.n	12ac <_sercom_get_default_pad+0x110>
    124e:	2901      	cmp	r1, #1
    1250:	d006      	beq.n	1260 <_sercom_get_default_pad+0xc4>
    1252:	2900      	cmp	r1, #0
    1254:	d027      	beq.n	12a6 <_sercom_get_default_pad+0x10a>
    1256:	2902      	cmp	r1, #2
    1258:	d006      	beq.n	1268 <_sercom_get_default_pad+0xcc>
    125a:	2903      	cmp	r1, #3
    125c:	d006      	beq.n	126c <_sercom_get_default_pad+0xd0>
    125e:	e001      	b.n	1264 <_sercom_get_default_pad+0xc8>
    1260:	4825      	ldr	r0, [pc, #148]	; (12f8 <_sercom_get_default_pad+0x15c>)
    1262:	e023      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    1264:	2000      	movs	r0, #0
    1266:	e021      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    1268:	4824      	ldr	r0, [pc, #144]	; (12fc <_sercom_get_default_pad+0x160>)
    126a:	e01f      	b.n	12ac <_sercom_get_default_pad+0x110>
    126c:	4824      	ldr	r0, [pc, #144]	; (1300 <_sercom_get_default_pad+0x164>)
    126e:	e01d      	b.n	12ac <_sercom_get_default_pad+0x110>
    1270:	2901      	cmp	r1, #1
    1272:	d006      	beq.n	1282 <_sercom_get_default_pad+0xe6>
    1274:	2900      	cmp	r1, #0
    1276:	d018      	beq.n	12aa <_sercom_get_default_pad+0x10e>
    1278:	2902      	cmp	r1, #2
    127a:	d006      	beq.n	128a <_sercom_get_default_pad+0xee>
    127c:	2903      	cmp	r1, #3
    127e:	d006      	beq.n	128e <_sercom_get_default_pad+0xf2>
    1280:	e001      	b.n	1286 <_sercom_get_default_pad+0xea>
    1282:	4820      	ldr	r0, [pc, #128]	; (1304 <_sercom_get_default_pad+0x168>)
    1284:	e012      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    1286:	2000      	movs	r0, #0
    1288:	e010      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    128a:	481f      	ldr	r0, [pc, #124]	; (1308 <_sercom_get_default_pad+0x16c>)
    128c:	e00e      	b.n	12ac <_sercom_get_default_pad+0x110>
    128e:	481f      	ldr	r0, [pc, #124]	; (130c <_sercom_get_default_pad+0x170>)
    1290:	e00c      	b.n	12ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    1292:	2000      	movs	r0, #0
    1294:	e00a      	b.n	12ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    1296:	481e      	ldr	r0, [pc, #120]	; (1310 <_sercom_get_default_pad+0x174>)
    1298:	e008      	b.n	12ac <_sercom_get_default_pad+0x110>
    129a:	2003      	movs	r0, #3
    129c:	e006      	b.n	12ac <_sercom_get_default_pad+0x110>
    129e:	481d      	ldr	r0, [pc, #116]	; (1314 <_sercom_get_default_pad+0x178>)
    12a0:	e004      	b.n	12ac <_sercom_get_default_pad+0x110>
    12a2:	481d      	ldr	r0, [pc, #116]	; (1318 <_sercom_get_default_pad+0x17c>)
    12a4:	e002      	b.n	12ac <_sercom_get_default_pad+0x110>
    12a6:	481d      	ldr	r0, [pc, #116]	; (131c <_sercom_get_default_pad+0x180>)
    12a8:	e000      	b.n	12ac <_sercom_get_default_pad+0x110>
    12aa:	481d      	ldr	r0, [pc, #116]	; (1320 <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
    12ac:	4770      	bx	lr
    12ae:	46c0      	nop			; (mov r8, r8)
    12b0:	42001000 	.word	0x42001000
    12b4:	42000800 	.word	0x42000800
    12b8:	42000c00 	.word	0x42000c00
    12bc:	42001800 	.word	0x42001800
    12c0:	42001c00 	.word	0x42001c00
    12c4:	42001400 	.word	0x42001400
    12c8:	00050003 	.word	0x00050003
    12cc:	00060003 	.word	0x00060003
    12d0:	00070003 	.word	0x00070003
    12d4:	00010003 	.word	0x00010003
    12d8:	001e0003 	.word	0x001e0003
    12dc:	001f0003 	.word	0x001f0003
    12e0:	00090003 	.word	0x00090003
    12e4:	000a0003 	.word	0x000a0003
    12e8:	000b0003 	.word	0x000b0003
    12ec:	00110003 	.word	0x00110003
    12f0:	00120003 	.word	0x00120003
    12f4:	00130003 	.word	0x00130003
    12f8:	000d0003 	.word	0x000d0003
    12fc:	000e0003 	.word	0x000e0003
    1300:	000f0003 	.word	0x000f0003
    1304:	00170003 	.word	0x00170003
    1308:	00180003 	.word	0x00180003
    130c:	00190003 	.word	0x00190003
    1310:	00040003 	.word	0x00040003
    1314:	00080003 	.word	0x00080003
    1318:	00100003 	.word	0x00100003
    131c:	000c0003 	.word	0x000c0003
    1320:	00160003 	.word	0x00160003

00001324 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    1324:	b530      	push	{r4, r5, lr}
    1326:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    1328:	4b0c      	ldr	r3, [pc, #48]	; (135c <_sercom_get_sercom_inst_index+0x38>)
    132a:	466a      	mov	r2, sp
    132c:	cb32      	ldmia	r3!, {r1, r4, r5}
    132e:	c232      	stmia	r2!, {r1, r4, r5}
    1330:	cb32      	ldmia	r3!, {r1, r4, r5}
    1332:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    1334:	9b00      	ldr	r3, [sp, #0]
    1336:	4283      	cmp	r3, r0
    1338:	d006      	beq.n	1348 <_sercom_get_sercom_inst_index+0x24>
    133a:	2301      	movs	r3, #1
    133c:	009a      	lsls	r2, r3, #2
    133e:	4669      	mov	r1, sp
    1340:	5852      	ldr	r2, [r2, r1]
    1342:	4282      	cmp	r2, r0
    1344:	d103      	bne.n	134e <_sercom_get_sercom_inst_index+0x2a>
    1346:	e000      	b.n	134a <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1348:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
    134a:	b2d8      	uxtb	r0, r3
    134c:	e003      	b.n	1356 <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    134e:	3301      	adds	r3, #1
    1350:	2b06      	cmp	r3, #6
    1352:	d1f3      	bne.n	133c <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    1354:	2000      	movs	r0, #0
}
    1356:	b007      	add	sp, #28
    1358:	bd30      	pop	{r4, r5, pc}
    135a:	46c0      	nop			; (mov r8, r8)
    135c:	00004f14 	.word	0x00004f14

00001360 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    1360:	4770      	bx	lr
    1362:	46c0      	nop			; (mov r8, r8)

00001364 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    1364:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    1366:	4b0a      	ldr	r3, [pc, #40]	; (1390 <_sercom_set_handler+0x2c>)
    1368:	781b      	ldrb	r3, [r3, #0]
    136a:	2b00      	cmp	r3, #0
    136c:	d10c      	bne.n	1388 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    136e:	4f09      	ldr	r7, [pc, #36]	; (1394 <_sercom_set_handler+0x30>)
    1370:	4e09      	ldr	r6, [pc, #36]	; (1398 <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
    1372:	4d0a      	ldr	r5, [pc, #40]	; (139c <_sercom_set_handler+0x38>)
    1374:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    1376:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
    1378:	195a      	adds	r2, r3, r5
    137a:	6014      	str	r4, [r2, #0]
    137c:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    137e:	2b18      	cmp	r3, #24
    1380:	d1f9      	bne.n	1376 <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    1382:	2201      	movs	r2, #1
    1384:	4b02      	ldr	r3, [pc, #8]	; (1390 <_sercom_set_handler+0x2c>)
    1386:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    1388:	0080      	lsls	r0, r0, #2
    138a:	4b02      	ldr	r3, [pc, #8]	; (1394 <_sercom_set_handler+0x30>)
    138c:	50c1      	str	r1, [r0, r3]
}
    138e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1390:	2000044e 	.word	0x2000044e
    1394:	20000450 	.word	0x20000450
    1398:	00001361 	.word	0x00001361
    139c:	20004130 	.word	0x20004130

000013a0 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    13a0:	b510      	push	{r4, lr}
    13a2:	b082      	sub	sp, #8
    13a4:	1c04      	adds	r4, r0, #0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    13a6:	4668      	mov	r0, sp
    13a8:	4905      	ldr	r1, [pc, #20]	; (13c0 <_sercom_get_interrupt_vector+0x20>)
    13aa:	2206      	movs	r2, #6
    13ac:	4b05      	ldr	r3, [pc, #20]	; (13c4 <_sercom_get_interrupt_vector+0x24>)
    13ae:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    13b0:	1c20      	adds	r0, r4, #0
    13b2:	4b05      	ldr	r3, [pc, #20]	; (13c8 <_sercom_get_interrupt_vector+0x28>)
    13b4:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    13b6:	466b      	mov	r3, sp
    13b8:	5618      	ldrsb	r0, [r3, r0]
}
    13ba:	b002      	add	sp, #8
    13bc:	bd10      	pop	{r4, pc}
    13be:	46c0      	nop			; (mov r8, r8)
    13c0:	00004f2c 	.word	0x00004f2c
    13c4:	00004c6d 	.word	0x00004c6d
    13c8:	00001325 	.word	0x00001325

000013cc <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    13cc:	b508      	push	{r3, lr}
    13ce:	4b02      	ldr	r3, [pc, #8]	; (13d8 <SERCOM0_Handler+0xc>)
    13d0:	681b      	ldr	r3, [r3, #0]
    13d2:	2000      	movs	r0, #0
    13d4:	4798      	blx	r3
    13d6:	bd08      	pop	{r3, pc}
    13d8:	20000450 	.word	0x20000450

000013dc <SERCOM1_Handler>:
    13dc:	b508      	push	{r3, lr}
    13de:	4b02      	ldr	r3, [pc, #8]	; (13e8 <SERCOM1_Handler+0xc>)
    13e0:	685b      	ldr	r3, [r3, #4]
    13e2:	2001      	movs	r0, #1
    13e4:	4798      	blx	r3
    13e6:	bd08      	pop	{r3, pc}
    13e8:	20000450 	.word	0x20000450

000013ec <SERCOM2_Handler>:
    13ec:	b508      	push	{r3, lr}
    13ee:	4b02      	ldr	r3, [pc, #8]	; (13f8 <SERCOM2_Handler+0xc>)
    13f0:	689b      	ldr	r3, [r3, #8]
    13f2:	2002      	movs	r0, #2
    13f4:	4798      	blx	r3
    13f6:	bd08      	pop	{r3, pc}
    13f8:	20000450 	.word	0x20000450

000013fc <SERCOM3_Handler>:
    13fc:	b508      	push	{r3, lr}
    13fe:	4b02      	ldr	r3, [pc, #8]	; (1408 <SERCOM3_Handler+0xc>)
    1400:	68db      	ldr	r3, [r3, #12]
    1402:	2003      	movs	r0, #3
    1404:	4798      	blx	r3
    1406:	bd08      	pop	{r3, pc}
    1408:	20000450 	.word	0x20000450

0000140c <SERCOM4_Handler>:
    140c:	b508      	push	{r3, lr}
    140e:	4b02      	ldr	r3, [pc, #8]	; (1418 <SERCOM4_Handler+0xc>)
    1410:	691b      	ldr	r3, [r3, #16]
    1412:	2004      	movs	r0, #4
    1414:	4798      	blx	r3
    1416:	bd08      	pop	{r3, pc}
    1418:	20000450 	.word	0x20000450

0000141c <SERCOM5_Handler>:
    141c:	b508      	push	{r3, lr}
    141e:	4b02      	ldr	r3, [pc, #8]	; (1428 <SERCOM5_Handler+0xc>)
    1420:	695b      	ldr	r3, [r3, #20]
    1422:	2005      	movs	r0, #5
    1424:	4798      	blx	r3
    1426:	bd08      	pop	{r3, pc}
    1428:	20000450 	.word	0x20000450

0000142c <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    142c:	b5f0      	push	{r4, r5, r6, r7, lr}
    142e:	465f      	mov	r7, fp
    1430:	4656      	mov	r6, sl
    1432:	464d      	mov	r5, r9
    1434:	4644      	mov	r4, r8
    1436:	b4f0      	push	{r4, r5, r6, r7}
    1438:	b089      	sub	sp, #36	; 0x24
    143a:	4680      	mov	r8, r0
    143c:	1c0d      	adds	r5, r1, #0
    143e:	1c14      	adds	r4, r2, #0
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    1440:	1c03      	adds	r3, r0, #0
    1442:	6019      	str	r1, [r3, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    1444:	680b      	ldr	r3, [r1, #0]
    1446:	079b      	lsls	r3, r3, #30
    1448:	d400      	bmi.n	144c <spi_init+0x20>
    144a:	e09c      	b.n	1586 <spi_init+0x15a>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
	Sercom *const hw = module->hw;

	uint32_t pad_pinmuxes[] = {
    144c:	6a53      	ldr	r3, [r2, #36]	; 0x24
    144e:	9303      	str	r3, [sp, #12]
    1450:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1452:	9304      	str	r3, [sp, #16]
    1454:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    1456:	9305      	str	r3, [sp, #20]
    1458:	6b13      	ldr	r3, [r2, #48]	; 0x30
    145a:	9306      	str	r3, [sp, #24]
    145c:	2700      	movs	r7, #0
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    145e:	231f      	movs	r3, #31
    1460:	4699      	mov	r9, r3
    1462:	b2f9      	uxtb	r1, r7
    1464:	00bb      	lsls	r3, r7, #2
		config->pinmux_pad2, config->pinmux_pad3
	};

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    1466:	aa03      	add	r2, sp, #12
    1468:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    146a:	2800      	cmp	r0, #0
    146c:	d102      	bne.n	1474 <spi_init+0x48>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    146e:	1c28      	adds	r0, r5, #0
    1470:	4ba0      	ldr	r3, [pc, #640]	; (16f4 <spi_init+0x2c8>)
    1472:	4798      	blx	r3
		}

		if (current_pinmux == PINMUX_UNUSED) {
    1474:	1c43      	adds	r3, r0, #1
    1476:	d028      	beq.n	14ca <spi_init+0x9e>
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    1478:	0401      	lsls	r1, r0, #16
    147a:	0c0b      	lsrs	r3, r1, #16
    147c:	469b      	mov	fp, r3
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
    147e:	0c00      	lsrs	r0, r0, #16
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1480:	b2c6      	uxtb	r6, r0
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1482:	2300      	movs	r3, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1484:	0602      	lsls	r2, r0, #24
    1486:	d404      	bmi.n	1492 <spi_init+0x66>
		return &(ports[port_index]->Group[group_index]);
    1488:	0973      	lsrs	r3, r6, #5
    148a:	01db      	lsls	r3, r3, #7
    148c:	4a9a      	ldr	r2, [pc, #616]	; (16f8 <spi_init+0x2cc>)
    148e:	4694      	mov	ip, r2
    1490:	4463      	add	r3, ip
 */
static inline uint8_t system_pinmux_pin_get_mux_position(
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);
    1492:	464a      	mov	r2, r9
    1494:	4032      	ands	r2, r6

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    1496:	1898      	adds	r0, r3, r2
    1498:	3040      	adds	r0, #64	; 0x40
    149a:	7800      	ldrb	r0, [r0, #0]
    149c:	4682      	mov	sl, r0
		return SYSTEM_PINMUX_GPIO;
    149e:	2080      	movs	r0, #128	; 0x80
		const uint8_t gpio_pin)
{
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_index = (gpio_pin % 32);

	if (!(port->PINCFG[pin_index].reg & PORT_PINCFG_PMUXEN)) {
    14a0:	4651      	mov	r1, sl
    14a2:	07c9      	lsls	r1, r1, #31
    14a4:	d50a      	bpl.n	14bc <spi_init+0x90>
		return SYSTEM_PINMUX_GPIO;
	}

	uint32_t pmux_reg = port->PMUX[pin_index / 2].reg;
    14a6:	0852      	lsrs	r2, r2, #1
    14a8:	189b      	adds	r3, r3, r2
    14aa:	3330      	adds	r3, #48	; 0x30
    14ac:	7818      	ldrb	r0, [r3, #0]
    14ae:	b2c0      	uxtb	r0, r0

	if (pin_index & 1) {
    14b0:	07f3      	lsls	r3, r6, #31
    14b2:	d501      	bpl.n	14b8 <spi_init+0x8c>
		return (pmux_reg & PORT_PMUX_PMUXO_Msk) >> PORT_PMUX_PMUXO_Pos;
    14b4:	0900      	lsrs	r0, r0, #4
    14b6:	e001      	b.n	14bc <spi_init+0x90>
	}
	else {
		return (pmux_reg & PORT_PMUX_PMUXE_Msk) >> PORT_PMUX_PMUXE_Pos;
    14b8:	230f      	movs	r3, #15
    14ba:	4018      	ands	r0, r3

		if (current_pinmux == PINMUX_UNUSED) {
			continue;
		}

		if ((current_pinmux & 0xFFFF) !=
    14bc:	4583      	cmp	fp, r0
    14be:	d004      	beq.n	14ca <spi_init+0x9e>
				system_pinmux_pin_get_mux_position(current_pinmux >> 16)) {
			module->hw = NULL;
    14c0:	2300      	movs	r3, #0
    14c2:	4642      	mov	r2, r8
    14c4:	6013      	str	r3, [r2, #0]
			return STATUS_ERR_DENIED;
    14c6:	201c      	movs	r0, #28
    14c8:	e10c      	b.n	16e4 <spi_init+0x2b8>
    14ca:	3701      	adds	r7, #1
		config->pinmux_pad0, config->pinmux_pad1,
		config->pinmux_pad2, config->pinmux_pad3
	};

	/* Compare the current SERCOM pins against the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    14cc:	2f04      	cmp	r7, #4
    14ce:	d1c8      	bne.n	1462 <spi_init+0x36>
	}

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to read BAUD register */
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
    14d0:	200c      	movs	r0, #12
    14d2:	4b8a      	ldr	r3, [pc, #552]	; (16fc <spi_init+0x2d0>)
    14d4:	4798      	blx	r3
    14d6:	1c01      	adds	r1, r0, #0
	uint32_t addr = 0;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and compare it */
	if (config->mode == SPI_MODE_MASTER) {
    14d8:	7822      	ldrb	r2, [r4, #0]
	/* Value to read BAUD register */
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
#  endif
	/* Value to read CTRLA, CTRLB and ADDR register */
	uint32_t ctrla = 0;
    14da:	2700      	movs	r7, #0
	uint32_t addr = 0;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and compare it */
	if (config->mode == SPI_MODE_MASTER) {
    14dc:	2a01      	cmp	r2, #1
    14de:	d111      	bne.n	1504 <spi_init+0xd8>
		enum status_code error_code = _sercom_get_sync_baud_val(
    14e0:	6960      	ldr	r0, [r4, #20]
    14e2:	aa02      	add	r2, sp, #8
    14e4:	4b86      	ldr	r3, [pc, #536]	; (1700 <spi_init+0x2d4>)
    14e6:	4798      	blx	r3
    14e8:	1c03      	adds	r3, r0, #0
				config->mode_specific.master.baudrate,
				external_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    14ea:	2017      	movs	r0, #23
	if (config->mode == SPI_MODE_MASTER) {
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				external_clock, &baud);

		if (error_code != STATUS_OK) {
    14ec:	2b00      	cmp	r3, #0
    14ee:	d000      	beq.n	14f2 <spi_init+0xc6>
    14f0:	e0f8      	b.n	16e4 <spi_init+0x2b8>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		if (spi_module->BAUD.reg !=  (uint8_t)baud) {
    14f2:	7aab      	ldrb	r3, [r5, #10]
    14f4:	b2db      	uxtb	r3, r3
    14f6:	aa02      	add	r2, sp, #8
    14f8:	7812      	ldrb	r2, [r2, #0]
			return STATUS_ERR_DENIED;
    14fa:	3005      	adds	r0, #5
		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		if (spi_module->BAUD.reg !=  (uint8_t)baud) {
    14fc:	429a      	cmp	r2, r3
    14fe:	d000      	beq.n	1502 <spi_init+0xd6>
    1500:	e0f0      	b.n	16e4 <spi_init+0x2b8>
			return STATUS_ERR_DENIED;
		}

		ctrla |= SERCOM_SPI_CTRLA_MODE(0x3);
    1502:	370c      	adds	r7, #12
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    1504:	7826      	ldrb	r6, [r4, #0]
    1506:	2e00      	cmp	r6, #0
    1508:	d115      	bne.n	1536 <spi_init+0x10a>

		/* Set frame format */
		ctrla |= config->mode_specific.slave.frame_format;
    150a:	6963      	ldr	r3, [r4, #20]
    150c:	469c      	mov	ip, r3

		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;
    150e:	8b22      	ldrh	r2, [r4, #24]

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
		if (spi_module->CTRLA.reg != addr) {
    1510:	682b      	ldr	r3, [r5, #0]
		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
    1512:	7ee1      	ldrb	r1, [r4, #27]
    1514:	0409      	lsls	r1, r1, #16

		/* Set address mode */
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
    1516:	7ea0      	ldrb	r0, [r4, #26]
    1518:	4301      	orrs	r1, r0
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
		if (spi_module->CTRLA.reg != addr) {
			return STATUS_ERR_DENIED;
    151a:	201c      	movs	r0, #28
		ctrlb |= config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		addr |= (config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
		if (spi_module->CTRLA.reg != addr) {
    151c:	4299      	cmp	r1, r3
    151e:	d000      	beq.n	1522 <spi_init+0xf6>
    1520:	e0e0      	b.n	16e4 <spi_init+0x2b8>
			return STATUS_ERR_DENIED;
		}

		if (config->mode_specific.slave.preload_enable) {
    1522:	7f23      	ldrb	r3, [r4, #28]
    1524:	2b00      	cmp	r3, #0
    1526:	d001      	beq.n	152c <spi_init+0x100>
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
    1528:	2340      	movs	r3, #64	; 0x40
    152a:	431a      	orrs	r2, r3
    152c:	2308      	movs	r3, #8
    152e:	4661      	mov	r1, ip
    1530:	4319      	orrs	r1, r3
		}
		ctrla |= SERCOM_SPI_CTRLA_MODE(0x2);
    1532:	430f      	orrs	r7, r1
    1534:	e000      	b.n	1538 <spi_init+0x10c>
	uint16_t baud;
	uint32_t external_clock = system_gclk_chan_get_hz(SERCOM_GCLK_ID);
#  endif
	/* Value to read CTRLA, CTRLB and ADDR register */
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
    1536:	2200      	movs	r2, #0
    1538:	68a3      	ldr	r3, [r4, #8]
    153a:	6861      	ldr	r1, [r4, #4]
    153c:	430b      	orrs	r3, r1
    153e:	68e1      	ldr	r1, [r4, #12]
    1540:	430b      	orrs	r3, r1

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    1542:	433b      	orrs	r3, r7

	/* Set SPI character size */
	ctrlb |= config->character_size;
    1544:	7c21      	ldrb	r1, [r4, #16]
    1546:	430a      	orrs	r2, r1

	if (config->run_in_standby) {
    1548:	7c61      	ldrb	r1, [r4, #17]
    154a:	2900      	cmp	r1, #0
    154c:	d001      	beq.n	1552 <spi_init+0x126>
		/* Enable in sleep mode */
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    154e:	2180      	movs	r1, #128	; 0x80
    1550:	430b      	orrs	r3, r1
	}

	if (config->receiver_enable) {
    1552:	7ca1      	ldrb	r1, [r4, #18]
    1554:	2900      	cmp	r1, #0
    1556:	d002      	beq.n	155e <spi_init+0x132>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    1558:	2180      	movs	r1, #128	; 0x80
    155a:	0289      	lsls	r1, r1, #10
    155c:	430a      	orrs	r2, r1
#  endif

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
    155e:	6828      	ldr	r0, [r5, #0]
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
	}
#  endif

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;
    1560:	2102      	movs	r1, #2
    1562:	430b      	orrs	r3, r1

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
    1564:	4283      	cmp	r3, r0
    1566:	d109      	bne.n	157c <spi_init+0x150>
			spi_module->CTRLB.reg == ctrlb) {
    1568:	686b      	ldr	r3, [r5, #4]
#  endif

	ctrla |= SERCOM_SPI_CTRLA_ENABLE;

	/* Check that same config is set */
	if (spi_module->CTRLA.reg == ctrla &&
    156a:	4293      	cmp	r3, r2
    156c:	d106      	bne.n	157c <spi_init+0x150>
			spi_module->CTRLB.reg == ctrlb) {
		module->mode           = config->mode;
    156e:	4643      	mov	r3, r8
    1570:	715e      	strb	r6, [r3, #5]
		module->character_size = config->character_size;
    1572:	7c23      	ldrb	r3, [r4, #16]
    1574:	4642      	mov	r2, r8
    1576:	7193      	strb	r3, [r2, #6]
		return STATUS_OK;
    1578:	2000      	movs	r0, #0
    157a:	e0b3      	b.n	16e4 <spi_init+0x2b8>
	}

	/* Not same config, wipe module pointer and return */
	module->hw = NULL;
    157c:	2300      	movs	r3, #0
    157e:	4642      	mov	r2, r8
    1580:	6013      	str	r3, [r2, #0]

	return STATUS_ERR_DENIED;
    1582:	201c      	movs	r0, #28
    1584:	e0ae      	b.n	16e4 <spi_init+0x2b8>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    1586:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
    1588:	2005      	movs	r0, #5
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    158a:	07db      	lsls	r3, r3, #31
    158c:	d500      	bpl.n	1590 <spi_init+0x164>
    158e:	e0a9      	b.n	16e4 <spi_init+0x2b8>
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    1590:	1c08      	adds	r0, r1, #0
    1592:	4b5c      	ldr	r3, [pc, #368]	; (1704 <spi_init+0x2d8>)
    1594:	4798      	blx	r3
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    1596:	495c      	ldr	r1, [pc, #368]	; (1708 <spi_init+0x2dc>)
    1598:	6a0a      	ldr	r2, [r1, #32]
	}
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    159a:	1c86      	adds	r6, r0, #2
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    159c:	2301      	movs	r3, #1
    159e:	40b3      	lsls	r3, r6
    15a0:	4313      	orrs	r3, r2
    15a2:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    15a4:	a907      	add	r1, sp, #28
    15a6:	2720      	movs	r7, #32
    15a8:	5de3      	ldrb	r3, [r4, r7]
    15aa:	700b      	strb	r3, [r1, #0]
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    15ac:	300d      	adds	r0, #13

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    15ae:	b2c6      	uxtb	r6, r0
    15b0:	1c30      	adds	r0, r6, #0
    15b2:	4b56      	ldr	r3, [pc, #344]	; (170c <spi_init+0x2e0>)
    15b4:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    15b6:	1c30      	adds	r0, r6, #0
    15b8:	4b55      	ldr	r3, [pc, #340]	; (1710 <spi_init+0x2e4>)
    15ba:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    15bc:	5de0      	ldrb	r0, [r4, r7]
    15be:	2100      	movs	r1, #0
    15c0:	4b54      	ldr	r3, [pc, #336]	; (1714 <spi_init+0x2e8>)
    15c2:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    15c4:	7823      	ldrb	r3, [r4, #0]
    15c6:	2b01      	cmp	r3, #1
    15c8:	d103      	bne.n	15d2 <spi_init+0x1a6>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    15ca:	682a      	ldr	r2, [r5, #0]
    15cc:	330b      	adds	r3, #11
    15ce:	4313      	orrs	r3, r2
    15d0:	602b      	str	r3, [r5, #0]
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    15d2:	7823      	ldrb	r3, [r4, #0]
    15d4:	2b00      	cmp	r3, #0
    15d6:	d103      	bne.n	15e0 <spi_init+0x1b4>
		/* Set the SERCOM in SPI slave mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x2);
    15d8:	682a      	ldr	r2, [r5, #0]
    15da:	3308      	adds	r3, #8
    15dc:	4313      	orrs	r3, r2
    15de:	602b      	str	r3, [r5, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    15e0:	4643      	mov	r3, r8
    15e2:	681e      	ldr	r6, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    15e4:	ab02      	add	r3, sp, #8
    15e6:	2280      	movs	r2, #128	; 0x80
    15e8:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    15ea:	2200      	movs	r2, #0
    15ec:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    15ee:	2101      	movs	r1, #1
    15f0:	7099      	strb	r1, [r3, #2]
	config->powersave    = false;
    15f2:	70da      	strb	r2, [r3, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    15f4:	7823      	ldrb	r3, [r4, #0]
    15f6:	2b00      	cmp	r3, #0
    15f8:	d101      	bne.n	15fe <spi_init+0x1d2>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    15fa:	ab02      	add	r3, sp, #8
    15fc:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
    15fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1600:	9303      	str	r3, [sp, #12]
    1602:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1604:	9304      	str	r3, [sp, #16]
    1606:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1608:	9305      	str	r3, [sp, #20]
    160a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    160c:	9306      	str	r3, [sp, #24]
    160e:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    1610:	ad02      	add	r5, sp, #8
    1612:	b2f9      	uxtb	r1, r7
    1614:	00bb      	lsls	r3, r7, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    1616:	aa03      	add	r2, sp, #12
    1618:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    161a:	2800      	cmp	r0, #0
    161c:	d102      	bne.n	1624 <spi_init+0x1f8>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    161e:	1c30      	adds	r0, r6, #0
    1620:	4b34      	ldr	r3, [pc, #208]	; (16f4 <spi_init+0x2c8>)
    1622:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    1624:	1c43      	adds	r3, r0, #1
    1626:	d005      	beq.n	1634 <spi_init+0x208>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    1628:	7028      	strb	r0, [r5, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    162a:	0c00      	lsrs	r0, r0, #16
    162c:	b2c0      	uxtb	r0, r0
    162e:	1c29      	adds	r1, r5, #0
    1630:	4b39      	ldr	r3, [pc, #228]	; (1718 <spi_init+0x2ec>)
    1632:	4798      	blx	r3
    1634:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    1636:	2f04      	cmp	r7, #4
    1638:	d1eb      	bne.n	1612 <spi_init+0x1e6>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    163a:	7823      	ldrb	r3, [r4, #0]
    163c:	4642      	mov	r2, r8
    163e:	7153      	strb	r3, [r2, #5]
	module->character_size   = config->character_size;
    1640:	7c23      	ldrb	r3, [r4, #16]
    1642:	7193      	strb	r3, [r2, #6]
	module->receiver_enabled = config->receiver_enable;
    1644:	7ca3      	ldrb	r3, [r4, #18]
    1646:	71d3      	strb	r3, [r2, #7]
	module->master_slave_select_enable = config->master_slave_select_enable;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    1648:	2200      	movs	r2, #0
    164a:	466b      	mov	r3, sp
    164c:	80da      	strh	r2, [r3, #6]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    164e:	7823      	ldrb	r3, [r4, #0]
    1650:	2b01      	cmp	r3, #1
    1652:	d115      	bne.n	1680 <spi_init+0x254>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    1654:	4643      	mov	r3, r8
    1656:	6818      	ldr	r0, [r3, #0]
    1658:	4b2a      	ldr	r3, [pc, #168]	; (1704 <spi_init+0x2d8>)
    165a:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    165c:	300d      	adds	r0, #13
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    165e:	b2c0      	uxtb	r0, r0
    1660:	4b26      	ldr	r3, [pc, #152]	; (16fc <spi_init+0x2d0>)
    1662:	4798      	blx	r3
    1664:	1c01      	adds	r1, r0, #0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    1666:	6960      	ldr	r0, [r4, #20]
    1668:	466b      	mov	r3, sp
    166a:	1d9a      	adds	r2, r3, #6
    166c:	4b24      	ldr	r3, [pc, #144]	; (1700 <spi_init+0x2d4>)
    166e:	4798      	blx	r3
    1670:	1c03      	adds	r3, r0, #0
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    1672:	2017      	movs	r0, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    1674:	2b00      	cmp	r3, #0
    1676:	d135      	bne.n	16e4 <spi_init+0x2b8>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    1678:	466b      	mov	r3, sp
    167a:	3306      	adds	r3, #6
    167c:	781b      	ldrb	r3, [r3, #0]
    167e:	72b3      	strb	r3, [r6, #10]
	}
# endif
# if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    1680:	7823      	ldrb	r3, [r4, #0]
    1682:	2b00      	cmp	r3, #0
    1684:	d10e      	bne.n	16a4 <spi_init+0x278>
		/* Set frame format */
		ctrla = config->mode_specific.slave.frame_format;
    1686:	6961      	ldr	r1, [r4, #20]

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;
    1688:	8b22      	ldrh	r2, [r4, #24]

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    168a:	6970      	ldr	r0, [r6, #20]
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
    168c:	7ee3      	ldrb	r3, [r4, #27]
    168e:	041b      	lsls	r3, r3, #16
		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
    1690:	7ea5      	ldrb	r5, [r4, #26]
    1692:	432b      	orrs	r3, r5

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    1694:	4303      	orrs	r3, r0
    1696:	6173      	str	r3, [r6, #20]
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);

		if (config->mode_specific.slave.preload_enable) {
    1698:	7f23      	ldrb	r3, [r4, #28]
    169a:	2b00      	cmp	r3, #0
    169c:	d004      	beq.n	16a8 <spi_init+0x27c>
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
    169e:	2340      	movs	r3, #64	; 0x40
    16a0:	431a      	orrs	r2, r3
    16a2:	e001      	b.n	16a8 <spi_init+0x27c>
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
    16a4:	2200      	movs	r2, #0
#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
    16a6:	2100      	movs	r1, #0
    16a8:	68a3      	ldr	r3, [r4, #8]
    16aa:	6860      	ldr	r0, [r4, #4]
    16ac:	4303      	orrs	r3, r0
    16ae:	68e0      	ldr	r0, [r4, #12]
    16b0:	4303      	orrs	r3, r0

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    16b2:	430b      	orrs	r3, r1

	/* Set SPI character size */
	ctrlb |= config->character_size;
    16b4:	7c21      	ldrb	r1, [r4, #16]
    16b6:	430a      	orrs	r2, r1

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    16b8:	7c61      	ldrb	r1, [r4, #17]
    16ba:	2900      	cmp	r1, #0
    16bc:	d103      	bne.n	16c6 <spi_init+0x29a>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    16be:	4917      	ldr	r1, [pc, #92]	; (171c <spi_init+0x2f0>)
    16c0:	7889      	ldrb	r1, [r1, #2]
    16c2:	0789      	lsls	r1, r1, #30
    16c4:	d501      	bpl.n	16ca <spi_init+0x29e>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    16c6:	2180      	movs	r1, #128	; 0x80
    16c8:	430b      	orrs	r3, r1
	}

	if (config->receiver_enable) {
    16ca:	7ca1      	ldrb	r1, [r4, #18]
    16cc:	2900      	cmp	r1, #0
    16ce:	d002      	beq.n	16d6 <spi_init+0x2aa>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    16d0:	2180      	movs	r1, #128	; 0x80
    16d2:	0289      	lsls	r1, r1, #10
    16d4:	430a      	orrs	r2, r1
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    16d6:	6831      	ldr	r1, [r6, #0]
    16d8:	430b      	orrs	r3, r1
    16da:	6033      	str	r3, [r6, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    16dc:	6873      	ldr	r3, [r6, #4]
    16de:	431a      	orrs	r2, r3
    16e0:	6072      	str	r2, [r6, #4]

	return STATUS_OK;
    16e2:	2000      	movs	r0, #0
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    16e4:	b009      	add	sp, #36	; 0x24
    16e6:	bc3c      	pop	{r2, r3, r4, r5}
    16e8:	4690      	mov	r8, r2
    16ea:	4699      	mov	r9, r3
    16ec:	46a2      	mov	sl, r4
    16ee:	46ab      	mov	fp, r5
    16f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    16f2:	46c0      	nop			; (mov r8, r8)
    16f4:	0000119d 	.word	0x0000119d
    16f8:	41004400 	.word	0x41004400
    16fc:	000026e9 	.word	0x000026e9
    1700:	00000f61 	.word	0x00000f61
    1704:	00001325 	.word	0x00001325
    1708:	40000400 	.word	0x40000400
    170c:	000026cd 	.word	0x000026cd
    1710:	00002641 	.word	0x00002641
    1714:	00001151 	.word	0x00001151
    1718:	000027c5 	.word	0x000027c5
    171c:	41002000 	.word	0x41002000

00001720 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    1720:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    1722:	7944      	ldrb	r4, [r0, #5]
		return STATUS_ERR_UNSUPPORTED_DEV;
    1724:	2315      	movs	r3, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    1726:	2c01      	cmp	r4, #1
    1728:	d16c      	bne.n	1804 <spi_select_slave+0xe4>
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
#  endif
	{
		if (select) {
    172a:	2a00      	cmp	r2, #0
    172c:	d05a      	beq.n	17e4 <spi_select_slave+0xc4>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    172e:	784b      	ldrb	r3, [r1, #1]
    1730:	2b00      	cmp	r3, #0
    1732:	d046      	beq.n	17c2 <spi_select_slave+0xa2>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1734:	6803      	ldr	r3, [r0, #0]
    1736:	7b9b      	ldrb	r3, [r3, #14]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    1738:	07db      	lsls	r3, r3, #31
    173a:	d410      	bmi.n	175e <spi_select_slave+0x3e>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    173c:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    173e:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1740:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1742:	2900      	cmp	r1, #0
    1744:	d104      	bne.n	1750 <spi_select_slave+0x30>
		return &(ports[port_index]->Group[group_index]);
    1746:	095a      	lsrs	r2, r3, #5
    1748:	01d2      	lsls	r2, r2, #7
    174a:	492f      	ldr	r1, [pc, #188]	; (1808 <spi_select_slave+0xe8>)
    174c:	468c      	mov	ip, r1
    174e:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1750:	211f      	movs	r1, #31
    1752:	400b      	ands	r3, r1
    1754:	391e      	subs	r1, #30
    1756:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1758:	6191      	str	r1, [r2, #24]
					return STATUS_BUSY;
    175a:	2305      	movs	r3, #5
    175c:	e052      	b.n	1804 <spi_select_slave+0xe4>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    175e:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1760:	09dc      	lsrs	r4, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1762:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1764:	2c00      	cmp	r4, #0
    1766:	d104      	bne.n	1772 <spi_select_slave+0x52>
		return &(ports[port_index]->Group[group_index]);
    1768:	095a      	lsrs	r2, r3, #5
    176a:	01d2      	lsls	r2, r2, #7
    176c:	4c26      	ldr	r4, [pc, #152]	; (1808 <spi_select_slave+0xe8>)
    176e:	46a4      	mov	ip, r4
    1770:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1772:	241f      	movs	r4, #31
    1774:	4023      	ands	r3, r4
    1776:	3c1e      	subs	r4, #30
    1778:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    177a:	6154      	str	r4, [r2, #20]

				/* Write address to slave */
				spi_write(module, slave->address);
    177c:	788a      	ldrb	r2, [r1, #2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    177e:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1780:	7b99      	ldrb	r1, [r3, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    1782:	07c9      	lsls	r1, r1, #31
    1784:	d500      	bpl.n	1788 <spi_select_slave+0x68>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    1786:	831a      	strh	r2, [r3, #24]

				if (!(module->receiver_enabled)) {
    1788:	79c2      	ldrb	r2, [r0, #7]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    178a:	2300      	movs	r3, #0
				port_pin_set_output_level(slave->ss_pin, false);

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    178c:	2a00      	cmp	r2, #0
    178e:	d139      	bne.n	1804 <spi_select_slave+0xe4>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1790:	6802      	ldr	r2, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1792:	2104      	movs	r1, #4
    1794:	7b93      	ldrb	r3, [r2, #14]
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    1796:	420b      	tst	r3, r1
    1798:	d0fc      	beq.n	1794 <spi_select_slave+0x74>
    179a:	7b91      	ldrb	r1, [r2, #14]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    179c:	2300      	movs	r3, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    179e:	0749      	lsls	r1, r1, #29
    17a0:	d530      	bpl.n	1804 <spi_select_slave+0xe4>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    17a2:	8a13      	ldrh	r3, [r2, #16]
    17a4:	075b      	lsls	r3, r3, #29
    17a6:	d503      	bpl.n	17b0 <spi_select_slave+0x90>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    17a8:	8a11      	ldrh	r1, [r2, #16]
    17aa:	2304      	movs	r3, #4
    17ac:	430b      	orrs	r3, r1
    17ae:	8213      	strh	r3, [r2, #16]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    17b0:	7983      	ldrb	r3, [r0, #6]
    17b2:	2b01      	cmp	r3, #1
    17b4:	d102      	bne.n	17bc <spi_select_slave+0x9c>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    17b6:	8b13      	ldrh	r3, [r2, #24]
    17b8:	2300      	movs	r3, #0
    17ba:	e023      	b.n	1804 <spi_select_slave+0xe4>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    17bc:	8b13      	ldrh	r3, [r2, #24]
    17be:	2300      	movs	r3, #0
    17c0:	e020      	b.n	1804 <spi_select_slave+0xe4>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    17c2:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    17c4:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    17c6:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    17c8:	2900      	cmp	r1, #0
    17ca:	d104      	bne.n	17d6 <spi_select_slave+0xb6>
		return &(ports[port_index]->Group[group_index]);
    17cc:	095a      	lsrs	r2, r3, #5
    17ce:	01d2      	lsls	r2, r2, #7
    17d0:	490d      	ldr	r1, [pc, #52]	; (1808 <spi_select_slave+0xe8>)
    17d2:	468c      	mov	ip, r1
    17d4:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    17d6:	211f      	movs	r1, #31
    17d8:	400b      	ands	r3, r1
    17da:	391e      	subs	r1, #30
    17dc:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    17de:	6151      	str	r1, [r2, #20]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    17e0:	2300      	movs	r3, #0
    17e2:	e00f      	b.n	1804 <spi_select_slave+0xe4>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    17e4:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    17e6:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    17e8:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    17ea:	2900      	cmp	r1, #0
    17ec:	d104      	bne.n	17f8 <spi_select_slave+0xd8>
		return &(ports[port_index]->Group[group_index]);
    17ee:	095a      	lsrs	r2, r3, #5
    17f0:	01d2      	lsls	r2, r2, #7
    17f2:	4905      	ldr	r1, [pc, #20]	; (1808 <spi_select_slave+0xe8>)
    17f4:	468c      	mov	ip, r1
    17f6:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    17f8:	211f      	movs	r1, #31
    17fa:	400b      	ands	r3, r1
    17fc:	391e      	subs	r1, #30
    17fe:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1800:	6191      	str	r1, [r2, #24]
		}
	}
	return STATUS_OK;
    1802:	2300      	movs	r3, #0
}
    1804:	1c18      	adds	r0, r3, #0
    1806:	bd10      	pop	{r4, pc}
    1808:	41004400 	.word	0x41004400

0000180c <spi_write_buffer_wait>:
 */
enum status_code spi_write_buffer_wait(
		struct spi_module *const module,
		const uint8_t *tx_data,
		uint16_t length)
{
    180c:	b5f0      	push	{r4, r5, r6, r7, lr}
    180e:	465f      	mov	r7, fp
    1810:	4656      	mov	r6, sl
    1812:	464d      	mov	r5, r9
    1814:	4644      	mov	r4, r8
    1816:	b4f0      	push	{r4, r5, r6, r7}
    1818:	b083      	sub	sp, #12
		return STATUS_BUSY;
	}
#  endif

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    181a:	2317      	movs	r3, #23
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
	}
#  endif

	if (length == 0) {
    181c:	2a00      	cmp	r2, #0
    181e:	d100      	bne.n	1822 <spi_write_buffer_wait+0x16>
    1820:	e0ec      	b.n	19fc <spi_write_buffer_wait+0x1f0>
		return STATUS_ERR_INVALID_ARG;
	}

#  if CONF_SPI_SLAVE_ENABLE == true
	if ((module->mode == SPI_MODE_SLAVE) && (spi_is_write_complete(module))) {
    1822:	7943      	ldrb	r3, [r0, #5]
    1824:	2b00      	cmp	r3, #0
    1826:	d105      	bne.n	1834 <spi_write_buffer_wait+0x28>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1828:	6803      	ldr	r3, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    182a:	7b9c      	ldrb	r4, [r3, #14]
    182c:	07a4      	lsls	r4, r4, #30
    182e:	d501      	bpl.n	1834 <spi_write_buffer_wait+0x28>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    1830:	2402      	movs	r4, #2
    1832:	739c      	strb	r4, [r3, #14]
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
					if (spi_is_ready_to_write(module)) {
						data_to_send = tx_data[tx_pos++];
    1834:	4693      	mov	fp, r2
    1836:	2400      	movs	r4, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1838:	2301      	movs	r3, #1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    183a:	2502      	movs	r5, #2
    183c:	46ac      	mov	ip, r5
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    183e:	3502      	adds	r5, #2
    1840:	46a9      	mov	r9, r5
    1842:	e08e      	b.n	1962 <spi_write_buffer_wait+0x156>

	/* Write block */
	while (length--) {
#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
    1844:	7945      	ldrb	r5, [r0, #5]
    1846:	2d00      	cmp	r5, #0
    1848:	d117      	bne.n	187a <spi_write_buffer_wait+0x6e>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    184a:	6807      	ldr	r7, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    184c:	7bbd      	ldrb	r5, [r7, #14]
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
				if (spi_is_ready_to_write(module)) {
    184e:	421d      	tst	r5, r3
    1850:	d106      	bne.n	1860 <spi_write_buffer_wait+0x54>
    1852:	4d6e      	ldr	r5, [pc, #440]	; (1a0c <spi_write_buffer_wait+0x200>)
    1854:	7bbe      	ldrb	r6, [r7, #14]
    1856:	421e      	tst	r6, r3
    1858:	d102      	bne.n	1860 <spi_write_buffer_wait+0x54>
    185a:	3d01      	subs	r5, #1
	/* Write block */
	while (length--) {
#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    185c:	2d00      	cmp	r5, #0
    185e:	d1f9      	bne.n	1854 <spi_write_buffer_wait+0x48>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1860:	6806      	ldr	r6, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1862:	7bb5      	ldrb	r5, [r6, #14]
				if (spi_is_ready_to_write(module)) {
					break;
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
    1864:	4667      	mov	r7, ip
    1866:	423d      	tst	r5, r7
    1868:	d003      	beq.n	1872 <spi_write_buffer_wait+0x66>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    186a:	2302      	movs	r3, #2
    186c:	73b3      	strb	r3, [r6, #14]
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
				_spi_clear_tx_complete_flag(module);
				return STATUS_ABORTED;
    186e:	3302      	adds	r3, #2
    1870:	e0c4      	b.n	19fc <spi_write_buffer_wait+0x1f0>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1872:	7bb5      	ldrb	r5, [r6, #14]
			}

			if (!spi_is_ready_to_write(module)) {
    1874:	421d      	tst	r5, r3
    1876:	d100      	bne.n	187a <spi_write_buffer_wait+0x6e>
    1878:	e0b7      	b.n	19ea <spi_write_buffer_wait+0x1de>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    187a:	6806      	ldr	r6, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    187c:	7bb5      	ldrb	r5, [r6, #14]
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    187e:	421d      	tst	r5, r3
    1880:	d0fc      	beq.n	187c <spi_write_buffer_wait+0x70>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    1882:	1c65      	adds	r5, r4, #1
    1884:	b2ad      	uxth	r5, r5
    1886:	46a8      	mov	r8, r5
    1888:	5d0d      	ldrb	r5, [r1, r4]

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    188a:	7987      	ldrb	r7, [r0, #6]
    188c:	2f01      	cmp	r7, #1
    188e:	d002      	beq.n	1896 <spi_write_buffer_wait+0x8a>
		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    1890:	b2ad      	uxth	r5, r5
    1892:	4644      	mov	r4, r8
    1894:	e005      	b.n	18a2 <spi_write_buffer_wait+0x96>

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			data_to_send |= (tx_data[tx_pos++] << 8);
    1896:	3402      	adds	r4, #2
    1898:	b2a4      	uxth	r4, r4
    189a:	4647      	mov	r7, r8
    189c:	5dcf      	ldrb	r7, [r1, r7]
    189e:	023f      	lsls	r7, r7, #8
    18a0:	433d      	orrs	r5, r7
    18a2:	7bb7      	ldrb	r7, [r6, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    18a4:	421f      	tst	r7, r3
    18a6:	d002      	beq.n	18ae <spi_write_buffer_wait+0xa2>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    18a8:	05ed      	lsls	r5, r5, #23
    18aa:	0ded      	lsrs	r5, r5, #23
    18ac:	8335      	strh	r5, [r6, #24]
    18ae:	1e55      	subs	r5, r2, #1
    18b0:	b2ad      	uxth	r5, r5
		}

		/* Write the data to send */
		spi_write(module, data_to_send);

		if (module->receiver_enabled) {
    18b2:	79c6      	ldrb	r6, [r0, #7]
    18b4:	2e00      	cmp	r6, #0
    18b6:	d057      	beq.n	1968 <spi_write_buffer_wait+0x15c>
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
    18b8:	7945      	ldrb	r5, [r0, #5]
    18ba:	2d00      	cmp	r5, #0
    18bc:	d137      	bne.n	192e <spi_write_buffer_wait+0x122>
    18be:	4f54      	ldr	r7, [pc, #336]	; (1a10 <spi_write_buffer_wait+0x204>)
    18c0:	9101      	str	r1, [sp, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    18c2:	6805      	ldr	r5, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    18c4:	7bae      	ldrb	r6, [r5, #14]
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
					if (spi_is_ready_to_write(module)) {
    18c6:	421e      	tst	r6, r3
    18c8:	d01c      	beq.n	1904 <spi_write_buffer_wait+0xf8>
						data_to_send = tx_data[tx_pos++];
    18ca:	1c66      	adds	r6, r4, #1
    18cc:	b2b1      	uxth	r1, r6
    18ce:	4688      	mov	r8, r1
    18d0:	9901      	ldr	r1, [sp, #4]
    18d2:	5d09      	ldrb	r1, [r1, r4]
    18d4:	9100      	str	r1, [sp, #0]
						/* If 9-bit data, get next byte to send from the buffer */
						if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    18d6:	7981      	ldrb	r1, [r0, #6]
    18d8:	2901      	cmp	r1, #1
    18da:	d003      	beq.n	18e4 <spi_write_buffer_wait+0xd8>
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
					if (spi_is_ready_to_write(module)) {
						data_to_send = tx_data[tx_pos++];
    18dc:	4669      	mov	r1, sp
    18de:	880e      	ldrh	r6, [r1, #0]
    18e0:	4644      	mov	r4, r8
    18e2:	e007      	b.n	18f4 <spi_write_buffer_wait+0xe8>
						/* If 9-bit data, get next byte to send from the buffer */
						if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
							data_to_send |= (tx_data[tx_pos++] << 8);
    18e4:	3402      	adds	r4, #2
    18e6:	b2a4      	uxth	r4, r4
    18e8:	4641      	mov	r1, r8
    18ea:	9e01      	ldr	r6, [sp, #4]
    18ec:	5c71      	ldrb	r1, [r6, r1]
    18ee:	0209      	lsls	r1, r1, #8
    18f0:	9e00      	ldr	r6, [sp, #0]
    18f2:	430e      	orrs	r6, r1
    18f4:	7ba9      	ldrb	r1, [r5, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    18f6:	4219      	tst	r1, r3
    18f8:	d002      	beq.n	1900 <spi_write_buffer_wait+0xf4>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    18fa:	05f6      	lsls	r6, r6, #23
    18fc:	0df6      	lsrs	r6, r6, #23
    18fe:	832e      	strh	r6, [r5, #24]
						}

						/* Write the data to send */
						spi_write(module, data_to_send);
						length--;
    1900:	3a01      	subs	r2, #1
    1902:	b292      	uxth	r2, r2
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1904:	6806      	ldr	r6, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1906:	7bb5      	ldrb	r5, [r6, #14]
					}
					if (spi_is_ready_to_read(module)) {
    1908:	4649      	mov	r1, r9
    190a:	420d      	tst	r5, r1
    190c:	d102      	bne.n	1914 <spi_write_buffer_wait+0x108>
    190e:	3f01      	subs	r7, #1

		if (module->receiver_enabled) {
#  if CONF_SPI_SLAVE_ENABLE == true
			/* Start timeout period for slave */
			if (module->mode == SPI_MODE_SLAVE) {
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    1910:	2f00      	cmp	r7, #0
    1912:	d1d6      	bne.n	18c2 <spi_write_buffer_wait+0xb6>
    1914:	9901      	ldr	r1, [sp, #4]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1916:	7bb5      	ldrb	r5, [r6, #14]
						break;
					}
				}

				/* Check if master has ended the transaction */
				if (spi_is_write_complete(module)) {
    1918:	4667      	mov	r7, ip
    191a:	423d      	tst	r5, r7
    191c:	d003      	beq.n	1926 <spi_write_buffer_wait+0x11a>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    191e:	2302      	movs	r3, #2
    1920:	73b3      	strb	r3, [r6, #14]
				}

				/* Check if master has ended the transaction */
				if (spi_is_write_complete(module)) {
					_spi_clear_tx_complete_flag(module);
					return STATUS_ABORTED;
    1922:	3302      	adds	r3, #2
    1924:	e06a      	b.n	19fc <spi_write_buffer_wait+0x1f0>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1926:	7bb5      	ldrb	r5, [r6, #14]
				}

				if (!spi_is_ready_to_read(module)) {
    1928:	464e      	mov	r6, r9
    192a:	4235      	tst	r5, r6
    192c:	d05f      	beq.n	19ee <spi_write_buffer_wait+0x1e2>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    192e:	6806      	ldr	r6, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1930:	7bb5      	ldrb	r5, [r6, #14]
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
    1932:	464f      	mov	r7, r9
    1934:	423d      	tst	r5, r7
    1936:	d0fb      	beq.n	1930 <spi_write_buffer_wait+0x124>
    1938:	7bb5      	ldrb	r5, [r6, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    193a:	423d      	tst	r5, r7
    193c:	d00d      	beq.n	195a <spi_write_buffer_wait+0x14e>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    193e:	8a35      	ldrh	r5, [r6, #16]
    1940:	423d      	tst	r5, r7
    1942:	d004      	beq.n	194e <spi_write_buffer_wait+0x142>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    1944:	8a35      	ldrh	r5, [r6, #16]
    1946:	2704      	movs	r7, #4
    1948:	433d      	orrs	r5, r7
    194a:	b2ad      	uxth	r5, r5
    194c:	8235      	strh	r5, [r6, #16]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    194e:	7985      	ldrb	r5, [r0, #6]
    1950:	2d01      	cmp	r5, #1
    1952:	d101      	bne.n	1958 <spi_write_buffer_wait+0x14c>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    1954:	8b35      	ldrh	r5, [r6, #24]
    1956:	e000      	b.n	195a <spi_write_buffer_wait+0x14e>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    1958:	8b35      	ldrh	r5, [r6, #24]
			}

			/* Flush read buffer */
			uint16_t flush;
			spi_read(module, &flush);
			flush_length--;
    195a:	465d      	mov	r5, fp
    195c:	3d01      	subs	r5, #1
    195e:	b2ad      	uxth	r5, r5
    1960:	46ab      	mov	fp, r5
    1962:	3a01      	subs	r2, #1
    1964:	b292      	uxth	r2, r2
    1966:	e000      	b.n	196a <spi_write_buffer_wait+0x15e>
		}

		/* Write the data to send */
		spi_write(module, data_to_send);

		if (module->receiver_enabled) {
    1968:	1c2a      	adds	r2, r5, #0

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    196a:	4d2a      	ldr	r5, [pc, #168]	; (1a14 <spi_write_buffer_wait+0x208>)
    196c:	42aa      	cmp	r2, r5
    196e:	d000      	beq.n	1972 <spi_write_buffer_wait+0x166>
    1970:	e768      	b.n	1844 <spi_write_buffer_wait+0x38>
    1972:	465a      	mov	r2, fp
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    1974:	7943      	ldrb	r3, [r0, #5]
    1976:	2b01      	cmp	r3, #1
    1978:	d106      	bne.n	1988 <spi_write_buffer_wait+0x17c>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    197a:	6801      	ldr	r1, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    197c:	2202      	movs	r2, #2
    197e:	7b8b      	ldrb	r3, [r1, #14]
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    1980:	4213      	tst	r3, r2
    1982:	d0fc      	beq.n	197e <spi_write_buffer_wait+0x172>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    1984:	2300      	movs	r3, #0
    1986:	e039      	b.n	19fc <spi_write_buffer_wait+0x1f0>
		}
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
    1988:	2b00      	cmp	r3, #0
    198a:	d132      	bne.n	19f2 <spi_write_buffer_wait+0x1e6>
		if (module->receiver_enabled) {
    198c:	79c1      	ldrb	r1, [r0, #7]
    198e:	2900      	cmp	r1, #0
    1990:	d034      	beq.n	19fc <spi_write_buffer_wait+0x1f0>
			while (flush_length) {
    1992:	2a00      	cmp	r2, #0
    1994:	d11f      	bne.n	19d6 <spi_write_buffer_wait+0x1ca>
    1996:	e031      	b.n	19fc <spi_write_buffer_wait+0x1f0>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1998:	7ba2      	ldrb	r2, [r4, #14]
				/* Start timeout period for slave */
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
					if (spi_is_ready_to_read(module)) {
    199a:	420a      	tst	r2, r1
    199c:	d102      	bne.n	19a4 <spi_write_buffer_wait+0x198>
    199e:	3b01      	subs	r3, #1
#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
		if (module->receiver_enabled) {
			while (flush_length) {
				/* Start timeout period for slave */
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    19a0:	2b00      	cmp	r3, #0
    19a2:	d1f9      	bne.n	1998 <spi_write_buffer_wait+0x18c>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    19a4:	6803      	ldr	r3, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    19a6:	7b9a      	ldrb	r2, [r3, #14]
					if (spi_is_ready_to_read(module)) {
						break;
					}
				}
				if (!spi_is_ready_to_read(module)) {
    19a8:	420a      	tst	r2, r1
    19aa:	d024      	beq.n	19f6 <spi_write_buffer_wait+0x1ea>
    19ac:	7b9a      	ldrb	r2, [r3, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    19ae:	420a      	tst	r2, r1
    19b0:	d00c      	beq.n	19cc <spi_write_buffer_wait+0x1c0>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    19b2:	8a1a      	ldrh	r2, [r3, #16]
    19b4:	420a      	tst	r2, r1
    19b6:	d003      	beq.n	19c0 <spi_write_buffer_wait+0x1b4>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    19b8:	8a1a      	ldrh	r2, [r3, #16]
    19ba:	4332      	orrs	r2, r6
    19bc:	b292      	uxth	r2, r2
    19be:	821a      	strh	r2, [r3, #16]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    19c0:	7982      	ldrb	r2, [r0, #6]
    19c2:	2a01      	cmp	r2, #1
    19c4:	d101      	bne.n	19ca <spi_write_buffer_wait+0x1be>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    19c6:	8b1b      	ldrh	r3, [r3, #24]
    19c8:	e000      	b.n	19cc <spi_write_buffer_wait+0x1c0>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    19ca:	8b1b      	ldrh	r3, [r3, #24]
					return STATUS_ERR_TIMEOUT;
				}
				/* Flush read buffer */
				uint16_t flush;
				spi_read(module, &flush);
				flush_length--;
    19cc:	3f01      	subs	r7, #1
    19ce:	b2bf      	uxth	r7, r7
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
		if (module->receiver_enabled) {
			while (flush_length) {
    19d0:	2f00      	cmp	r7, #0
    19d2:	d104      	bne.n	19de <spi_write_buffer_wait+0x1d2>
    19d4:	e011      	b.n	19fa <spi_write_buffer_wait+0x1ee>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    19d6:	2104      	movs	r1, #4
				/* Start timeout period for slave */
				for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
					if (spi_is_ready_to_read(module)) {
    19d8:	4d0c      	ldr	r5, [pc, #48]	; (1a0c <spi_write_buffer_wait+0x200>)

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    19da:	2604      	movs	r6, #4
    19dc:	465f      	mov	r7, fp
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    19de:	6804      	ldr	r4, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    19e0:	7ba3      	ldrb	r3, [r4, #14]
    19e2:	420b      	tst	r3, r1
    19e4:	d1de      	bne.n	19a4 <spi_write_buffer_wait+0x198>
    19e6:	1c2b      	adds	r3, r5, #0
    19e8:	e7d6      	b.n	1998 <spi_write_buffer_wait+0x18c>
				return STATUS_ABORTED;
			}

			if (!spi_is_ready_to_write(module)) {
				/* Not ready to write data within timeout period */
				return STATUS_ERR_TIMEOUT;
    19ea:	2312      	movs	r3, #18
    19ec:	e006      	b.n	19fc <spi_write_buffer_wait+0x1f0>
					return STATUS_ABORTED;
				}

				if (!spi_is_ready_to_read(module)) {
					/* Not ready to read data within timeout period */
					return STATUS_ERR_TIMEOUT;
    19ee:	2312      	movs	r3, #18
    19f0:	e004      	b.n	19fc <spi_write_buffer_wait+0x1f0>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    19f2:	2300      	movs	r3, #0
    19f4:	e002      	b.n	19fc <spi_write_buffer_wait+0x1f0>
						break;
					}
				}
				if (!spi_is_ready_to_read(module)) {
					/* Not ready to read data within timeout period */
					return STATUS_ERR_TIMEOUT;
    19f6:	2312      	movs	r3, #18
    19f8:	e000      	b.n	19fc <spi_write_buffer_wait+0x1f0>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    19fa:	2300      	movs	r3, #0
}
    19fc:	1c18      	adds	r0, r3, #0
    19fe:	b003      	add	sp, #12
    1a00:	bc3c      	pop	{r2, r3, r4, r5}
    1a02:	4690      	mov	r8, r2
    1a04:	4699      	mov	r9, r3
    1a06:	46a2      	mov	sl, r4
    1a08:	46ab      	mov	fp, r5
    1a0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a0c:	00002710 	.word	0x00002710
    1a10:	00002711 	.word	0x00002711
    1a14:	0000ffff 	.word	0x0000ffff

00001a18 <spi_transceive_buffer_wait>:
enum status_code spi_transceive_buffer_wait(
		struct spi_module *const module,
		uint8_t *tx_data,
		uint8_t *rx_data,
		uint16_t length)
{
    1a18:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a1a:	465f      	mov	r7, fp
    1a1c:	4656      	mov	r6, sl
    1a1e:	464d      	mov	r5, r9
    1a20:	4644      	mov	r4, r8
    1a22:	b4f0      	push	{r4, r5, r6, r7}
    1a24:	b085      	sub	sp, #20
    1a26:	4689      	mov	r9, r1
    1a28:	9203      	str	r2, [sp, #12]
    1a2a:	469a      	mov	sl, r3
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    1a2c:	2617      	movs	r6, #23
		return STATUS_BUSY;
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
    1a2e:	2b00      	cmp	r3, #0
    1a30:	d100      	bne.n	1a34 <spi_transceive_buffer_wait+0x1c>
    1a32:	e138      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
		return STATUS_ERR_INVALID_ARG;
	}

	if (!(module->receiver_enabled)) {
    1a34:	79c3      	ldrb	r3, [r0, #7]
		return STATUS_ERR_DENIED;
    1a36:	3605      	adds	r6, #5
	/* Sanity check arguments */
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
	}

	if (!(module->receiver_enabled)) {
    1a38:	2b00      	cmp	r3, #0
    1a3a:	d100      	bne.n	1a3e <spi_transceive_buffer_wait+0x26>
    1a3c:	e133      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
		return STATUS_ERR_DENIED;
	}

#  if CONF_SPI_SLAVE_ENABLE == true
	if ((module->mode == SPI_MODE_SLAVE) && (spi_is_write_complete(module))) {
    1a3e:	7943      	ldrb	r3, [r0, #5]
    1a40:	2b00      	cmp	r3, #0
    1a42:	d105      	bne.n	1a50 <spi_transceive_buffer_wait+0x38>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1a44:	6803      	ldr	r3, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1a46:	7b9a      	ldrb	r2, [r3, #14]
    1a48:	0792      	lsls	r2, r2, #30
    1a4a:	d501      	bpl.n	1a50 <spi_transceive_buffer_wait+0x38>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    1a4c:	2202      	movs	r2, #2
    1a4e:	739a      	strb	r2, [r3, #14]
	uint16_t tx_pos = 0;
	uint16_t rx_pos = 0;
	uint16_t rx_length = length;

	/* Send and receive buffer */
	while (length--) {
    1a50:	4653      	mov	r3, sl
    1a52:	1e5f      	subs	r7, r3, #1
    1a54:	b2bf      	uxth	r7, r7
    1a56:	2300      	movs	r3, #0
    1a58:	469b      	mov	fp, r3
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1a5a:	2201      	movs	r2, #1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1a5c:	2104      	movs	r1, #4
#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
    1a5e:	7944      	ldrb	r4, [r0, #5]
    1a60:	2c00      	cmp	r4, #0
    1a62:	d117      	bne.n	1a94 <spi_transceive_buffer_wait+0x7c>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1a64:	6806      	ldr	r6, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1a66:	7bb4      	ldrb	r4, [r6, #14]
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
				if (spi_is_ready_to_write(module)) {
    1a68:	4214      	tst	r4, r2
    1a6a:	d106      	bne.n	1a7a <spi_transceive_buffer_wait+0x62>
    1a6c:	4c92      	ldr	r4, [pc, #584]	; (1cb8 <spi_transceive_buffer_wait+0x2a0>)
    1a6e:	7bb5      	ldrb	r5, [r6, #14]
    1a70:	4215      	tst	r5, r2
    1a72:	d102      	bne.n	1a7a <spi_transceive_buffer_wait+0x62>
    1a74:	3c01      	subs	r4, #1
	/* Send and receive buffer */
	while (length--) {
#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    1a76:	2c00      	cmp	r4, #0
    1a78:	d1f9      	bne.n	1a6e <spi_transceive_buffer_wait+0x56>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1a7a:	6804      	ldr	r4, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1a7c:	7ba5      	ldrb	r5, [r4, #14]
				if (spi_is_ready_to_write(module)) {
					break;
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
    1a7e:	2602      	movs	r6, #2
    1a80:	4235      	tst	r5, r6
    1a82:	d003      	beq.n	1a8c <spi_transceive_buffer_wait+0x74>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    1a84:	2302      	movs	r3, #2
    1a86:	73a3      	strb	r3, [r4, #14]
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
				_spi_clear_tx_complete_flag(module);
				return STATUS_ABORTED;
    1a88:	3602      	adds	r6, #2
    1a8a:	e10c      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1a8c:	7ba4      	ldrb	r4, [r4, #14]
			}

			if (!spi_is_ready_to_write(module)) {
    1a8e:	4214      	tst	r4, r2
    1a90:	d100      	bne.n	1a94 <spi_transceive_buffer_wait+0x7c>
    1a92:	e0f8      	b.n	1c86 <spi_transceive_buffer_wait+0x26e>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1a94:	6805      	ldr	r5, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1a96:	7bac      	ldrb	r4, [r5, #14]
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    1a98:	4214      	tst	r4, r2
    1a9a:	d0fc      	beq.n	1a96 <spi_transceive_buffer_wait+0x7e>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    1a9c:	1c5e      	adds	r6, r3, #1
    1a9e:	b2b6      	uxth	r6, r6
    1aa0:	464c      	mov	r4, r9
    1aa2:	5ce4      	ldrb	r4, [r4, r3]
    1aa4:	46a0      	mov	r8, r4

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1aa6:	7984      	ldrb	r4, [r0, #6]
    1aa8:	2c01      	cmp	r4, #1
    1aaa:	d005      	beq.n	1ab8 <spi_transceive_buffer_wait+0xa0>
		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    1aac:	4643      	mov	r3, r8
    1aae:	466c      	mov	r4, sp
    1ab0:	80a3      	strh	r3, [r4, #4]
    1ab2:	88a4      	ldrh	r4, [r4, #4]
    1ab4:	1c33      	adds	r3, r6, #0
    1ab6:	e006      	b.n	1ac6 <spi_transceive_buffer_wait+0xae>

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			data_to_send |= (tx_data[tx_pos++] << 8);
    1ab8:	3302      	adds	r3, #2
    1aba:	b29b      	uxth	r3, r3
    1abc:	464c      	mov	r4, r9
    1abe:	5da6      	ldrb	r6, [r4, r6]
    1ac0:	0236      	lsls	r6, r6, #8
    1ac2:	4644      	mov	r4, r8
    1ac4:	4334      	orrs	r4, r6
    1ac6:	7bae      	ldrb	r6, [r5, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    1ac8:	4216      	tst	r6, r2
    1aca:	d100      	bne.n	1ace <spi_transceive_buffer_wait+0xb6>
    1acc:	e0e5      	b.n	1c9a <spi_transceive_buffer_wait+0x282>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    1ace:	05e4      	lsls	r4, r4, #23
    1ad0:	0de4      	lsrs	r4, r4, #23
    1ad2:	832c      	strh	r4, [r5, #24]
    1ad4:	e0e1      	b.n	1c9a <spi_transceive_buffer_wait+0x282>
		/* Write the data to send */
		spi_write(module, data_to_send);

#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
    1ad6:	4d79      	ldr	r5, [pc, #484]	; (1cbc <spi_transceive_buffer_wait+0x2a4>)
    1ad8:	9701      	str	r7, [sp, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1ada:	6804      	ldr	r4, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1adc:	7ba6      	ldrb	r6, [r4, #14]
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
				if (spi_is_ready_to_write(module)) {
    1ade:	4216      	tst	r6, r2
    1ae0:	d01e      	beq.n	1b20 <spi_transceive_buffer_wait+0x108>
					data_to_send = tx_data[tx_pos++];
    1ae2:	1c5e      	adds	r6, r3, #1
    1ae4:	b2b6      	uxth	r6, r6
    1ae6:	46b4      	mov	ip, r6
    1ae8:	464e      	mov	r6, r9
    1aea:	5cf6      	ldrb	r6, [r6, r3]
    1aec:	9602      	str	r6, [sp, #8]
					/* If 9-bit data, get next byte to send from the buffer */
					if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1aee:	7987      	ldrb	r7, [r0, #6]
    1af0:	2f01      	cmp	r7, #1
    1af2:	d002      	beq.n	1afa <spi_transceive_buffer_wait+0xe2>
#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
				if (spi_is_ready_to_write(module)) {
					data_to_send = tx_data[tx_pos++];
    1af4:	b2b6      	uxth	r6, r6
    1af6:	4663      	mov	r3, ip
    1af8:	e008      	b.n	1b0c <spi_transceive_buffer_wait+0xf4>
					/* If 9-bit data, get next byte to send from the buffer */
					if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
						data_to_send |= (tx_data[tx_pos++] << 8);
    1afa:	3302      	adds	r3, #2
    1afc:	b29b      	uxth	r3, r3
    1afe:	464f      	mov	r7, r9
    1b00:	4666      	mov	r6, ip
    1b02:	5dbe      	ldrb	r6, [r7, r6]
    1b04:	0236      	lsls	r6, r6, #8
    1b06:	9f02      	ldr	r7, [sp, #8]
    1b08:	4337      	orrs	r7, r6
    1b0a:	1c3e      	adds	r6, r7, #0
    1b0c:	7ba7      	ldrb	r7, [r4, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    1b0e:	4217      	tst	r7, r2
    1b10:	d002      	beq.n	1b18 <spi_transceive_buffer_wait+0x100>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    1b12:	05f6      	lsls	r6, r6, #23
    1b14:	0df6      	lsrs	r6, r6, #23
    1b16:	8326      	strh	r6, [r4, #24]
					}

					/* Write the data to send */
					spi_write(module, data_to_send);
					length--;
    1b18:	9f01      	ldr	r7, [sp, #4]
    1b1a:	3f01      	subs	r7, #1
    1b1c:	b2bc      	uxth	r4, r7
    1b1e:	9401      	str	r4, [sp, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1b20:	6804      	ldr	r4, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1b22:	7ba6      	ldrb	r6, [r4, #14]
				}
				if (spi_is_ready_to_read(module)) {
    1b24:	420e      	tst	r6, r1
    1b26:	d102      	bne.n	1b2e <spi_transceive_buffer_wait+0x116>
    1b28:	3d01      	subs	r5, #1
		spi_write(module, data_to_send);

#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    1b2a:	2d00      	cmp	r5, #0
    1b2c:	d1d5      	bne.n	1ada <spi_transceive_buffer_wait+0xc2>
    1b2e:	9f01      	ldr	r7, [sp, #4]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1b30:	7ba5      	ldrb	r5, [r4, #14]
				if (spi_is_ready_to_read(module)) {
					break;
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
    1b32:	2602      	movs	r6, #2
    1b34:	4235      	tst	r5, r6
    1b36:	d003      	beq.n	1b40 <spi_transceive_buffer_wait+0x128>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    1b38:	2302      	movs	r3, #2
    1b3a:	73a3      	strb	r3, [r4, #14]
				}
			}
			/* Check if master has ended the transaction */
			if (spi_is_write_complete(module)) {
				_spi_clear_tx_complete_flag(module);
				return STATUS_ABORTED;
    1b3c:	3602      	adds	r6, #2
    1b3e:	e0b2      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1b40:	7ba4      	ldrb	r4, [r4, #14]
			}

			if (!spi_is_ready_to_read(module)) {
    1b42:	420c      	tst	r4, r1
    1b44:	d100      	bne.n	1b48 <spi_transceive_buffer_wait+0x130>
    1b46:	e0a0      	b.n	1c8a <spi_transceive_buffer_wait+0x272>
    1b48:	1c3e      	adds	r6, r7, #0
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1b4a:	6805      	ldr	r5, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1b4c:	7bac      	ldrb	r4, [r5, #14]
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
    1b4e:	420c      	tst	r4, r1
    1b50:	d0fc      	beq.n	1b4c <spi_transceive_buffer_wait+0x134>
		}

		enum status_code retval;
		uint16_t received_data = 0;
		rx_length--;
    1b52:	4654      	mov	r4, sl
    1b54:	3c01      	subs	r4, #1
    1b56:	b2a4      	uxth	r4, r4
    1b58:	46a2      	mov	sl, r4
    1b5a:	7bac      	ldrb	r4, [r5, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    1b5c:	420c      	tst	r4, r1
    1b5e:	d017      	beq.n	1b90 <spi_transceive_buffer_wait+0x178>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    1b60:	8a2f      	ldrh	r7, [r5, #16]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    1b62:	2400      	movs	r4, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    1b64:	420f      	tst	r7, r1
    1b66:	d005      	beq.n	1b74 <spi_transceive_buffer_wait+0x15c>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    1b68:	8a2c      	ldrh	r4, [r5, #16]
    1b6a:	2704      	movs	r7, #4
    1b6c:	433c      	orrs	r4, r7
    1b6e:	b2a4      	uxth	r4, r4
    1b70:	822c      	strh	r4, [r5, #16]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
    1b72:	241e      	movs	r4, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1b74:	7987      	ldrb	r7, [r0, #6]
    1b76:	2f01      	cmp	r7, #1
    1b78:	d103      	bne.n	1b82 <spi_transceive_buffer_wait+0x16a>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    1b7a:	8b2d      	ldrh	r5, [r5, #24]
    1b7c:	05ed      	lsls	r5, r5, #23
    1b7e:	0ded      	lsrs	r5, r5, #23
    1b80:	e002      	b.n	1b88 <spi_transceive_buffer_wait+0x170>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    1b82:	8b2f      	ldrh	r7, [r5, #24]
    1b84:	25ff      	movs	r5, #255	; 0xff
    1b86:	403d      	ands	r5, r7

		retval = spi_read(module, &received_data);

		if (retval != STATUS_OK) {
    1b88:	2c00      	cmp	r4, #0
    1b8a:	d003      	beq.n	1b94 <spi_transceive_buffer_wait+0x17c>
    1b8c:	1c26      	adds	r6, r4, #0
    1b8e:	e08a      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
		/* No data has been received, return */
		return STATUS_ERR_IO;
    1b90:	2610      	movs	r6, #16
			/* Overflow, abort */
			return retval;
    1b92:	e088      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    1b94:	465c      	mov	r4, fp
    1b96:	3401      	adds	r4, #1
    1b98:	b2a4      	uxth	r4, r4
    1b9a:	46a4      	mov	ip, r4
    1b9c:	9f03      	ldr	r7, [sp, #12]
    1b9e:	465c      	mov	r4, fp
    1ba0:	553d      	strb	r5, [r7, r4]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1ba2:	7987      	ldrb	r7, [r0, #6]
    1ba4:	2f01      	cmp	r7, #1
    1ba6:	d108      	bne.n	1bba <spi_transceive_buffer_wait+0x1a2>
			rx_data[rx_pos++] = (received_data >> 8);
    1ba8:	465f      	mov	r7, fp
    1baa:	3702      	adds	r7, #2
    1bac:	b2bc      	uxth	r4, r7
    1bae:	46a3      	mov	fp, r4
    1bb0:	0a2d      	lsrs	r5, r5, #8
    1bb2:	9c03      	ldr	r4, [sp, #12]
    1bb4:	4667      	mov	r7, ip
    1bb6:	55e5      	strb	r5, [r4, r7]
    1bb8:	e000      	b.n	1bbc <spi_transceive_buffer_wait+0x1a4>
			/* Overflow, abort */
			return retval;
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    1bba:	46e3      	mov	fp, ip
	uint16_t tx_pos = 0;
	uint16_t rx_pos = 0;
	uint16_t rx_length = length;

	/* Send and receive buffer */
	while (length--) {
    1bbc:	1e77      	subs	r7, r6, #1
    1bbe:	b2bf      	uxth	r7, r7
    1bc0:	2e00      	cmp	r6, #0
    1bc2:	d000      	beq.n	1bc6 <spi_transceive_buffer_wait+0x1ae>
    1bc4:	e74b      	b.n	1a5e <spi_transceive_buffer_wait+0x46>
		while (!spi_is_ready_to_read(module)) {
		}

		enum status_code retval;
		uint16_t received_data = 0;
		rx_length--;
    1bc6:	4652      	mov	r2, sl
			rx_data[rx_pos++] = (received_data >> 8);
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    1bc8:	7943      	ldrb	r3, [r0, #5]
    1bca:	2b01      	cmp	r3, #1
    1bcc:	d106      	bne.n	1bdc <spi_transceive_buffer_wait+0x1c4>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1bce:	6801      	ldr	r1, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    1bd0:	2202      	movs	r2, #2
    1bd2:	7b8b      	ldrb	r3, [r1, #14]
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    1bd4:	4213      	tst	r3, r2
    1bd6:	d0fc      	beq.n	1bd2 <spi_transceive_buffer_wait+0x1ba>
				rx_data[rx_pos++] = (received_data >> 8);
			}
		}
	}
#  endif
	return STATUS_OK;
    1bd8:	2600      	movs	r6, #0
    1bda:	e064      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
		}
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
    1bdc:	2b00      	cmp	r3, #0
    1bde:	d156      	bne.n	1c8e <spi_transceive_buffer_wait+0x276>
				rx_data[rx_pos++] = (received_data >> 8);
			}
		}
	}
#  endif
	return STATUS_OK;
    1be0:	2600      	movs	r6, #0
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
		while (rx_length) {
    1be2:	2a00      	cmp	r2, #0
    1be4:	d05f      	beq.n	1ca6 <spi_transceive_buffer_wait+0x28e>
    1be6:	e03e      	b.n	1c66 <spi_transceive_buffer_wait+0x24e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1be8:	7bb5      	ldrb	r5, [r6, #14]
			/* Start timeout period for slave */
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
				if (spi_is_ready_to_read(module)) {
    1bea:	423d      	tst	r5, r7
    1bec:	d102      	bne.n	1bf4 <spi_transceive_buffer_wait+0x1dc>
    1bee:	3b01      	subs	r3, #1

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
		while (rx_length) {
			/* Start timeout period for slave */
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
    1bf0:	2b00      	cmp	r3, #0
    1bf2:	d1f9      	bne.n	1be8 <spi_transceive_buffer_wait+0x1d0>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1bf4:	4663      	mov	r3, ip
    1bf6:	681b      	ldr	r3, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1bf8:	7b9d      	ldrb	r5, [r3, #14]
				if (spi_is_ready_to_read(module)) {
					break;
				}
			}
			if (!spi_is_ready_to_read(module)) {
    1bfa:	423d      	tst	r5, r7
    1bfc:	d049      	beq.n	1c92 <spi_transceive_buffer_wait+0x27a>
				/* Not ready to read data within timeout period */
				return STATUS_ERR_TIMEOUT;
			}
			enum status_code retval;
			uint16_t received_data = 0;
			rx_length--;
    1bfe:	3801      	subs	r0, #1
    1c00:	b280      	uxth	r0, r0
    1c02:	7b9d      	ldrb	r5, [r3, #14]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    1c04:	423d      	tst	r5, r7
    1c06:	d016      	beq.n	1c36 <spi_transceive_buffer_wait+0x21e>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    1c08:	8a1d      	ldrh	r5, [r3, #16]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    1c0a:	2600      	movs	r6, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    1c0c:	423d      	tst	r5, r7
    1c0e:	d005      	beq.n	1c1c <spi_transceive_buffer_wait+0x204>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    1c10:	8a1d      	ldrh	r5, [r3, #16]
    1c12:	4649      	mov	r1, r9
    1c14:	430d      	orrs	r5, r1
    1c16:	b2ad      	uxth	r5, r5
    1c18:	821d      	strh	r5, [r3, #16]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
    1c1a:	361e      	adds	r6, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1c1c:	4661      	mov	r1, ip
    1c1e:	798d      	ldrb	r5, [r1, #6]
    1c20:	2d01      	cmp	r5, #1
    1c22:	d103      	bne.n	1c2c <spi_transceive_buffer_wait+0x214>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    1c24:	8b1d      	ldrh	r5, [r3, #24]
    1c26:	05ed      	lsls	r5, r5, #23
    1c28:	0ded      	lsrs	r5, r5, #23
    1c2a:	e001      	b.n	1c30 <spi_transceive_buffer_wait+0x218>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    1c2c:	8b1d      	ldrh	r5, [r3, #24]
    1c2e:	4025      	ands	r5, r4

			retval = spi_read(module, &received_data);

			if (retval != STATUS_OK) {
    1c30:	2e00      	cmp	r6, #0
    1c32:	d002      	beq.n	1c3a <spi_transceive_buffer_wait+0x222>
    1c34:	e037      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
		/* No data has been received, return */
		return STATUS_ERR_IO;
    1c36:	2610      	movs	r6, #16
				/* Overflow, abort */
				return retval;
    1c38:	e035      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
			}
			/* Read value will be at least 8-bits long */
			rx_data[rx_pos++] = received_data;
    1c3a:	465b      	mov	r3, fp
    1c3c:	3301      	adds	r3, #1
    1c3e:	b29b      	uxth	r3, r3
    1c40:	4646      	mov	r6, r8
    1c42:	4659      	mov	r1, fp
    1c44:	5475      	strb	r5, [r6, r1]

			/* If 9-bit data, write next received byte to the buffer */
			if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1c46:	4661      	mov	r1, ip
    1c48:	798e      	ldrb	r6, [r1, #6]
    1c4a:	2e01      	cmp	r6, #1
    1c4c:	d107      	bne.n	1c5e <spi_transceive_buffer_wait+0x246>
				rx_data[rx_pos++] = (received_data >> 8);
    1c4e:	465e      	mov	r6, fp
    1c50:	3602      	adds	r6, #2
    1c52:	b2b1      	uxth	r1, r6
    1c54:	468b      	mov	fp, r1
    1c56:	0a2d      	lsrs	r5, r5, #8
    1c58:	4641      	mov	r1, r8
    1c5a:	54cd      	strb	r5, [r1, r3]
    1c5c:	e000      	b.n	1c60 <spi_transceive_buffer_wait+0x248>
			if (retval != STATUS_OK) {
				/* Overflow, abort */
				return retval;
			}
			/* Read value will be at least 8-bits long */
			rx_data[rx_pos++] = received_data;
    1c5e:	469b      	mov	fp, r3
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (module->mode == SPI_MODE_SLAVE) {
		while (rx_length) {
    1c60:	2800      	cmp	r0, #0
    1c62:	d109      	bne.n	1c78 <spi_transceive_buffer_wait+0x260>
    1c64:	e017      	b.n	1c96 <spi_transceive_buffer_wait+0x27e>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1c66:	2704      	movs	r7, #4
			/* Start timeout period for slave */
			for (uint32_t i = 0; i <= SPI_TIMEOUT; i++) {
				if (spi_is_ready_to_read(module)) {
    1c68:	4a13      	ldr	r2, [pc, #76]	; (1cb8 <spi_transceive_buffer_wait+0x2a0>)

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    1c6a:	2304      	movs	r3, #4
    1c6c:	4699      	mov	r9, r3

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    1c6e:	24ff      	movs	r4, #255	; 0xff
    1c70:	4684      	mov	ip, r0
    1c72:	9b03      	ldr	r3, [sp, #12]
    1c74:	4698      	mov	r8, r3
    1c76:	4650      	mov	r0, sl
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1c78:	4663      	mov	r3, ip
    1c7a:	681e      	ldr	r6, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1c7c:	7bb3      	ldrb	r3, [r6, #14]
    1c7e:	423b      	tst	r3, r7
    1c80:	d1b8      	bne.n	1bf4 <spi_transceive_buffer_wait+0x1dc>
    1c82:	1c13      	adds	r3, r2, #0
    1c84:	e7b0      	b.n	1be8 <spi_transceive_buffer_wait+0x1d0>
				return STATUS_ABORTED;
			}

			if (!spi_is_ready_to_write(module)) {
				/* Not ready to write data within timeout period */
				return STATUS_ERR_TIMEOUT;
    1c86:	2612      	movs	r6, #18
    1c88:	e00d      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
				return STATUS_ABORTED;
			}

			if (!spi_is_ready_to_read(module)) {
				/* Not ready to read data within timeout period */
				return STATUS_ERR_TIMEOUT;
    1c8a:	2612      	movs	r6, #18
    1c8c:	e00b      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
				rx_data[rx_pos++] = (received_data >> 8);
			}
		}
	}
#  endif
	return STATUS_OK;
    1c8e:	2600      	movs	r6, #0
    1c90:	e009      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
					break;
				}
			}
			if (!spi_is_ready_to_read(module)) {
				/* Not ready to read data within timeout period */
				return STATUS_ERR_TIMEOUT;
    1c92:	2612      	movs	r6, #18
    1c94:	e007      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
				rx_data[rx_pos++] = (received_data >> 8);
			}
		}
	}
#  endif
	return STATUS_OK;
    1c96:	2600      	movs	r6, #0
    1c98:	e005      	b.n	1ca6 <spi_transceive_buffer_wait+0x28e>
		/* Write the data to send */
		spi_write(module, data_to_send);

#  if CONF_SPI_SLAVE_ENABLE == true
		/* Start timeout period for slave */
		if (module->mode == SPI_MODE_SLAVE) {
    1c9a:	7944      	ldrb	r4, [r0, #5]
    1c9c:	1c3e      	adds	r6, r7, #0
    1c9e:	2c00      	cmp	r4, #0
    1ca0:	d000      	beq.n	1ca4 <spi_transceive_buffer_wait+0x28c>
    1ca2:	e752      	b.n	1b4a <spi_transceive_buffer_wait+0x132>
    1ca4:	e717      	b.n	1ad6 <spi_transceive_buffer_wait+0xbe>
			}
		}
	}
#  endif
	return STATUS_OK;
}
    1ca6:	1c30      	adds	r0, r6, #0
    1ca8:	b005      	add	sp, #20
    1caa:	bc3c      	pop	{r2, r3, r4, r5}
    1cac:	4690      	mov	r8, r2
    1cae:	4699      	mov	r9, r3
    1cb0:	46a2      	mov	sl, r4
    1cb2:	46ab      	mov	fp, r5
    1cb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1cb6:	46c0      	nop			; (mov r8, r8)
    1cb8:	00002710 	.word	0x00002710
    1cbc:	00002711 	.word	0x00002711

00001cc0 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    1cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1cc2:	465f      	mov	r7, fp
    1cc4:	4656      	mov	r6, sl
    1cc6:	464d      	mov	r5, r9
    1cc8:	4644      	mov	r4, r8
    1cca:	b4f0      	push	{r4, r5, r6, r7}
    1ccc:	b08d      	sub	sp, #52	; 0x34
    1cce:	1c05      	adds	r5, r0, #0
    1cd0:	1c0c      	adds	r4, r1, #0
    1cd2:	1c16      	adds	r6, r2, #0
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    1cd4:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    1cd6:	1c08      	adds	r0, r1, #0
    1cd8:	4b82      	ldr	r3, [pc, #520]	; (1ee4 <usart_init+0x224>)
    1cda:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    1cdc:	6822      	ldr	r2, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    1cde:	2305      	movs	r3, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    1ce0:	07d2      	lsls	r2, r2, #31
    1ce2:	d500      	bpl.n	1ce6 <usart_init+0x26>
    1ce4:	e0f5      	b.n	1ed2 <usart_init+0x212>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    1ce6:	6822      	ldr	r2, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    1ce8:	3317      	adds	r3, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    1cea:	0792      	lsls	r2, r2, #30
    1cec:	d500      	bpl.n	1cf0 <usart_init+0x30>
    1cee:	e0f0      	b.n	1ed2 <usart_init+0x212>
    1cf0:	497d      	ldr	r1, [pc, #500]	; (1ee8 <usart_init+0x228>)
    1cf2:	6a0a      	ldr	r2, [r1, #32]
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    1cf4:	1c87      	adds	r7, r0, #2
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    1cf6:	3b1b      	subs	r3, #27
    1cf8:	40bb      	lsls	r3, r7
    1cfa:	4313      	orrs	r3, r2
    1cfc:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    1cfe:	a90b      	add	r1, sp, #44	; 0x2c
    1d00:	7f73      	ldrb	r3, [r6, #29]
    1d02:	700b      	strb	r3, [r1, #0]
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    1d04:	300d      	adds	r0, #13

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    1d06:	b2c7      	uxtb	r7, r0
    1d08:	1c38      	adds	r0, r7, #0
    1d0a:	4b78      	ldr	r3, [pc, #480]	; (1eec <usart_init+0x22c>)
    1d0c:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    1d0e:	1c38      	adds	r0, r7, #0
    1d10:	4b77      	ldr	r3, [pc, #476]	; (1ef0 <usart_init+0x230>)
    1d12:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    1d14:	7f70      	ldrb	r0, [r6, #29]
    1d16:	2100      	movs	r1, #0
    1d18:	4b76      	ldr	r3, [pc, #472]	; (1ef4 <usart_init+0x234>)
    1d1a:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    1d1c:	7af3      	ldrb	r3, [r6, #11]
    1d1e:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    1d20:	7d33      	ldrb	r3, [r6, #20]
    1d22:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    1d24:	7d73      	ldrb	r3, [r6, #21]
    1d26:	71eb      	strb	r3, [r5, #7]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    1d28:	682b      	ldr	r3, [r5, #0]
    1d2a:	4699      	mov	r9, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    1d2c:	1c18      	adds	r0, r3, #0
    1d2e:	4b6d      	ldr	r3, [pc, #436]	; (1ee4 <usart_init+0x224>)
    1d30:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    1d32:	300d      	adds	r0, #13
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    1d34:	2200      	movs	r2, #0
    1d36:	230e      	movs	r3, #14
    1d38:	a902      	add	r1, sp, #8
    1d3a:	468c      	mov	ip, r1
    1d3c:	4463      	add	r3, ip
    1d3e:	801a      	strh	r2, [r3, #0]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    1d40:	6833      	ldr	r3, [r6, #0]
    1d42:	469a      	mov	sl, r3
		(uint32_t)config->mux_setting |
    1d44:	68f3      	ldr	r3, [r6, #12]
    1d46:	469b      	mov	fp, r3
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    1d48:	7db3      	ldrb	r3, [r6, #22]
    1d4a:	9302      	str	r3, [sp, #8]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    1d4c:	6872      	ldr	r2, [r6, #4]
    1d4e:	9203      	str	r2, [sp, #12]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    1d50:	2a00      	cmp	r2, #0
    1d52:	d014      	beq.n	1d7e <usart_init+0xbe>
    1d54:	2380      	movs	r3, #128	; 0x80
    1d56:	055b      	lsls	r3, r3, #21
    1d58:	429a      	cmp	r2, r3
    1d5a:	d130      	bne.n	1dbe <usart_init+0xfe>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    1d5c:	7df3      	ldrb	r3, [r6, #23]
    1d5e:	2b00      	cmp	r3, #0
    1d60:	d131      	bne.n	1dc6 <usart_init+0x106>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    1d62:	6933      	ldr	r3, [r6, #16]
    1d64:	4698      	mov	r8, r3
    1d66:	b2c0      	uxtb	r0, r0
    1d68:	4b63      	ldr	r3, [pc, #396]	; (1ef8 <usart_init+0x238>)
    1d6a:	4798      	blx	r3
    1d6c:	1c01      	adds	r1, r0, #0
    1d6e:	4640      	mov	r0, r8
    1d70:	220e      	movs	r2, #14
    1d72:	ab02      	add	r3, sp, #8
    1d74:	469c      	mov	ip, r3
    1d76:	4462      	add	r2, ip
    1d78:	4b60      	ldr	r3, [pc, #384]	; (1efc <usart_init+0x23c>)
    1d7a:	4798      	blx	r3
    1d7c:	e020      	b.n	1dc0 <usart_init+0x100>
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    1d7e:	7df3      	ldrb	r3, [r6, #23]
    1d80:	2b00      	cmp	r3, #0
    1d82:	d00b      	beq.n	1d9c <usart_init+0xdc>
				status_code =
    1d84:	2310      	movs	r3, #16
    1d86:	9300      	str	r3, [sp, #0]
    1d88:	6930      	ldr	r0, [r6, #16]
    1d8a:	69b1      	ldr	r1, [r6, #24]
    1d8c:	220e      	movs	r2, #14
    1d8e:	ab02      	add	r3, sp, #8
    1d90:	469c      	mov	ip, r3
    1d92:	4462      	add	r2, ip
    1d94:	2300      	movs	r3, #0
    1d96:	4f5a      	ldr	r7, [pc, #360]	; (1f00 <usart_init+0x240>)
    1d98:	47b8      	blx	r7
    1d9a:	e011      	b.n	1dc0 <usart_init+0x100>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    1d9c:	6933      	ldr	r3, [r6, #16]
    1d9e:	4698      	mov	r8, r3
    1da0:	b2c0      	uxtb	r0, r0
    1da2:	4b55      	ldr	r3, [pc, #340]	; (1ef8 <usart_init+0x238>)
    1da4:	4798      	blx	r3
    1da6:	1c01      	adds	r1, r0, #0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
    1da8:	2310      	movs	r3, #16
    1daa:	9300      	str	r3, [sp, #0]
    1dac:	4640      	mov	r0, r8
    1dae:	220e      	movs	r2, #14
    1db0:	ab02      	add	r3, sp, #8
    1db2:	469c      	mov	ip, r3
    1db4:	4462      	add	r2, ip
    1db6:	2300      	movs	r3, #0
    1db8:	4f51      	ldr	r7, [pc, #324]	; (1f00 <usart_init+0x240>)
    1dba:	47b8      	blx	r7
    1dbc:	e000      	b.n	1dc0 <usart_init+0x100>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
    1dbe:	2000      	movs	r0, #0
    1dc0:	1e03      	subs	r3, r0, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    1dc2:	d000      	beq.n	1dc6 <usart_init+0x106>
    1dc4:	e085      	b.n	1ed2 <usart_init+0x212>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    1dc6:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    1dc8:	8a13      	ldrh	r3, [r2, #16]
    1dca:	0bdb      	lsrs	r3, r3, #15
    1dcc:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1dce:	b29b      	uxth	r3, r3
    1dd0:	2b00      	cmp	r3, #0
    1dd2:	d1f9      	bne.n	1dc8 <usart_init+0x108>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    1dd4:	330e      	adds	r3, #14
    1dd6:	aa02      	add	r2, sp, #8
    1dd8:	4694      	mov	ip, r2
    1dda:	4463      	add	r3, ip
    1ddc:	881b      	ldrh	r3, [r3, #0]
    1dde:	464a      	mov	r2, r9
    1de0:	8153      	strh	r3, [r2, #10]
    1de2:	465b      	mov	r3, fp
    1de4:	4652      	mov	r2, sl
    1de6:	4313      	orrs	r3, r2
    1de8:	9a03      	ldr	r2, [sp, #12]
    1dea:	4313      	orrs	r3, r2
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    1dec:	9a02      	ldr	r2, [sp, #8]
    1dee:	0757      	lsls	r7, r2, #29

	/*Set baud val */
	usart_hw->BAUD.reg = baud;

	/* Set sample mode */
	ctrla |= transfer_mode;
    1df0:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
    1df2:	7df3      	ldrb	r3, [r6, #23]
    1df4:	2b00      	cmp	r3, #0
    1df6:	d101      	bne.n	1dfc <usart_init+0x13c>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    1df8:	3304      	adds	r3, #4
    1dfa:	431f      	orrs	r7, r3
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    1dfc:	7d73      	ldrb	r3, [r6, #21]
    1dfe:	041a      	lsls	r2, r3, #16
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    1e00:	7d33      	ldrb	r3, [r6, #20]
    1e02:	045b      	lsls	r3, r3, #17
    1e04:	4313      	orrs	r3, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
    1e06:	7af1      	ldrb	r1, [r6, #11]
    1e08:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    1e0a:	8932      	ldrh	r2, [r6, #8]
    1e0c:	2aff      	cmp	r2, #255	; 0xff
    1e0e:	d003      	beq.n	1e18 <usart_init+0x158>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    1e10:	2380      	movs	r3, #128	; 0x80
    1e12:	045b      	lsls	r3, r3, #17
    1e14:	431f      	orrs	r7, r3
		ctrlb |= config->parity;
    1e16:	4311      	orrs	r1, r2
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    1e18:	7f33      	ldrb	r3, [r6, #28]
    1e1a:	2b00      	cmp	r3, #0
    1e1c:	d103      	bne.n	1e26 <usart_init+0x166>
    1e1e:	4b39      	ldr	r3, [pc, #228]	; (1f04 <usart_init+0x244>)
    1e20:	789b      	ldrb	r3, [r3, #2]
    1e22:	079b      	lsls	r3, r3, #30
    1e24:	d501      	bpl.n	1e2a <usart_init+0x16a>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    1e26:	2380      	movs	r3, #128	; 0x80
    1e28:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    1e2a:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    1e2c:	8a13      	ldrh	r3, [r2, #16]
    1e2e:	0bdb      	lsrs	r3, r3, #15
    1e30:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1e32:	b29b      	uxth	r3, r3
    1e34:	2b00      	cmp	r3, #0
    1e36:	d1f9      	bne.n	1e2c <usart_init+0x16c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    1e38:	464b      	mov	r3, r9
    1e3a:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    1e3c:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    1e3e:	8a13      	ldrh	r3, [r2, #16]
    1e40:	0bdb      	lsrs	r3, r3, #15
    1e42:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1e44:	b29b      	uxth	r3, r3
    1e46:	2b00      	cmp	r3, #0
    1e48:	d1f9      	bne.n	1e3e <usart_init+0x17e>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    1e4a:	464b      	mov	r3, r9
    1e4c:	601f      	str	r7, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    1e4e:	ab0a      	add	r3, sp, #40	; 0x28
    1e50:	2280      	movs	r2, #128	; 0x80
    1e52:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    1e54:	2200      	movs	r2, #0
    1e56:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    1e58:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    1e5a:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
    1e5c:	6a33      	ldr	r3, [r6, #32]
    1e5e:	9306      	str	r3, [sp, #24]
    1e60:	6a73      	ldr	r3, [r6, #36]	; 0x24
    1e62:	9307      	str	r3, [sp, #28]
    1e64:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    1e66:	9308      	str	r3, [sp, #32]
    1e68:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    1e6a:	9302      	str	r3, [sp, #8]
    1e6c:	9309      	str	r3, [sp, #36]	; 0x24
    1e6e:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    1e70:	ae0a      	add	r6, sp, #40	; 0x28
    1e72:	b2f9      	uxtb	r1, r7
    1e74:	00bb      	lsls	r3, r7, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    1e76:	aa06      	add	r2, sp, #24
    1e78:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    1e7a:	2800      	cmp	r0, #0
    1e7c:	d102      	bne.n	1e84 <usart_init+0x1c4>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    1e7e:	1c20      	adds	r0, r4, #0
    1e80:	4b21      	ldr	r3, [pc, #132]	; (1f08 <usart_init+0x248>)
    1e82:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    1e84:	1c43      	adds	r3, r0, #1
    1e86:	d005      	beq.n	1e94 <usart_init+0x1d4>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    1e88:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    1e8a:	0c00      	lsrs	r0, r0, #16
    1e8c:	b2c0      	uxtb	r0, r0
    1e8e:	1c31      	adds	r1, r6, #0
    1e90:	4b1e      	ldr	r3, [pc, #120]	; (1f0c <usart_init+0x24c>)
    1e92:	4798      	blx	r3
    1e94:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    1e96:	2f04      	cmp	r7, #4
    1e98:	d1eb      	bne.n	1e72 <usart_init+0x1b2>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
    1e9a:	2300      	movs	r3, #0
    1e9c:	60ab      	str	r3, [r5, #8]
    1e9e:	60eb      	str	r3, [r5, #12]
    1ea0:	612b      	str	r3, [r5, #16]
	}

	module->tx_buffer_ptr              = NULL;
    1ea2:	61ab      	str	r3, [r5, #24]
	module->rx_buffer_ptr              = NULL;
    1ea4:	616b      	str	r3, [r5, #20]
	module->remaining_tx_buffer_length = 0x0000;
    1ea6:	2200      	movs	r2, #0
    1ea8:	83eb      	strh	r3, [r5, #30]
	module->remaining_rx_buffer_length = 0x0000;
    1eaa:	83ab      	strh	r3, [r5, #28]
	module->callback_reg_mask          = 0x00;
    1eac:	3320      	adds	r3, #32
    1eae:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    1eb0:	3301      	adds	r3, #1
    1eb2:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    1eb4:	3301      	adds	r3, #1
    1eb6:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    1eb8:	3301      	adds	r3, #1
    1eba:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    1ebc:	6828      	ldr	r0, [r5, #0]
    1ebe:	4b09      	ldr	r3, [pc, #36]	; (1ee4 <usart_init+0x224>)
    1ec0:	4798      	blx	r3
    1ec2:	1c04      	adds	r4, r0, #0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    1ec4:	4912      	ldr	r1, [pc, #72]	; (1f10 <usart_init+0x250>)
    1ec6:	4b13      	ldr	r3, [pc, #76]	; (1f14 <usart_init+0x254>)
    1ec8:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    1eca:	00a4      	lsls	r4, r4, #2
    1ecc:	4b12      	ldr	r3, [pc, #72]	; (1f18 <usart_init+0x258>)
    1ece:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
    1ed0:	2300      	movs	r3, #0
}
    1ed2:	1c18      	adds	r0, r3, #0
    1ed4:	b00d      	add	sp, #52	; 0x34
    1ed6:	bc3c      	pop	{r2, r3, r4, r5}
    1ed8:	4690      	mov	r8, r2
    1eda:	4699      	mov	r9, r3
    1edc:	46a2      	mov	sl, r4
    1ede:	46ab      	mov	fp, r5
    1ee0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1ee2:	46c0      	nop			; (mov r8, r8)
    1ee4:	00001325 	.word	0x00001325
    1ee8:	40000400 	.word	0x40000400
    1eec:	000026cd 	.word	0x000026cd
    1ef0:	00002641 	.word	0x00002641
    1ef4:	00001151 	.word	0x00001151
    1ef8:	000026e9 	.word	0x000026e9
    1efc:	00000f61 	.word	0x00000f61
    1f00:	00000f89 	.word	0x00000f89
    1f04:	41002000 	.word	0x41002000
    1f08:	0000119d 	.word	0x0000119d
    1f0c:	000027c5 	.word	0x000027c5
    1f10:	00001f1d 	.word	0x00001f1d
    1f14:	00001365 	.word	0x00001365
    1f18:	20004130 	.word	0x20004130

00001f1c <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    1f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    1f1e:	0080      	lsls	r0, r0, #2
    1f20:	4b49      	ldr	r3, [pc, #292]	; (2048 <STACK_SIZE+0x48>)
    1f22:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    1f24:	682c      	ldr	r4, [r5, #0]
	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    1f26:	8a23      	ldrh	r3, [r4, #16]
    1f28:	0bdb      	lsrs	r3, r3, #15
    1f2a:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1f2c:	b29b      	uxth	r3, r3
    1f2e:	2b00      	cmp	r3, #0
    1f30:	d1f9      	bne.n	1f26 <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    1f32:	7ba3      	ldrb	r3, [r4, #14]
	interrupt_status &= usart_hw->INTENSET.reg;
    1f34:	7b66      	ldrb	r6, [r4, #13]
    1f36:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
			module->callback_enable_mask;
    1f38:	2321      	movs	r3, #33	; 0x21
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
	callback_status = module->callback_reg_mask &
    1f3a:	5ceb      	ldrb	r3, [r5, r3]
    1f3c:	2220      	movs	r2, #32
    1f3e:	5caf      	ldrb	r7, [r5, r2]
    1f40:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    1f42:	07f3      	lsls	r3, r6, #31
    1f44:	d522      	bpl.n	1f8c <_usart_interrupt_handler+0x70>
		if (module->remaining_tx_buffer_length) {
    1f46:	8beb      	ldrh	r3, [r5, #30]
    1f48:	b29b      	uxth	r3, r3
    1f4a:	2b00      	cmp	r3, #0
    1f4c:	d01c      	beq.n	1f88 <_usart_interrupt_handler+0x6c>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    1f4e:	69aa      	ldr	r2, [r5, #24]
    1f50:	7813      	ldrb	r3, [r2, #0]
    1f52:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    1f54:	1c51      	adds	r1, r2, #1
    1f56:	61a9      	str	r1, [r5, #24]

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    1f58:	7969      	ldrb	r1, [r5, #5]
    1f5a:	2901      	cmp	r1, #1
    1f5c:	d001      	beq.n	1f62 <_usart_interrupt_handler+0x46>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    1f5e:	b29b      	uxth	r3, r3
    1f60:	e004      	b.n	1f6c <_usart_interrupt_handler+0x50>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    1f62:	7851      	ldrb	r1, [r2, #1]
    1f64:	0209      	lsls	r1, r1, #8
    1f66:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    1f68:	3202      	adds	r2, #2
    1f6a:	61aa      	str	r2, [r5, #24]
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    1f6c:	05db      	lsls	r3, r3, #23
    1f6e:	0ddb      	lsrs	r3, r3, #23
    1f70:	8323      	strh	r3, [r4, #24]

			if (--(module->remaining_tx_buffer_length) == 0) {
    1f72:	8beb      	ldrh	r3, [r5, #30]
    1f74:	3b01      	subs	r3, #1
    1f76:	b29b      	uxth	r3, r3
    1f78:	83eb      	strh	r3, [r5, #30]
    1f7a:	2b00      	cmp	r3, #0
    1f7c:	d106      	bne.n	1f8c <_usart_interrupt_handler+0x70>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    1f7e:	3301      	adds	r3, #1
    1f80:	7323      	strb	r3, [r4, #12]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    1f82:	3301      	adds	r3, #1
    1f84:	7363      	strb	r3, [r4, #13]
    1f86:	e001      	b.n	1f8c <_usart_interrupt_handler+0x70>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    1f88:	2301      	movs	r3, #1
    1f8a:	7323      	strb	r3, [r4, #12]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    1f8c:	07b3      	lsls	r3, r6, #30
    1f8e:	d509      	bpl.n	1fa4 <_usart_interrupt_handler+0x88>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    1f90:	2302      	movs	r3, #2
    1f92:	7323      	strb	r3, [r4, #12]
		module->tx_status = STATUS_OK;
    1f94:	2200      	movs	r2, #0
    1f96:	3321      	adds	r3, #33	; 0x21
    1f98:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    1f9a:	07fb      	lsls	r3, r7, #31
    1f9c:	d502      	bpl.n	1fa4 <_usart_interrupt_handler+0x88>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    1f9e:	1c28      	adds	r0, r5, #0
    1fa0:	68ab      	ldr	r3, [r5, #8]
    1fa2:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    1fa4:	0773      	lsls	r3, r6, #29
    1fa6:	d54e      	bpl.n	2046 <STACK_SIZE+0x46>

		if (module->remaining_rx_buffer_length) {
    1fa8:	8bab      	ldrh	r3, [r5, #28]
    1faa:	b29b      	uxth	r3, r3
    1fac:	2b00      	cmp	r3, #0
    1fae:	d048      	beq.n	2042 <STACK_SIZE+0x42>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    1fb0:	8a23      	ldrh	r3, [r4, #16]
    1fb2:	b2db      	uxtb	r3, r3
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    1fb4:	075a      	lsls	r2, r3, #29
    1fb6:	d022      	beq.n	1ffe <_usart_interrupt_handler+0xe2>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    1fb8:	079a      	lsls	r2, r3, #30
    1fba:	d507      	bpl.n	1fcc <_usart_interrupt_handler+0xb0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    1fbc:	221a      	movs	r2, #26
    1fbe:	2322      	movs	r3, #34	; 0x22
    1fc0:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
    1fc2:	8a22      	ldrh	r2, [r4, #16]
    1fc4:	3b20      	subs	r3, #32
    1fc6:	4313      	orrs	r3, r2
    1fc8:	8223      	strh	r3, [r4, #16]
    1fca:	e012      	b.n	1ff2 <_usart_interrupt_handler+0xd6>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    1fcc:	075a      	lsls	r2, r3, #29
    1fce:	d507      	bpl.n	1fe0 <_usart_interrupt_handler+0xc4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    1fd0:	221e      	movs	r2, #30
    1fd2:	2322      	movs	r3, #34	; 0x22
    1fd4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
    1fd6:	8a22      	ldrh	r2, [r4, #16]
    1fd8:	3b1e      	subs	r3, #30
    1fda:	4313      	orrs	r3, r2
    1fdc:	8223      	strh	r3, [r4, #16]
    1fde:	e008      	b.n	1ff2 <_usart_interrupt_handler+0xd6>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    1fe0:	07db      	lsls	r3, r3, #31
    1fe2:	d506      	bpl.n	1ff2 <_usart_interrupt_handler+0xd6>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    1fe4:	2213      	movs	r2, #19
    1fe6:	2322      	movs	r3, #34	; 0x22
    1fe8:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
    1fea:	8a22      	ldrh	r2, [r4, #16]
    1fec:	3b21      	subs	r3, #33	; 0x21
    1fee:	4313      	orrs	r3, r2
    1ff0:	8223      	strh	r3, [r4, #16]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    1ff2:	077b      	lsls	r3, r7, #29
    1ff4:	d527      	bpl.n	2046 <STACK_SIZE+0x46>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    1ff6:	692b      	ldr	r3, [r5, #16]
    1ff8:	1c28      	adds	r0, r5, #0
    1ffa:	4798      	blx	r3
    1ffc:	e023      	b.n	2046 <STACK_SIZE+0x46>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    1ffe:	8b23      	ldrh	r3, [r4, #24]
    2000:	05db      	lsls	r3, r3, #23
    2002:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    2004:	b2da      	uxtb	r2, r3
    2006:	6969      	ldr	r1, [r5, #20]
    2008:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    200a:	696a      	ldr	r2, [r5, #20]
    200c:	1c51      	adds	r1, r2, #1
    200e:	6169      	str	r1, [r5, #20]

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    2010:	7969      	ldrb	r1, [r5, #5]
    2012:	2901      	cmp	r1, #1
    2014:	d104      	bne.n	2020 <STACK_SIZE+0x20>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    2016:	0a1b      	lsrs	r3, r3, #8
    2018:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    201a:	696b      	ldr	r3, [r5, #20]
    201c:	3301      	adds	r3, #1
    201e:	616b      	str	r3, [r5, #20]
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    2020:	8bab      	ldrh	r3, [r5, #28]
    2022:	3b01      	subs	r3, #1
    2024:	b29b      	uxth	r3, r3
    2026:	83ab      	strh	r3, [r5, #28]
    2028:	2b00      	cmp	r3, #0
    202a:	d10c      	bne.n	2046 <STACK_SIZE+0x46>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    202c:	3304      	adds	r3, #4
    202e:	7323      	strb	r3, [r4, #12]
					module->rx_status = STATUS_OK;
    2030:	2200      	movs	r2, #0
    2032:	331e      	adds	r3, #30
    2034:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    2036:	07bb      	lsls	r3, r7, #30
    2038:	d505      	bpl.n	2046 <STACK_SIZE+0x46>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    203a:	68eb      	ldr	r3, [r5, #12]
    203c:	1c28      	adds	r0, r5, #0
    203e:	4798      	blx	r3
    2040:	e001      	b.n	2046 <STACK_SIZE+0x46>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    2042:	2304      	movs	r3, #4
    2044:	7323      	strb	r3, [r4, #12]
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
		}
	}
#endif
}
    2046:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2048:	20004130 	.word	0x20004130

0000204c <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    204c:	b508      	push	{r3, lr}
	switch (clock_source) {
    204e:	2807      	cmp	r0, #7
    2050:	d803      	bhi.n	205a <system_clock_source_get_hz+0xe>
    2052:	0080      	lsls	r0, r0, #2
    2054:	4b17      	ldr	r3, [pc, #92]	; (20b4 <system_clock_source_get_hz+0x68>)
    2056:	581b      	ldr	r3, [r3, r0]
    2058:	469f      	mov	pc, r3
		}

		return 48000000UL;

	default:
		return 0;
    205a:	2000      	movs	r0, #0
    205c:	e028      	b.n	20b0 <system_clock_source_get_hz+0x64>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    205e:	4b16      	ldr	r3, [pc, #88]	; (20b8 <system_clock_source_get_hz+0x6c>)
    2060:	68d8      	ldr	r0, [r3, #12]
    2062:	e025      	b.n	20b0 <system_clock_source_get_hz+0x64>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    2064:	4b15      	ldr	r3, [pc, #84]	; (20bc <system_clock_source_get_hz+0x70>)
    2066:	6a18      	ldr	r0, [r3, #32]
    2068:	0580      	lsls	r0, r0, #22
    206a:	0f80      	lsrs	r0, r0, #30
    206c:	4b14      	ldr	r3, [pc, #80]	; (20c0 <system_clock_source_get_hz+0x74>)
    206e:	40c3      	lsrs	r3, r0
    2070:	1c18      	adds	r0, r3, #0
    2072:	e01d      	b.n	20b0 <system_clock_source_get_hz+0x64>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    2074:	4b10      	ldr	r3, [pc, #64]	; (20b8 <system_clock_source_get_hz+0x6c>)
    2076:	6918      	ldr	r0, [r3, #16]
    2078:	e01a      	b.n	20b0 <system_clock_source_get_hz+0x64>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    207a:	4b0f      	ldr	r3, [pc, #60]	; (20b8 <system_clock_source_get_hz+0x6c>)
    207c:	681b      	ldr	r3, [r3, #0]
    207e:	2002      	movs	r0, #2
    2080:	4018      	ands	r0, r3
    2082:	d015      	beq.n	20b0 <system_clock_source_get_hz+0x64>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    2084:	490d      	ldr	r1, [pc, #52]	; (20bc <system_clock_source_get_hz+0x70>)
    2086:	2210      	movs	r2, #16
    2088:	68cb      	ldr	r3, [r1, #12]
    208a:	421a      	tst	r2, r3
    208c:	d0fc      	beq.n	2088 <system_clock_source_get_hz+0x3c>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    208e:	4b0a      	ldr	r3, [pc, #40]	; (20b8 <system_clock_source_get_hz+0x6c>)
    2090:	681b      	ldr	r3, [r3, #0]
    2092:	075b      	lsls	r3, r3, #29
    2094:	d50b      	bpl.n	20ae <system_clock_source_get_hz+0x62>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    2096:	2000      	movs	r0, #0
    2098:	4b0a      	ldr	r3, [pc, #40]	; (20c4 <system_clock_source_get_hz+0x78>)
    209a:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    209c:	4b06      	ldr	r3, [pc, #24]	; (20b8 <system_clock_source_get_hz+0x6c>)
    209e:	689b      	ldr	r3, [r3, #8]
    20a0:	041b      	lsls	r3, r3, #16
    20a2:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    20a4:	4358      	muls	r0, r3
    20a6:	e003      	b.n	20b0 <system_clock_source_get_hz+0x64>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    20a8:	2080      	movs	r0, #128	; 0x80
    20aa:	0200      	lsls	r0, r0, #8
    20ac:	e000      	b.n	20b0 <system_clock_source_get_hz+0x64>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    20ae:	4806      	ldr	r0, [pc, #24]	; (20c8 <system_clock_source_get_hz+0x7c>)

	default:
		return 0;
	}
}
    20b0:	bd08      	pop	{r3, pc}
    20b2:	46c0      	nop			; (mov r8, r8)
    20b4:	00004f34 	.word	0x00004f34
    20b8:	20000468 	.word	0x20000468
    20bc:	40000800 	.word	0x40000800
    20c0:	007a1200 	.word	0x007a1200
    20c4:	000026e9 	.word	0x000026e9
    20c8:	02dc6c00 	.word	0x02dc6c00

000020cc <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    20cc:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    20ce:	4c0c      	ldr	r4, [pc, #48]	; (2100 <system_clock_source_osc8m_set_config+0x34>)
    20d0:	6a23      	ldr	r3, [r4, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    20d2:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    20d4:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    20d6:	7842      	ldrb	r2, [r0, #1]
    20d8:	2001      	movs	r0, #1
    20da:	4002      	ands	r2, r0
    20dc:	0192      	lsls	r2, r2, #6
    20de:	2640      	movs	r6, #64	; 0x40
    20e0:	43b3      	bics	r3, r6
    20e2:	4313      	orrs	r3, r2
    20e4:	1c02      	adds	r2, r0, #0
    20e6:	402a      	ands	r2, r5
    20e8:	01d2      	lsls	r2, r2, #7
    20ea:	307f      	adds	r0, #127	; 0x7f
    20ec:	4383      	bics	r3, r0
    20ee:	4313      	orrs	r3, r2
    20f0:	2203      	movs	r2, #3
    20f2:	400a      	ands	r2, r1
    20f4:	0212      	lsls	r2, r2, #8
    20f6:	4903      	ldr	r1, [pc, #12]	; (2104 <system_clock_source_osc8m_set_config+0x38>)
    20f8:	400b      	ands	r3, r1
    20fa:	4313      	orrs	r3, r2
    20fc:	6223      	str	r3, [r4, #32]
}
    20fe:	bd70      	pop	{r4, r5, r6, pc}
    2100:	40000800 	.word	0x40000800
    2104:	fffffcff 	.word	0xfffffcff

00002108 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    2108:	b5f0      	push	{r4, r5, r6, r7, lr}
    210a:	465f      	mov	r7, fp
    210c:	4656      	mov	r6, sl
    210e:	464d      	mov	r5, r9
    2110:	4644      	mov	r4, r8
    2112:	b4f0      	push	{r4, r5, r6, r7}
    2114:	b083      	sub	sp, #12
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    2116:	4e2e      	ldr	r6, [pc, #184]	; (21d0 <system_clock_source_xosc32k_set_config+0xc8>)
    2118:	8ab3      	ldrh	r3, [r6, #20]
    211a:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;
    211c:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    211e:	7803      	ldrb	r3, [r0, #0]
    2120:	425a      	negs	r2, r3
    2122:	415a      	adcs	r2, r3
    2124:	4691      	mov	r9, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    2126:	7883      	ldrb	r3, [r0, #2]
    2128:	469b      	mov	fp, r3
	temp.bit.EN1K = config->enable_1khz_output;
    212a:	78c3      	ldrb	r3, [r0, #3]
	temp.bit.EN32K = config->enable_32khz_output;
    212c:	7902      	ldrb	r2, [r0, #4]
    212e:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
    2130:	7b47      	ldrb	r7, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    2132:	7b02      	ldrb	r2, [r0, #12]
    2134:	9201      	str	r2, [sp, #4]
	temp.bit.WRTLOCK  = config->write_once;
    2136:	7b84      	ldrb	r4, [r0, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    2138:	6882      	ldr	r2, [r0, #8]
    213a:	4826      	ldr	r0, [pc, #152]	; (21d4 <system_clock_source_xosc32k_set_config+0xcc>)
    213c:	6102      	str	r2, [r0, #16]

	SYSCTRL->XOSC32K = temp;
    213e:	2001      	movs	r0, #1
    2140:	464a      	mov	r2, r9
    2142:	0092      	lsls	r2, r2, #2
    2144:	4691      	mov	r9, r2
    2146:	2204      	movs	r2, #4
    2148:	4692      	mov	sl, r2
    214a:	4662      	mov	r2, ip
    214c:	4651      	mov	r1, sl
    214e:	438a      	bics	r2, r1
    2150:	4694      	mov	ip, r2
    2152:	464a      	mov	r2, r9
    2154:	4661      	mov	r1, ip
    2156:	430a      	orrs	r2, r1
    2158:	4694      	mov	ip, r2
    215a:	4642      	mov	r2, r8
    215c:	4002      	ands	r2, r0
    215e:	00d2      	lsls	r2, r2, #3
    2160:	4690      	mov	r8, r2
    2162:	2208      	movs	r2, #8
    2164:	4691      	mov	r9, r2
    2166:	4662      	mov	r2, ip
    2168:	4649      	mov	r1, r9
    216a:	438a      	bics	r2, r1
    216c:	4694      	mov	ip, r2
    216e:	4642      	mov	r2, r8
    2170:	4661      	mov	r1, ip
    2172:	430a      	orrs	r2, r1
    2174:	4694      	mov	ip, r2
    2176:	4003      	ands	r3, r0
    2178:	011b      	lsls	r3, r3, #4
    217a:	2210      	movs	r2, #16
    217c:	4690      	mov	r8, r2
    217e:	4662      	mov	r2, ip
    2180:	4641      	mov	r1, r8
    2182:	438a      	bics	r2, r1
    2184:	4313      	orrs	r3, r2
    2186:	4659      	mov	r1, fp
    2188:	4001      	ands	r1, r0
    218a:	0149      	lsls	r1, r1, #5
    218c:	2220      	movs	r2, #32
    218e:	4393      	bics	r3, r2
    2190:	430b      	orrs	r3, r1
    2192:	9a01      	ldr	r2, [sp, #4]
    2194:	4002      	ands	r2, r0
    2196:	0192      	lsls	r2, r2, #6
    2198:	2140      	movs	r1, #64	; 0x40
    219a:	438b      	bics	r3, r1
    219c:	4313      	orrs	r3, r2
    219e:	4007      	ands	r7, r0
    21a0:	01ff      	lsls	r7, r7, #7
    21a2:	2280      	movs	r2, #128	; 0x80
    21a4:	4393      	bics	r3, r2
    21a6:	433b      	orrs	r3, r7
    21a8:	3a79      	subs	r2, #121	; 0x79
    21aa:	4015      	ands	r5, r2
    21ac:	022d      	lsls	r5, r5, #8
    21ae:	4f0a      	ldr	r7, [pc, #40]	; (21d8 <system_clock_source_xosc32k_set_config+0xd0>)
    21b0:	403b      	ands	r3, r7
    21b2:	432b      	orrs	r3, r5
    21b4:	4004      	ands	r4, r0
    21b6:	0320      	lsls	r0, r4, #12
    21b8:	4c08      	ldr	r4, [pc, #32]	; (21dc <system_clock_source_xosc32k_set_config+0xd4>)
    21ba:	401c      	ands	r4, r3
    21bc:	4304      	orrs	r4, r0
    21be:	82b4      	strh	r4, [r6, #20]
}
    21c0:	b003      	add	sp, #12
    21c2:	bc3c      	pop	{r2, r3, r4, r5}
    21c4:	4690      	mov	r8, r2
    21c6:	4699      	mov	r9, r3
    21c8:	46a2      	mov	sl, r4
    21ca:	46ab      	mov	fp, r5
    21cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    21ce:	46c0      	nop			; (mov r8, r8)
    21d0:	40000800 	.word	0x40000800
    21d4:	20000468 	.word	0x20000468
    21d8:	fffff8ff 	.word	0xfffff8ff
    21dc:	ffffefff 	.word	0xffffefff

000021e0 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    21e0:	b510      	push	{r4, lr}
 *
 * \return Device ID signature as a 32-bit integer.
 */
static inline uint32_t system_get_device_id(void)
{
	return DSU->DID.reg;
    21e2:	4b26      	ldr	r3, [pc, #152]	; (227c <system_clock_source_dfll_set_config+0x9c>)
    21e4:	699b      	ldr	r3, [r3, #24]

	/* Get MCU revision */
	uint32_t rev = system_get_device_id();

	rev &= DSU_DID_REVISION_Msk;
    21e6:	051b      	lsls	r3, r3, #20
	rev = rev >> DSU_DID_REVISION_Pos;
    21e8:	0f1b      	lsrs	r3, r3, #28

	if (rev < _SYSTEM_MCU_REVISION_D) {
    21ea:	2b02      	cmp	r3, #2
    21ec:	d809      	bhi.n	2202 <system_clock_source_dfll_set_config+0x22>
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
    21ee:	7a02      	ldrb	r2, [r0, #8]
    21f0:	0212      	lsls	r2, r2, #8
    21f2:	21f8      	movs	r1, #248	; 0xf8
    21f4:	0149      	lsls	r1, r1, #5
    21f6:	400a      	ands	r2, r1
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
    21f8:	7a81      	ldrb	r1, [r0, #10]
	rev &= DSU_DID_REVISION_Msk;
	rev = rev >> DSU_DID_REVISION_Pos;

	if (rev < _SYSTEM_MCU_REVISION_D) {
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
    21fa:	430a      	orrs	r2, r1

	rev &= DSU_DID_REVISION_Msk;
	rev = rev >> DSU_DID_REVISION_Pos;

	if (rev < _SYSTEM_MCU_REVISION_D) {
		_system_clock_inst.dfll.val =
    21fc:	4920      	ldr	r1, [pc, #128]	; (2280 <system_clock_source_dfll_set_config+0xa0>)
    21fe:	604a      	str	r2, [r1, #4]
    2200:	e008      	b.n	2214 <system_clock_source_dfll_set_config+0x34>
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
	} else {
		_system_clock_inst.dfll.val =
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
    2202:	7a02      	ldrb	r2, [r0, #8]
    2204:	0692      	lsls	r2, r2, #26
    2206:	0c11      	lsrs	r1, r2, #16
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
    2208:	8942      	ldrh	r2, [r0, #10]
    220a:	0592      	lsls	r2, r2, #22
    220c:	0d92      	lsrs	r2, r2, #22
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
	} else {
		_system_clock_inst.dfll.val =
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
    220e:	430a      	orrs	r2, r1
	if (rev < _SYSTEM_MCU_REVISION_D) {
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
	} else {
		_system_clock_inst.dfll.val =
    2210:	491b      	ldr	r1, [pc, #108]	; (2280 <system_clock_source_dfll_set_config+0xa0>)
    2212:	604a      	str	r2, [r1, #4]
    2214:	8884      	ldrh	r4, [r0, #4]
    2216:	8842      	ldrh	r2, [r0, #2]
    2218:	4314      	orrs	r4, r2
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
	}

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    221a:	79c2      	ldrb	r2, [r0, #7]
    221c:	7981      	ldrb	r1, [r0, #6]
    221e:	430a      	orrs	r2, r1
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    2220:	4322      	orrs	r2, r4
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    2222:	7841      	ldrb	r1, [r0, #1]
    2224:	01c9      	lsls	r1, r1, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    2226:	430a      	orrs	r2, r1
		_system_clock_inst.dfll.val =
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
	}

	_system_clock_inst.dfll.control =
    2228:	4915      	ldr	r1, [pc, #84]	; (2280 <system_clock_source_dfll_set_config+0xa0>)
    222a:	600a      	str	r2, [r1, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    222c:	7802      	ldrb	r2, [r0, #0]
    222e:	2a04      	cmp	r2, #4
    2230:	d123      	bne.n	227a <system_clock_source_dfll_set_config+0x9a>

		if(rev < _SYSTEM_MCU_REVISION_D) {
    2232:	2b02      	cmp	r3, #2
    2234:	d810      	bhi.n	2258 <system_clock_source_dfll_set_config+0x78>
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
    2236:	7b03      	ldrb	r3, [r0, #12]
    2238:	061b      	lsls	r3, r3, #24
    223a:	22f8      	movs	r2, #248	; 0xf8
    223c:	0552      	lsls	r2, r2, #21
    223e:	4013      	ands	r3, r2
    2240:	1c19      	adds	r1, r3, #0
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
    2242:	89c3      	ldrh	r3, [r0, #14]
    2244:	041b      	lsls	r3, r3, #16
    2246:	22ff      	movs	r2, #255	; 0xff
    2248:	0412      	lsls	r2, r2, #16
    224a:	4013      	ands	r3, r2

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		if(rev < _SYSTEM_MCU_REVISION_D) {
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
    224c:	430b      	orrs	r3, r1
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    224e:	8a02      	ldrh	r2, [r0, #16]
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		if(rev < _SYSTEM_MCU_REVISION_D) {
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
    2250:	4313      	orrs	r3, r2
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		if(rev < _SYSTEM_MCU_REVISION_D) {
			_system_clock_inst.dfll.mul =
    2252:	4a0b      	ldr	r2, [pc, #44]	; (2280 <system_clock_source_dfll_set_config+0xa0>)
    2254:	6093      	str	r3, [r2, #8]
    2256:	e00b      	b.n	2270 <system_clock_source_dfll_set_config+0x90>
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
					_SYSTEM_NEW_DFLLMUL_CSTEP(config->coarse_max_step) |
    2258:	7b03      	ldrb	r3, [r0, #12]
    225a:	069b      	lsls	r3, r3, #26
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    225c:	8a02      	ldrh	r2, [r0, #16]
    225e:	4313      	orrs	r3, r2
    2260:	1c19      	adds	r1, r3, #0
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
					_SYSTEM_NEW_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
    2262:	89c3      	ldrh	r3, [r0, #14]
    2264:	041b      	lsls	r3, r3, #16
    2266:	4a07      	ldr	r2, [pc, #28]	; (2284 <system_clock_source_dfll_set_config+0xa4>)
    2268:	4013      	ands	r3, r2
    226a:	430b      	orrs	r3, r1
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
    226c:	4a04      	ldr	r2, [pc, #16]	; (2280 <system_clock_source_dfll_set_config+0xa0>)
    226e:	6093      	str	r3, [r2, #8]
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		}

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    2270:	4a03      	ldr	r2, [pc, #12]	; (2280 <system_clock_source_dfll_set_config+0xa0>)
    2272:	6811      	ldr	r1, [r2, #0]
    2274:	2304      	movs	r3, #4
    2276:	430b      	orrs	r3, r1
    2278:	6013      	str	r3, [r2, #0]
	}
}
    227a:	bd10      	pop	{r4, pc}
    227c:	41002000 	.word	0x41002000
    2280:	20000468 	.word	0x20000468
    2284:	03ff0000 	.word	0x03ff0000

00002288 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    2288:	2807      	cmp	r0, #7
    228a:	d803      	bhi.n	2294 <system_clock_source_enable+0xc>
    228c:	0080      	lsls	r0, r0, #2
    228e:	4b1e      	ldr	r3, [pc, #120]	; (2308 <system_clock_source_enable+0x80>)
    2290:	581b      	ldr	r3, [r3, r0]
    2292:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    2294:	2017      	movs	r0, #23
    2296:	e036      	b.n	2306 <system_clock_source_enable+0x7e>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    2298:	4a1c      	ldr	r2, [pc, #112]	; (230c <system_clock_source_enable+0x84>)
    229a:	6a11      	ldr	r1, [r2, #32]
    229c:	2302      	movs	r3, #2
    229e:	430b      	orrs	r3, r1
    22a0:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    22a2:	2000      	movs	r0, #0
    22a4:	e02f      	b.n	2306 <system_clock_source_enable+0x7e>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    22a6:	4a19      	ldr	r2, [pc, #100]	; (230c <system_clock_source_enable+0x84>)
    22a8:	6991      	ldr	r1, [r2, #24]
    22aa:	2302      	movs	r3, #2
    22ac:	430b      	orrs	r3, r1
    22ae:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    22b0:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
    22b2:	e028      	b.n	2306 <system_clock_source_enable+0x7e>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    22b4:	4a15      	ldr	r2, [pc, #84]	; (230c <system_clock_source_enable+0x84>)
    22b6:	8a11      	ldrh	r1, [r2, #16]
    22b8:	2302      	movs	r3, #2
    22ba:	430b      	orrs	r3, r1
    22bc:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    22be:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
    22c0:	e021      	b.n	2306 <system_clock_source_enable+0x7e>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    22c2:	4a12      	ldr	r2, [pc, #72]	; (230c <system_clock_source_enable+0x84>)
    22c4:	8a91      	ldrh	r1, [r2, #20]
    22c6:	2302      	movs	r3, #2
    22c8:	430b      	orrs	r3, r1
    22ca:	8293      	strh	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    22cc:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
    22ce:	e01a      	b.n	2306 <system_clock_source_enable+0x7e>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    22d0:	4b0f      	ldr	r3, [pc, #60]	; (2310 <system_clock_source_enable+0x88>)
    22d2:	6819      	ldr	r1, [r3, #0]
    22d4:	2202      	movs	r2, #2
    22d6:	430a      	orrs	r2, r1
    22d8:	601a      	str	r2, [r3, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
    22da:	681a      	ldr	r2, [r3, #0]
    22dc:	4b0d      	ldr	r3, [pc, #52]	; (2314 <system_clock_source_enable+0x8c>)
    22de:	4013      	ands	r3, r2
    22e0:	4a0a      	ldr	r2, [pc, #40]	; (230c <system_clock_source_enable+0x84>)
    22e2:	8493      	strh	r3, [r2, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    22e4:	1c11      	adds	r1, r2, #0
    22e6:	2210      	movs	r2, #16
    22e8:	68cb      	ldr	r3, [r1, #12]
    22ea:	421a      	tst	r2, r3
    22ec:	d0fc      	beq.n	22e8 <system_clock_source_enable+0x60>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    22ee:	4a08      	ldr	r2, [pc, #32]	; (2310 <system_clock_source_enable+0x88>)
    22f0:	6891      	ldr	r1, [r2, #8]
    22f2:	4b06      	ldr	r3, [pc, #24]	; (230c <system_clock_source_enable+0x84>)
    22f4:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    22f6:	6851      	ldr	r1, [r2, #4]
    22f8:	6299      	str	r1, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    22fa:	6812      	ldr	r2, [r2, #0]
    22fc:	b292      	uxth	r2, r2
    22fe:	849a      	strh	r2, [r3, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    2300:	2000      	movs	r0, #0
    2302:	e000      	b.n	2306 <system_clock_source_enable+0x7e>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    2304:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
    2306:	4770      	bx	lr
    2308:	00004f54 	.word	0x00004f54
    230c:	40000800 	.word	0x40000800
    2310:	20000468 	.word	0x20000468
    2314:	0000ff7f 	.word	0x0000ff7f

00002318 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    2318:	b5f0      	push	{r4, r5, r6, r7, lr}
    231a:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    231c:	22c2      	movs	r2, #194	; 0xc2
    231e:	00d2      	lsls	r2, r2, #3
    2320:	4b4e      	ldr	r3, [pc, #312]	; (245c <system_clock_init+0x144>)
    2322:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    2324:	494e      	ldr	r1, [pc, #312]	; (2460 <system_clock_init+0x148>)
    2326:	684b      	ldr	r3, [r1, #4]
    2328:	221e      	movs	r2, #30
    232a:	4393      	bics	r3, r2
    232c:	3a1a      	subs	r2, #26
    232e:	4313      	orrs	r3, r2
    2330:	604b      	str	r3, [r1, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    2332:	3a02      	subs	r2, #2
    2334:	ab01      	add	r3, sp, #4
    2336:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    2338:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    233a:	4d4a      	ldr	r5, [pc, #296]	; (2464 <system_clock_init+0x14c>)
    233c:	b2e0      	uxtb	r0, r4
    233e:	a901      	add	r1, sp, #4
    2340:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    2342:	3401      	adds	r4, #1
    2344:	2c1c      	cmp	r4, #28
    2346:	d1f9      	bne.n	233c <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    2348:	a80a      	add	r0, sp, #40	; 0x28
    234a:	2300      	movs	r3, #0
    234c:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
    234e:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
    2350:	2280      	movs	r2, #128	; 0x80
    2352:	0212      	lsls	r2, r2, #8
    2354:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    2356:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    2358:	2201      	movs	r2, #1
    235a:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
    235c:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
    235e:	7383      	strb	r3, [r0, #14]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    2360:	3205      	adds	r2, #5
    2362:	7042      	strb	r2, [r0, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    2364:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    2366:	4b40      	ldr	r3, [pc, #256]	; (2468 <system_clock_init+0x150>)
    2368:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    236a:	2005      	movs	r0, #5
    236c:	4b3f      	ldr	r3, [pc, #252]	; (246c <system_clock_init+0x154>)
    236e:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    2370:	493a      	ldr	r1, [pc, #232]	; (245c <system_clock_init+0x144>)
    2372:	2202      	movs	r2, #2
    2374:	68cb      	ldr	r3, [r1, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    2376:	421a      	tst	r2, r3
    2378:	d0fc      	beq.n	2374 <system_clock_init+0x5c>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
    237a:	4a38      	ldr	r2, [pc, #224]	; (245c <system_clock_init+0x144>)
    237c:	8a91      	ldrh	r1, [r2, #20]
    237e:	2380      	movs	r3, #128	; 0x80
    2380:	430b      	orrs	r3, r1
    2382:	8293      	strh	r3, [r2, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    2384:	ab05      	add	r3, sp, #20
    2386:	2100      	movs	r1, #0
    2388:	2200      	movs	r2, #0
    238a:	8059      	strh	r1, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    238c:	8099      	strh	r1, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    238e:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    2390:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    2392:	3107      	adds	r1, #7
    2394:	7219      	strb	r1, [r3, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
    2396:	3138      	adds	r1, #56	; 0x38
    2398:	8159      	strh	r1, [r3, #10]

	/* Closed loop mode */
	config->coarse_max_step = 1;
    239a:	393e      	subs	r1, #62	; 0x3e
    239c:	7319      	strb	r1, [r3, #12]
	config->fine_max_step   = 1;
    239e:	81d9      	strh	r1, [r3, #14]
	config->multiply_factor = 6; /* Multiply 8MHz by 6 to get 48MHz */
    23a0:	3105      	adds	r1, #5
    23a2:	8219      	strh	r1, [r3, #16]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    23a4:	3902      	subs	r1, #2
    23a6:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    23a8:	705a      	strb	r2, [r3, #1]
    23aa:	4b31      	ldr	r3, [pc, #196]	; (2470 <system_clock_init+0x158>)
    23ac:	699b      	ldr	r3, [r3, #24]
	   Not applicable for silicon rev C and previous*/

	/* Get MCU revision */
	uint32_t rev = system_get_device_id();

	rev &= DSU_DID_REVISION_Msk;
    23ae:	051b      	lsls	r3, r3, #20
	rev = rev >> DSU_DID_REVISION_Pos;
    23b0:	0f1b      	lsrs	r3, r3, #28

	if (rev >= _SYSTEM_MCU_REVISION_D) {
    23b2:	2b02      	cmp	r3, #2
    23b4:	d907      	bls.n	23c6 <system_clock_init+0xae>
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

		uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    23b6:	4b2f      	ldr	r3, [pc, #188]	; (2474 <system_clock_init+0x15c>)
    23b8:	681b      	ldr	r3, [r3, #0]
    23ba:	0e9b      	lsrs	r3, r3, #26
				+ (NVM_DFLL_COARSE_POS / 32))
			>> (NVM_DFLL_COARSE_POS % 32))
			& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
		/* In some revision chip, the coarse calibration value is not correct. */
		if (coarse == 0x3f) {
    23bc:	2b3f      	cmp	r3, #63	; 0x3f
    23be:	d100      	bne.n	23c2 <system_clock_init+0xaa>
			coarse = 0x1f;
    23c0:	3b20      	subs	r3, #32
		}
		dfll_conf.coarse_value = coarse;
    23c2:	aa05      	add	r2, sp, #20
    23c4:	7213      	strb	r3, [r2, #8]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    23c6:	a805      	add	r0, sp, #20
    23c8:	23b7      	movs	r3, #183	; 0xb7
    23ca:	00db      	lsls	r3, r3, #3
    23cc:	8203      	strh	r3, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    23ce:	2307      	movs	r3, #7
    23d0:	7303      	strb	r3, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    23d2:	3338      	adds	r3, #56	; 0x38
    23d4:	81c3      	strh	r3, [r0, #14]

	system_clock_source_dfll_set_config(&dfll_conf);
    23d6:	4b28      	ldr	r3, [pc, #160]	; (2478 <system_clock_init+0x160>)
    23d8:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
    23da:	a804      	add	r0, sp, #16
    23dc:	2500      	movs	r5, #0
    23de:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
    23e0:	2601      	movs	r6, #1
    23e2:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    23e4:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    23e6:	4b25      	ldr	r3, [pc, #148]	; (247c <system_clock_init+0x164>)
    23e8:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    23ea:	2006      	movs	r0, #6
    23ec:	4f1f      	ldr	r7, [pc, #124]	; (246c <system_clock_init+0x154>)
    23ee:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    23f0:	4b23      	ldr	r3, [pc, #140]	; (2480 <system_clock_init+0x168>)
    23f2:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    23f4:	ac01      	add	r4, sp, #4
    23f6:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
    23f8:	7065      	strb	r5, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    23fa:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    23fc:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    23fe:	2305      	movs	r3, #5
    2400:	7023      	strb	r3, [r4, #0]
    2402:	2001      	movs	r0, #1
    2404:	1c21      	adds	r1, r4, #0
    2406:	4b1f      	ldr	r3, [pc, #124]	; (2484 <system_clock_init+0x16c>)
    2408:	4798      	blx	r3
    240a:	2001      	movs	r0, #1
    240c:	4b1e      	ldr	r3, [pc, #120]	; (2488 <system_clock_init+0x170>)
    240e:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    2410:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    2412:	2000      	movs	r0, #0
    2414:	1c21      	adds	r1, r4, #0
    2416:	4b13      	ldr	r3, [pc, #76]	; (2464 <system_clock_init+0x14c>)
    2418:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    241a:	2000      	movs	r0, #0
    241c:	4b1b      	ldr	r3, [pc, #108]	; (248c <system_clock_init+0x174>)
    241e:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    2420:	2007      	movs	r0, #7
    2422:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    2424:	490d      	ldr	r1, [pc, #52]	; (245c <system_clock_init+0x144>)
    2426:	22d0      	movs	r2, #208	; 0xd0
    2428:	68cb      	ldr	r3, [r1, #12]
    242a:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    242c:	2bd0      	cmp	r3, #208	; 0xd0
    242e:	d1fb      	bne.n	2428 <system_clock_init+0x110>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    2430:	4a17      	ldr	r2, [pc, #92]	; (2490 <system_clock_init+0x178>)
    2432:	2300      	movs	r3, #0
    2434:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    2436:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    2438:	7293      	strb	r3, [r2, #10]
			break;
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    243a:	72d3      	strb	r3, [r2, #11]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    243c:	a901      	add	r1, sp, #4
    243e:	2201      	movs	r2, #1
    2440:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    2442:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    2444:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    2446:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    2448:	3307      	adds	r3, #7
    244a:	700b      	strb	r3, [r1, #0]
    244c:	2000      	movs	r0, #0
    244e:	4b0d      	ldr	r3, [pc, #52]	; (2484 <system_clock_init+0x16c>)
    2450:	4798      	blx	r3
    2452:	2000      	movs	r0, #0
    2454:	4b0c      	ldr	r3, [pc, #48]	; (2488 <system_clock_init+0x170>)
    2456:	4798      	blx	r3
#endif
}
    2458:	b00f      	add	sp, #60	; 0x3c
    245a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    245c:	40000800 	.word	0x40000800
    2460:	41004000 	.word	0x41004000
    2464:	000026cd 	.word	0x000026cd
    2468:	00002109 	.word	0x00002109
    246c:	00002289 	.word	0x00002289
    2470:	41002000 	.word	0x41002000
    2474:	00806024 	.word	0x00806024
    2478:	000021e1 	.word	0x000021e1
    247c:	000020cd 	.word	0x000020cd
    2480:	00002495 	.word	0x00002495
    2484:	000024b9 	.word	0x000024b9
    2488:	00002571 	.word	0x00002571
    248c:	00002641 	.word	0x00002641
    2490:	40000400 	.word	0x40000400

00002494 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    2494:	4a06      	ldr	r2, [pc, #24]	; (24b0 <system_gclk_init+0x1c>)
    2496:	6991      	ldr	r1, [r2, #24]
    2498:	2308      	movs	r3, #8
    249a:	430b      	orrs	r3, r1
    249c:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    249e:	2201      	movs	r2, #1
    24a0:	4b04      	ldr	r3, [pc, #16]	; (24b4 <system_gclk_init+0x20>)
    24a2:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    24a4:	1c19      	adds	r1, r3, #0
    24a6:	780b      	ldrb	r3, [r1, #0]
    24a8:	4213      	tst	r3, r2
    24aa:	d1fc      	bne.n	24a6 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    24ac:	4770      	bx	lr
    24ae:	46c0      	nop			; (mov r8, r8)
    24b0:	40000400 	.word	0x40000400
    24b4:	40000c00 	.word	0x40000c00

000024b8 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    24b8:	b570      	push	{r4, r5, r6, lr}
    24ba:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    24bc:	1c04      	adds	r4, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    24be:	780d      	ldrb	r5, [r1, #0]
    24c0:	022d      	lsls	r5, r5, #8
    24c2:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    24c4:	784b      	ldrb	r3, [r1, #1]
    24c6:	2b00      	cmp	r3, #0
    24c8:	d002      	beq.n	24d0 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    24ca:	2380      	movs	r3, #128	; 0x80
    24cc:	02db      	lsls	r3, r3, #11
    24ce:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    24d0:	7a4b      	ldrb	r3, [r1, #9]
    24d2:	2b00      	cmp	r3, #0
    24d4:	d002      	beq.n	24dc <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    24d6:	2380      	movs	r3, #128	; 0x80
    24d8:	031b      	lsls	r3, r3, #12
    24da:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    24dc:	6848      	ldr	r0, [r1, #4]
    24de:	2801      	cmp	r0, #1
    24e0:	d918      	bls.n	2514 <system_gclk_gen_set_config+0x5c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    24e2:	1e43      	subs	r3, r0, #1
    24e4:	4218      	tst	r0, r3
    24e6:	d110      	bne.n	250a <system_gclk_gen_set_config+0x52>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    24e8:	2802      	cmp	r0, #2
    24ea:	d906      	bls.n	24fa <system_gclk_gen_set_config+0x42>
    24ec:	2302      	movs	r3, #2
    24ee:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    24f0:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    24f2:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    24f4:	4298      	cmp	r0, r3
    24f6:	d8fb      	bhi.n	24f0 <system_gclk_gen_set_config+0x38>
    24f8:	e000      	b.n	24fc <system_gclk_gen_set_config+0x44>
    24fa:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    24fc:	0212      	lsls	r2, r2, #8
    24fe:	4332      	orrs	r2, r6
    2500:	1c14      	adds	r4, r2, #0
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    2502:	2380      	movs	r3, #128	; 0x80
    2504:	035b      	lsls	r3, r3, #13
    2506:	431d      	orrs	r5, r3
    2508:	e004      	b.n	2514 <system_gclk_gen_set_config+0x5c>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    250a:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    250c:	4334      	orrs	r4, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    250e:	2380      	movs	r3, #128	; 0x80
    2510:	029b      	lsls	r3, r3, #10
    2512:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    2514:	7a0b      	ldrb	r3, [r1, #8]
    2516:	2b00      	cmp	r3, #0
    2518:	d002      	beq.n	2520 <system_gclk_gen_set_config+0x68>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    251a:	2380      	movs	r3, #128	; 0x80
    251c:	039b      	lsls	r3, r3, #14
    251e:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2520:	4a0f      	ldr	r2, [pc, #60]	; (2560 <system_gclk_gen_set_config+0xa8>)
    2522:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    2524:	b25b      	sxtb	r3, r3
    2526:	2b00      	cmp	r3, #0
    2528:	dbfb      	blt.n	2522 <system_gclk_gen_set_config+0x6a>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    252a:	4b0e      	ldr	r3, [pc, #56]	; (2564 <system_gclk_gen_set_config+0xac>)
    252c:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    252e:	4b0e      	ldr	r3, [pc, #56]	; (2568 <system_gclk_gen_set_config+0xb0>)
    2530:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2532:	4a0b      	ldr	r2, [pc, #44]	; (2560 <system_gclk_gen_set_config+0xa8>)
    2534:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    2536:	b25b      	sxtb	r3, r3
    2538:	2b00      	cmp	r3, #0
    253a:	dbfb      	blt.n	2534 <system_gclk_gen_set_config+0x7c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    253c:	4b08      	ldr	r3, [pc, #32]	; (2560 <system_gclk_gen_set_config+0xa8>)
    253e:	609c      	str	r4, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2540:	1c1a      	adds	r2, r3, #0
    2542:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    2544:	b25b      	sxtb	r3, r3
    2546:	2b00      	cmp	r3, #0
    2548:	dbfb      	blt.n	2542 <system_gclk_gen_set_config+0x8a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    254a:	4a05      	ldr	r2, [pc, #20]	; (2560 <system_gclk_gen_set_config+0xa8>)
    254c:	6851      	ldr	r1, [r2, #4]
    254e:	2380      	movs	r3, #128	; 0x80
    2550:	025b      	lsls	r3, r3, #9
    2552:	400b      	ands	r3, r1
    2554:	431d      	orrs	r5, r3
    2556:	6055      	str	r5, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    2558:	4b04      	ldr	r3, [pc, #16]	; (256c <system_gclk_gen_set_config+0xb4>)
    255a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    255c:	bd70      	pop	{r4, r5, r6, pc}
    255e:	46c0      	nop			; (mov r8, r8)
    2560:	40000c00 	.word	0x40000c00
    2564:	00000e89 	.word	0x00000e89
    2568:	40000c08 	.word	0x40000c08
    256c:	00000ec9 	.word	0x00000ec9

00002570 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    2570:	b510      	push	{r4, lr}
    2572:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2574:	4a0b      	ldr	r2, [pc, #44]	; (25a4 <system_gclk_gen_enable+0x34>)
    2576:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    2578:	b25b      	sxtb	r3, r3
    257a:	2b00      	cmp	r3, #0
    257c:	dbfb      	blt.n	2576 <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    257e:	4b0a      	ldr	r3, [pc, #40]	; (25a8 <system_gclk_gen_enable+0x38>)
    2580:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    2582:	4b0a      	ldr	r3, [pc, #40]	; (25ac <system_gclk_gen_enable+0x3c>)
    2584:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2586:	4a07      	ldr	r2, [pc, #28]	; (25a4 <system_gclk_gen_enable+0x34>)
    2588:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    258a:	b25b      	sxtb	r3, r3
    258c:	2b00      	cmp	r3, #0
    258e:	dbfb      	blt.n	2588 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    2590:	4a04      	ldr	r2, [pc, #16]	; (25a4 <system_gclk_gen_enable+0x34>)
    2592:	6853      	ldr	r3, [r2, #4]
    2594:	2180      	movs	r1, #128	; 0x80
    2596:	0249      	lsls	r1, r1, #9
    2598:	430b      	orrs	r3, r1
    259a:	6053      	str	r3, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    259c:	4b04      	ldr	r3, [pc, #16]	; (25b0 <system_gclk_gen_enable+0x40>)
    259e:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    25a0:	bd10      	pop	{r4, pc}
    25a2:	46c0      	nop			; (mov r8, r8)
    25a4:	40000c00 	.word	0x40000c00
    25a8:	00000e89 	.word	0x00000e89
    25ac:	40000c04 	.word	0x40000c04
    25b0:	00000ec9 	.word	0x00000ec9

000025b4 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    25b4:	b570      	push	{r4, r5, r6, lr}
    25b6:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    25b8:	4a1a      	ldr	r2, [pc, #104]	; (2624 <system_gclk_gen_get_hz+0x70>)
    25ba:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    25bc:	b25b      	sxtb	r3, r3
    25be:	2b00      	cmp	r3, #0
    25c0:	dbfb      	blt.n	25ba <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    25c2:	4b19      	ldr	r3, [pc, #100]	; (2628 <system_gclk_gen_get_hz+0x74>)
    25c4:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    25c6:	4b19      	ldr	r3, [pc, #100]	; (262c <system_gclk_gen_get_hz+0x78>)
    25c8:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    25ca:	4a16      	ldr	r2, [pc, #88]	; (2624 <system_gclk_gen_get_hz+0x70>)
    25cc:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    25ce:	b25b      	sxtb	r3, r3
    25d0:	2b00      	cmp	r3, #0
    25d2:	dbfb      	blt.n	25cc <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    25d4:	4e13      	ldr	r6, [pc, #76]	; (2624 <system_gclk_gen_get_hz+0x70>)
    25d6:	6870      	ldr	r0, [r6, #4]
    25d8:	04c0      	lsls	r0, r0, #19
    25da:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    25dc:	4b14      	ldr	r3, [pc, #80]	; (2630 <system_gclk_gen_get_hz+0x7c>)
    25de:	4798      	blx	r3
    25e0:	1c05      	adds	r5, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    25e2:	4b12      	ldr	r3, [pc, #72]	; (262c <system_gclk_gen_get_hz+0x78>)
    25e4:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    25e6:	6876      	ldr	r6, [r6, #4]
    25e8:	02f6      	lsls	r6, r6, #11
    25ea:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    25ec:	4b11      	ldr	r3, [pc, #68]	; (2634 <system_gclk_gen_get_hz+0x80>)
    25ee:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    25f0:	4a0c      	ldr	r2, [pc, #48]	; (2624 <system_gclk_gen_get_hz+0x70>)
    25f2:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
    25f4:	b25b      	sxtb	r3, r3
    25f6:	2b00      	cmp	r3, #0
    25f8:	dbfb      	blt.n	25f2 <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    25fa:	4b0a      	ldr	r3, [pc, #40]	; (2624 <system_gclk_gen_get_hz+0x70>)
    25fc:	689c      	ldr	r4, [r3, #8]
    25fe:	0a24      	lsrs	r4, r4, #8
    2600:	b2a4      	uxth	r4, r4
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    2602:	4b0d      	ldr	r3, [pc, #52]	; (2638 <system_gclk_gen_get_hz+0x84>)
    2604:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    2606:	2e00      	cmp	r6, #0
    2608:	d107      	bne.n	261a <system_gclk_gen_get_hz+0x66>
    260a:	2c01      	cmp	r4, #1
    260c:	d907      	bls.n	261e <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    260e:	1c28      	adds	r0, r5, #0
    2610:	1c21      	adds	r1, r4, #0
    2612:	4b0a      	ldr	r3, [pc, #40]	; (263c <system_gclk_gen_get_hz+0x88>)
    2614:	4798      	blx	r3
    2616:	1c05      	adds	r5, r0, #0
    2618:	e001      	b.n	261e <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    261a:	3401      	adds	r4, #1
    261c:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    261e:	1c28      	adds	r0, r5, #0
    2620:	bd70      	pop	{r4, r5, r6, pc}
    2622:	46c0      	nop			; (mov r8, r8)
    2624:	40000c00 	.word	0x40000c00
    2628:	00000e89 	.word	0x00000e89
    262c:	40000c04 	.word	0x40000c04
    2630:	0000204d 	.word	0x0000204d
    2634:	40000c08 	.word	0x40000c08
    2638:	00000ec9 	.word	0x00000ec9
    263c:	00004aa9 	.word	0x00004aa9

00002640 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    2640:	b510      	push	{r4, lr}
    2642:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    2644:	4b06      	ldr	r3, [pc, #24]	; (2660 <system_gclk_chan_enable+0x20>)
    2646:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2648:	4b06      	ldr	r3, [pc, #24]	; (2664 <system_gclk_chan_enable+0x24>)
    264a:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    264c:	4a06      	ldr	r2, [pc, #24]	; (2668 <system_gclk_chan_enable+0x28>)
    264e:	8851      	ldrh	r1, [r2, #2]
    2650:	2380      	movs	r3, #128	; 0x80
    2652:	01db      	lsls	r3, r3, #7
    2654:	430b      	orrs	r3, r1
    2656:	8053      	strh	r3, [r2, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    2658:	4b04      	ldr	r3, [pc, #16]	; (266c <system_gclk_chan_enable+0x2c>)
    265a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    265c:	bd10      	pop	{r4, pc}
    265e:	46c0      	nop			; (mov r8, r8)
    2660:	00000e89 	.word	0x00000e89
    2664:	40000c02 	.word	0x40000c02
    2668:	40000c00 	.word	0x40000c00
    266c:	00000ec9 	.word	0x00000ec9

00002670 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    2670:	b510      	push	{r4, lr}
    2672:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    2674:	4b0f      	ldr	r3, [pc, #60]	; (26b4 <system_gclk_chan_disable+0x44>)
    2676:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2678:	4b0f      	ldr	r3, [pc, #60]	; (26b8 <system_gclk_chan_disable+0x48>)
    267a:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    267c:	4b0f      	ldr	r3, [pc, #60]	; (26bc <system_gclk_chan_disable+0x4c>)
    267e:	885a      	ldrh	r2, [r3, #2]
    2680:	0512      	lsls	r2, r2, #20
    2682:	0f10      	lsrs	r0, r2, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    2684:	8859      	ldrh	r1, [r3, #2]
    2686:	4a0e      	ldr	r2, [pc, #56]	; (26c0 <system_gclk_chan_disable+0x50>)
    2688:	400a      	ands	r2, r1
    268a:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    268c:	8859      	ldrh	r1, [r3, #2]
    268e:	4a0d      	ldr	r2, [pc, #52]	; (26c4 <system_gclk_chan_disable+0x54>)
    2690:	400a      	ands	r2, r1
    2692:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    2694:	1c19      	adds	r1, r3, #0
    2696:	2280      	movs	r2, #128	; 0x80
    2698:	01d2      	lsls	r2, r2, #7
    269a:	884b      	ldrh	r3, [r1, #2]
    269c:	4213      	tst	r3, r2
    269e:	d1fc      	bne.n	269a <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    26a0:	4906      	ldr	r1, [pc, #24]	; (26bc <system_gclk_chan_disable+0x4c>)
    26a2:	0202      	lsls	r2, r0, #8
    26a4:	8848      	ldrh	r0, [r1, #2]
    26a6:	4b06      	ldr	r3, [pc, #24]	; (26c0 <system_gclk_chan_disable+0x50>)
    26a8:	4003      	ands	r3, r0
    26aa:	4313      	orrs	r3, r2
    26ac:	804b      	strh	r3, [r1, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    26ae:	4b06      	ldr	r3, [pc, #24]	; (26c8 <system_gclk_chan_disable+0x58>)
    26b0:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    26b2:	bd10      	pop	{r4, pc}
    26b4:	00000e89 	.word	0x00000e89
    26b8:	40000c02 	.word	0x40000c02
    26bc:	40000c00 	.word	0x40000c00
    26c0:	fffff0ff 	.word	0xfffff0ff
    26c4:	ffffbfff 	.word	0xffffbfff
    26c8:	00000ec9 	.word	0x00000ec9

000026cc <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    26cc:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    26ce:	780c      	ldrb	r4, [r1, #0]
    26d0:	0224      	lsls	r4, r4, #8
    26d2:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    26d4:	4b02      	ldr	r3, [pc, #8]	; (26e0 <system_gclk_chan_set_config+0x14>)
    26d6:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    26d8:	b2a4      	uxth	r4, r4
    26da:	4b02      	ldr	r3, [pc, #8]	; (26e4 <system_gclk_chan_set_config+0x18>)
    26dc:	805c      	strh	r4, [r3, #2]
}
    26de:	bd10      	pop	{r4, pc}
    26e0:	00002671 	.word	0x00002671
    26e4:	40000c00 	.word	0x40000c00

000026e8 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    26e8:	b510      	push	{r4, lr}
    26ea:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    26ec:	4b06      	ldr	r3, [pc, #24]	; (2708 <system_gclk_chan_get_hz+0x20>)
    26ee:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    26f0:	4b06      	ldr	r3, [pc, #24]	; (270c <system_gclk_chan_get_hz+0x24>)
    26f2:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    26f4:	4b06      	ldr	r3, [pc, #24]	; (2710 <system_gclk_chan_get_hz+0x28>)
    26f6:	885c      	ldrh	r4, [r3, #2]
    26f8:	0524      	lsls	r4, r4, #20
    26fa:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    26fc:	4b05      	ldr	r3, [pc, #20]	; (2714 <system_gclk_chan_get_hz+0x2c>)
    26fe:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    2700:	1c20      	adds	r0, r4, #0
    2702:	4b05      	ldr	r3, [pc, #20]	; (2718 <system_gclk_chan_get_hz+0x30>)
    2704:	4798      	blx	r3
}
    2706:	bd10      	pop	{r4, pc}
    2708:	00000e89 	.word	0x00000e89
    270c:	40000c02 	.word	0x40000c02
    2710:	40000c00 	.word	0x40000c00
    2714:	00000ec9 	.word	0x00000ec9
    2718:	000025b5 	.word	0x000025b5

0000271c <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    271c:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    271e:	78d3      	ldrb	r3, [r2, #3]
    2720:	2b00      	cmp	r3, #0
    2722:	d11e      	bne.n	2762 <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    2724:	7814      	ldrb	r4, [r2, #0]
    2726:	2c80      	cmp	r4, #128	; 0x80
    2728:	d004      	beq.n	2734 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    272a:	0624      	lsls	r4, r4, #24
    272c:	2380      	movs	r3, #128	; 0x80
    272e:	025b      	lsls	r3, r3, #9
    2730:	431c      	orrs	r4, r3
    2732:	e000      	b.n	2736 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    2734:	2400      	movs	r4, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    2736:	7853      	ldrb	r3, [r2, #1]
    2738:	2502      	movs	r5, #2
    273a:	43ab      	bics	r3, r5
    273c:	d10a      	bne.n	2754 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    273e:	7893      	ldrb	r3, [r2, #2]
    2740:	2b00      	cmp	r3, #0
    2742:	d103      	bne.n	274c <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    2744:	2380      	movs	r3, #128	; 0x80
    2746:	029b      	lsls	r3, r3, #10
    2748:	431c      	orrs	r4, r3
    274a:	e002      	b.n	2752 <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    274c:	23c0      	movs	r3, #192	; 0xc0
    274e:	02db      	lsls	r3, r3, #11
    2750:	431c      	orrs	r4, r3
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    2752:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    2754:	7853      	ldrb	r3, [r2, #1]
    2756:	3b01      	subs	r3, #1
    2758:	2b01      	cmp	r3, #1
    275a:	d812      	bhi.n	2782 <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    275c:	4b18      	ldr	r3, [pc, #96]	; (27c0 <_system_pinmux_config+0xa4>)
    275e:	401c      	ands	r4, r3
    2760:	e00f      	b.n	2782 <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    2762:	6041      	str	r1, [r0, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    2764:	040b      	lsls	r3, r1, #16
    2766:	0c1b      	lsrs	r3, r3, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    2768:	24a0      	movs	r4, #160	; 0xa0
    276a:	05e4      	lsls	r4, r4, #23
    276c:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    276e:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    2770:	0c0b      	lsrs	r3, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    2772:	24d0      	movs	r4, #208	; 0xd0
    2774:	0624      	lsls	r4, r4, #24
    2776:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    2778:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    277a:	78d3      	ldrb	r3, [r2, #3]
    277c:	2b00      	cmp	r3, #0
    277e:	d018      	beq.n	27b2 <_system_pinmux_config+0x96>
    2780:	e01c      	b.n	27bc <_system_pinmux_config+0xa0>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    2782:	040b      	lsls	r3, r1, #16
    2784:	0c1b      	lsrs	r3, r3, #16
    2786:	25a0      	movs	r5, #160	; 0xa0
    2788:	05ed      	lsls	r5, r5, #23
    278a:	432b      	orrs	r3, r5

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    278c:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    278e:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    2790:	0c0b      	lsrs	r3, r1, #16
    2792:	25d0      	movs	r5, #208	; 0xd0
    2794:	062d      	lsls	r5, r5, #24
    2796:	432b      	orrs	r3, r5

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    2798:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    279a:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    279c:	78d3      	ldrb	r3, [r2, #3]
    279e:	2b00      	cmp	r3, #0
    27a0:	d10c      	bne.n	27bc <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    27a2:	0363      	lsls	r3, r4, #13
    27a4:	d505      	bpl.n	27b2 <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    27a6:	7893      	ldrb	r3, [r2, #2]
    27a8:	2b01      	cmp	r3, #1
    27aa:	d101      	bne.n	27b0 <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
    27ac:	6181      	str	r1, [r0, #24]
    27ae:	e000      	b.n	27b2 <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
    27b0:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    27b2:	7853      	ldrb	r3, [r2, #1]
    27b4:	3b01      	subs	r3, #1
    27b6:	2b01      	cmp	r3, #1
    27b8:	d800      	bhi.n	27bc <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    27ba:	6081      	str	r1, [r0, #8]
		}
	}
}
    27bc:	bd30      	pop	{r4, r5, pc}
    27be:	46c0      	nop			; (mov r8, r8)
    27c0:	fffbffff 	.word	0xfffbffff

000027c4 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    27c4:	b508      	push	{r3, lr}
    27c6:	1c03      	adds	r3, r0, #0
    27c8:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    27ca:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    27cc:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    27ce:	2900      	cmp	r1, #0
    27d0:	d104      	bne.n	27dc <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
    27d2:	0958      	lsrs	r0, r3, #5
    27d4:	01c0      	lsls	r0, r0, #7
    27d6:	4905      	ldr	r1, [pc, #20]	; (27ec <system_pinmux_pin_set_config+0x28>)
    27d8:	468c      	mov	ip, r1
    27da:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    27dc:	211f      	movs	r1, #31
    27de:	400b      	ands	r3, r1
    27e0:	391e      	subs	r1, #30
    27e2:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    27e4:	4b02      	ldr	r3, [pc, #8]	; (27f0 <system_pinmux_pin_set_config+0x2c>)
    27e6:	4798      	blx	r3
}
    27e8:	bd08      	pop	{r3, pc}
    27ea:	46c0      	nop			; (mov r8, r8)
    27ec:	41004400 	.word	0x41004400
    27f0:	0000271d 	.word	0x0000271d

000027f4 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    27f4:	4770      	bx	lr
    27f6:	46c0      	nop			; (mov r8, r8)

000027f8 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    27f8:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    27fa:	4b05      	ldr	r3, [pc, #20]	; (2810 <system_init+0x18>)
    27fc:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    27fe:	4b05      	ldr	r3, [pc, #20]	; (2814 <system_init+0x1c>)
    2800:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    2802:	4b05      	ldr	r3, [pc, #20]	; (2818 <system_init+0x20>)
    2804:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    2806:	4b05      	ldr	r3, [pc, #20]	; (281c <system_init+0x24>)
    2808:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    280a:	4b05      	ldr	r3, [pc, #20]	; (2820 <system_init+0x28>)
    280c:	4798      	blx	r3
}
    280e:	bd08      	pop	{r3, pc}
    2810:	00002319 	.word	0x00002319
    2814:	00000ef9 	.word	0x00000ef9
    2818:	000027f5 	.word	0x000027f5
    281c:	000027f5 	.word	0x000027f5
    2820:	000027f5 	.word	0x000027f5

00002824 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
    2824:	e7fe      	b.n	2824 <Dummy_Handler>
    2826:	46c0      	nop			; (mov r8, r8)

00002828 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    2828:	b510      	push	{r4, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    282a:	4b1d      	ldr	r3, [pc, #116]	; (28a0 <Reset_Handler+0x78>)
    282c:	4a1d      	ldr	r2, [pc, #116]	; (28a4 <Reset_Handler+0x7c>)
    282e:	429a      	cmp	r2, r3
    2830:	d003      	beq.n	283a <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
    2832:	4b1d      	ldr	r3, [pc, #116]	; (28a8 <Reset_Handler+0x80>)
    2834:	4a1a      	ldr	r2, [pc, #104]	; (28a0 <Reset_Handler+0x78>)
    2836:	429a      	cmp	r2, r3
    2838:	d304      	bcc.n	2844 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    283a:	4b1c      	ldr	r3, [pc, #112]	; (28ac <Reset_Handler+0x84>)
    283c:	4a1c      	ldr	r2, [pc, #112]	; (28b0 <Reset_Handler+0x88>)
    283e:	429a      	cmp	r2, r3
    2840:	d310      	bcc.n	2864 <Reset_Handler+0x3c>
    2842:	e01e      	b.n	2882 <Reset_Handler+0x5a>
    2844:	4a1b      	ldr	r2, [pc, #108]	; (28b4 <Reset_Handler+0x8c>)
    2846:	4b18      	ldr	r3, [pc, #96]	; (28a8 <Reset_Handler+0x80>)
    2848:	3303      	adds	r3, #3
    284a:	1a9b      	subs	r3, r3, r2
    284c:	089b      	lsrs	r3, r3, #2
    284e:	3301      	adds	r3, #1
    2850:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    2852:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    2854:	4812      	ldr	r0, [pc, #72]	; (28a0 <Reset_Handler+0x78>)
    2856:	4913      	ldr	r1, [pc, #76]	; (28a4 <Reset_Handler+0x7c>)
    2858:	588c      	ldr	r4, [r1, r2]
    285a:	5084      	str	r4, [r0, r2]
    285c:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    285e:	429a      	cmp	r2, r3
    2860:	d1fa      	bne.n	2858 <Reset_Handler+0x30>
    2862:	e7ea      	b.n	283a <Reset_Handler+0x12>
    2864:	4a14      	ldr	r2, [pc, #80]	; (28b8 <Reset_Handler+0x90>)
    2866:	4b11      	ldr	r3, [pc, #68]	; (28ac <Reset_Handler+0x84>)
    2868:	3303      	adds	r3, #3
    286a:	1a9b      	subs	r3, r3, r2
    286c:	089b      	lsrs	r3, r3, #2
    286e:	3301      	adds	r3, #1
    2870:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    2872:	2200      	movs	r2, #0
                *pDest++ = 0;
    2874:	480e      	ldr	r0, [pc, #56]	; (28b0 <Reset_Handler+0x88>)
    2876:	2100      	movs	r1, #0
    2878:	1814      	adds	r4, r2, r0
    287a:	6021      	str	r1, [r4, #0]
    287c:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    287e:	429a      	cmp	r2, r3
    2880:	d1fa      	bne.n	2878 <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    2882:	4a0e      	ldr	r2, [pc, #56]	; (28bc <Reset_Handler+0x94>)
    2884:	21ff      	movs	r1, #255	; 0xff
    2886:	4b0e      	ldr	r3, [pc, #56]	; (28c0 <Reset_Handler+0x98>)
    2888:	438b      	bics	r3, r1
    288a:	6093      	str	r3, [r2, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    288c:	4a0d      	ldr	r2, [pc, #52]	; (28c4 <Reset_Handler+0x9c>)
    288e:	6851      	ldr	r1, [r2, #4]
    2890:	2380      	movs	r3, #128	; 0x80
    2892:	430b      	orrs	r3, r1
    2894:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    2896:	4b0c      	ldr	r3, [pc, #48]	; (28c8 <Reset_Handler+0xa0>)
    2898:	4798      	blx	r3

        /* Branch to main function */
        main();
    289a:	4b0c      	ldr	r3, [pc, #48]	; (28cc <Reset_Handler+0xa4>)
    289c:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    289e:	e7fe      	b.n	289e <Reset_Handler+0x76>
    28a0:	20000000 	.word	0x20000000
    28a4:	00005054 	.word	0x00005054
    28a8:	20000024 	.word	0x20000024
    28ac:	20004148 	.word	0x20004148
    28b0:	20000024 	.word	0x20000024
    28b4:	20000004 	.word	0x20000004
    28b8:	20000028 	.word	0x20000028
    28bc:	e000ed00 	.word	0xe000ed00
    28c0:	00000000 	.word	0x00000000
    28c4:	41004000 	.word	0x41004000
    28c8:	00004c21 	.word	0x00004c21
    28cc:	00004a31 	.word	0x00004a31

000028d0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28d0:	1c03      	adds	r3, r0, #0
    28d2:	3308      	adds	r3, #8
    28d4:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    28d6:	2201      	movs	r2, #1
    28d8:	4252      	negs	r2, r2
    28da:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28dc:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28de:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    28e0:	2300      	movs	r3, #0
    28e2:	6003      	str	r3, [r0, #0]
}
    28e4:	4770      	bx	lr
    28e6:	46c0      	nop			; (mov r8, r8)

000028e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    28e8:	2300      	movs	r3, #0
    28ea:	6103      	str	r3, [r0, #16]
}
    28ec:	4770      	bx	lr
    28ee:	46c0      	nop			; (mov r8, r8)

000028f0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
    28f0:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    28f2:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    28f4:	689a      	ldr	r2, [r3, #8]
    28f6:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    28f8:	689a      	ldr	r2, [r3, #8]
    28fa:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
    28fc:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    28fe:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
    2900:	6803      	ldr	r3, [r0, #0]
    2902:	3301      	adds	r3, #1
    2904:	6003      	str	r3, [r0, #0]
}
    2906:	4770      	bx	lr

00002908 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2908:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    290a:	680c      	ldr	r4, [r1, #0]
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    290c:	1c02      	adds	r2, r0, #0
    290e:	3208      	adds	r2, #8
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2910:	1c63      	adds	r3, r4, #1
    2912:	d102      	bne.n	291a <vListInsert+0x12>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2914:	6902      	ldr	r2, [r0, #16]
    2916:	e004      	b.n	2922 <vListInsert+0x1a>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2918:	1c1a      	adds	r2, r3, #0
    291a:	6853      	ldr	r3, [r2, #4]
    291c:	681d      	ldr	r5, [r3, #0]
    291e:	42ac      	cmp	r4, r5
    2920:	d2fa      	bcs.n	2918 <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2922:	6853      	ldr	r3, [r2, #4]
    2924:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2926:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    2928:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
    292a:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    292c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
    292e:	6803      	ldr	r3, [r0, #0]
    2930:	3301      	adds	r3, #1
    2932:	6003      	str	r3, [r0, #0]
}
    2934:	bd30      	pop	{r4, r5, pc}
    2936:	46c0      	nop			; (mov r8, r8)

00002938 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2938:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    293a:	6842      	ldr	r2, [r0, #4]
    293c:	6881      	ldr	r1, [r0, #8]
    293e:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2940:	6882      	ldr	r2, [r0, #8]
    2942:	6841      	ldr	r1, [r0, #4]
    2944:	6051      	str	r1, [r2, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2946:	685a      	ldr	r2, [r3, #4]
    2948:	4282      	cmp	r2, r0
    294a:	d101      	bne.n	2950 <uxListRemove+0x18>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    294c:	6892      	ldr	r2, [r2, #8]
    294e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2950:	2200      	movs	r2, #0
    2952:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
    2954:	681a      	ldr	r2, [r3, #0]
    2956:	1e50      	subs	r0, r2, #1
    2958:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
    295a:	4770      	bx	lr

0000295c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    295c:	4b03      	ldr	r3, [pc, #12]	; (296c <prvTaskExitError+0x10>)
    295e:	681b      	ldr	r3, [r3, #0]
    2960:	3301      	adds	r3, #1
    2962:	d001      	beq.n	2968 <prvTaskExitError+0xc>
    2964:	b672      	cpsid	i
    2966:	e7fe      	b.n	2966 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
    2968:	b672      	cpsid	i
	for( ;; );
    296a:	e7fe      	b.n	296a <prvTaskExitError+0xe>
    296c:	20000018 	.word	0x20000018

00002970 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    2970:	4a06      	ldr	r2, [pc, #24]	; (298c <pxCurrentTCBConst2>)
    2972:	6813      	ldr	r3, [r2, #0]
    2974:	6818      	ldr	r0, [r3, #0]
    2976:	3020      	adds	r0, #32
    2978:	f380 8809 	msr	PSP, r0
    297c:	2002      	movs	r0, #2
    297e:	f380 8814 	msr	CONTROL, r0
    2982:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    2984:	46ae      	mov	lr, r5
    2986:	b662      	cpsie	i
    2988:	bd00      	pop	{pc}
    298a:	46c0      	nop			; (mov r8, r8)

0000298c <pxCurrentTCBConst2>:
    298c:	20003fd0 	.word	0x20003fd0

00002990 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2990:	b510      	push	{r4, lr}
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    2992:	1f03      	subs	r3, r0, #4
    2994:	2480      	movs	r4, #128	; 0x80
    2996:	0464      	lsls	r4, r4, #17
    2998:	601c      	str	r4, [r3, #0]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
    299a:	3b04      	subs	r3, #4
    299c:	6019      	str	r1, [r3, #0]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    299e:	3b04      	subs	r3, #4
    29a0:	4902      	ldr	r1, [pc, #8]	; (29ac <pxPortInitialiseStack+0x1c>)
    29a2:	6019      	str	r1, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    29a4:	3b14      	subs	r3, #20
    29a6:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
    29a8:	3840      	subs	r0, #64	; 0x40

	return pxTopOfStack;
}
    29aa:	bd10      	pop	{r4, pc}
    29ac:	0000295d 	.word	0x0000295d

000029b0 <SVC_Handler>:

void vPortSVCHandler( void )
{
	/* This function is no longer used, but retained for backward
	compatibility. */
}
    29b0:	4770      	bx	lr
    29b2:	46c0      	nop			; (mov r8, r8)

000029b4 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    29b4:	2280      	movs	r2, #128	; 0x80
    29b6:	0552      	lsls	r2, r2, #21
    29b8:	4b03      	ldr	r3, [pc, #12]	; (29c8 <vPortYield+0x14>)
    29ba:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
    29bc:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    29c0:	f3bf 8f6f 	isb	sy
}
    29c4:	4770      	bx	lr
    29c6:	46c0      	nop			; (mov r8, r8)
    29c8:	e000ed04 	.word	0xe000ed04

000029cc <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
    29cc:	b672      	cpsid	i
    uxCriticalNesting++;
    29ce:	4a04      	ldr	r2, [pc, #16]	; (29e0 <vPortEnterCritical+0x14>)
    29d0:	6813      	ldr	r3, [r2, #0]
    29d2:	3301      	adds	r3, #1
    29d4:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
    29d6:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    29da:	f3bf 8f6f 	isb	sy
}
    29de:	4770      	bx	lr
    29e0:	20000018 	.word	0x20000018

000029e4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
    29e4:	4b06      	ldr	r3, [pc, #24]	; (2a00 <vPortExitCritical+0x1c>)
    29e6:	681b      	ldr	r3, [r3, #0]
    29e8:	2b00      	cmp	r3, #0
    29ea:	d101      	bne.n	29f0 <vPortExitCritical+0xc>
    29ec:	b672      	cpsid	i
    29ee:	e7fe      	b.n	29ee <vPortExitCritical+0xa>
    uxCriticalNesting--;
    29f0:	3b01      	subs	r3, #1
    29f2:	4a03      	ldr	r2, [pc, #12]	; (2a00 <vPortExitCritical+0x1c>)
    29f4:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
    29f6:	2b00      	cmp	r3, #0
    29f8:	d100      	bne.n	29fc <vPortExitCritical+0x18>
    {
        portENABLE_INTERRUPTS();
    29fa:	b662      	cpsie	i
    }
}
    29fc:	4770      	bx	lr
    29fe:	46c0      	nop			; (mov r8, r8)
    2a00:	20000018 	.word	0x20000018

00002a04 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
    2a04:	f3ef 8010 	mrs	r0, PRIMASK
    2a08:	b672      	cpsid	i
    2a0a:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
    2a0c:	2000      	movs	r0, #0
    2a0e:	46c0      	nop			; (mov r8, r8)

00002a10 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
    2a10:	f380 8810 	msr	PRIMASK, r0
    2a14:	4770      	bx	lr
    2a16:	46c0      	nop			; (mov r8, r8)

00002a18 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
    2a18:	f3ef 8009 	mrs	r0, PSP
    2a1c:	4b0e      	ldr	r3, [pc, #56]	; (2a58 <pxCurrentTCBConst>)
    2a1e:	681a      	ldr	r2, [r3, #0]
    2a20:	3820      	subs	r0, #32
    2a22:	6010      	str	r0, [r2, #0]
    2a24:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    2a26:	4644      	mov	r4, r8
    2a28:	464d      	mov	r5, r9
    2a2a:	4656      	mov	r6, sl
    2a2c:	465f      	mov	r7, fp
    2a2e:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    2a30:	b508      	push	{r3, lr}
    2a32:	b672      	cpsid	i
    2a34:	f000 ff64 	bl	3900 <vTaskSwitchContext>
    2a38:	b662      	cpsie	i
    2a3a:	bc0c      	pop	{r2, r3}
    2a3c:	6811      	ldr	r1, [r2, #0]
    2a3e:	6808      	ldr	r0, [r1, #0]
    2a40:	3010      	adds	r0, #16
    2a42:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    2a44:	46a0      	mov	r8, r4
    2a46:	46a9      	mov	r9, r5
    2a48:	46b2      	mov	sl, r6
    2a4a:	46bb      	mov	fp, r7
    2a4c:	f380 8809 	msr	PSP, r0
    2a50:	3820      	subs	r0, #32
    2a52:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    2a54:	4718      	bx	r3
    2a56:	46c0      	nop			; (mov r8, r8)

00002a58 <pxCurrentTCBConst>:
    2a58:	20003fd0 	.word	0x20003fd0

00002a5c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    2a5c:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    2a5e:	4b07      	ldr	r3, [pc, #28]	; (2a7c <SysTick_Handler+0x20>)
    2a60:	4798      	blx	r3
    2a62:	1c04      	adds	r4, r0, #0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    2a64:	4b06      	ldr	r3, [pc, #24]	; (2a80 <SysTick_Handler+0x24>)
    2a66:	4798      	blx	r3
    2a68:	2800      	cmp	r0, #0
    2a6a:	d003      	beq.n	2a74 <SysTick_Handler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    2a6c:	2280      	movs	r2, #128	; 0x80
    2a6e:	0552      	lsls	r2, r2, #21
    2a70:	4b04      	ldr	r3, [pc, #16]	; (2a84 <SysTick_Handler+0x28>)
    2a72:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
    2a74:	1c20      	adds	r0, r4, #0
    2a76:	4b04      	ldr	r3, [pc, #16]	; (2a88 <SysTick_Handler+0x2c>)
    2a78:	4798      	blx	r3
}
    2a7a:	bd10      	pop	{r4, pc}
    2a7c:	00002a05 	.word	0x00002a05
    2a80:	000035fd 	.word	0x000035fd
    2a84:	e000ed04 	.word	0xe000ed04
    2a88:	00002a11 	.word	0x00002a11

00002a8c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
    2a8c:	b508      	push	{r3, lr}
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_VAL)  = 0; /* Load the SysTick Counter Value */
    2a8e:	2200      	movs	r2, #0
    2a90:	4b07      	ldr	r3, [pc, #28]	; (2ab0 <vPortSetupTimerInterrupt+0x24>)
    2a92:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    2a94:	2000      	movs	r0, #0
    2a96:	4b07      	ldr	r3, [pc, #28]	; (2ab4 <vPortSetupTimerInterrupt+0x28>)
    2a98:	4798      	blx	r3
    2a9a:	21c8      	movs	r1, #200	; 0xc8
    2a9c:	4b06      	ldr	r3, [pc, #24]	; (2ab8 <vPortSetupTimerInterrupt+0x2c>)
    2a9e:	4798      	blx	r3
    2aa0:	3801      	subs	r0, #1
    2aa2:	4b06      	ldr	r3, [pc, #24]	; (2abc <vPortSetupTimerInterrupt+0x30>)
    2aa4:	6018      	str	r0, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    2aa6:	2207      	movs	r2, #7
    2aa8:	4b05      	ldr	r3, [pc, #20]	; (2ac0 <vPortSetupTimerInterrupt+0x34>)
    2aaa:	601a      	str	r2, [r3, #0]
}
    2aac:	bd08      	pop	{r3, pc}
    2aae:	46c0      	nop			; (mov r8, r8)
    2ab0:	e000e018 	.word	0xe000e018
    2ab4:	000025b5 	.word	0x000025b5
    2ab8:	00004aa9 	.word	0x00004aa9
    2abc:	e000e014 	.word	0xe000e014
    2ac0:	e000e010 	.word	0xe000e010

00002ac4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    2ac4:	b508      	push	{r3, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    2ac6:	4b0a      	ldr	r3, [pc, #40]	; (2af0 <xPortStartScheduler+0x2c>)
    2ac8:	681a      	ldr	r2, [r3, #0]
    2aca:	21ff      	movs	r1, #255	; 0xff
    2acc:	0409      	lsls	r1, r1, #16
    2ace:	430a      	orrs	r2, r1
    2ad0:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    2ad2:	681a      	ldr	r2, [r3, #0]
    2ad4:	21ff      	movs	r1, #255	; 0xff
    2ad6:	0609      	lsls	r1, r1, #24
    2ad8:	430a      	orrs	r2, r1
    2ada:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
    2adc:	4b05      	ldr	r3, [pc, #20]	; (2af4 <xPortStartScheduler+0x30>)
    2ade:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
    2ae0:	2200      	movs	r2, #0
    2ae2:	4b05      	ldr	r3, [pc, #20]	; (2af8 <xPortStartScheduler+0x34>)
    2ae4:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
    2ae6:	4b05      	ldr	r3, [pc, #20]	; (2afc <xPortStartScheduler+0x38>)
    2ae8:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
    2aea:	4b05      	ldr	r3, [pc, #20]	; (2b00 <xPortStartScheduler+0x3c>)
    2aec:	4798      	blx	r3
    2aee:	46c0      	nop			; (mov r8, r8)
    2af0:	e000ed20 	.word	0xe000ed20
    2af4:	00002a8d 	.word	0x00002a8d
    2af8:	20000018 	.word	0x20000018
    2afc:	00002971 	.word	0x00002971
    2b00:	0000295d 	.word	0x0000295d

00002b04 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2b04:	b538      	push	{r3, r4, r5, lr}
    2b06:	1c04      	adds	r4, r0, #0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    2b08:	0743      	lsls	r3, r0, #29
    2b0a:	d002      	beq.n	2b12 <pvPortMalloc+0xe>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    2b0c:	2307      	movs	r3, #7
    2b0e:	439c      	bics	r4, r3
    2b10:	3408      	adds	r4, #8
		}
	#endif

	vTaskSuspendAll();
    2b12:	4b10      	ldr	r3, [pc, #64]	; (2b54 <pvPortMalloc+0x50>)
    2b14:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
    2b16:	4b10      	ldr	r3, [pc, #64]	; (2b58 <pvPortMalloc+0x54>)
    2b18:	681b      	ldr	r3, [r3, #0]
    2b1a:	2b00      	cmp	r3, #0
    2b1c:	d105      	bne.n	2b2a <pvPortMalloc+0x26>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    2b1e:	2207      	movs	r2, #7
    2b20:	4b0e      	ldr	r3, [pc, #56]	; (2b5c <pvPortMalloc+0x58>)
    2b22:	3308      	adds	r3, #8
    2b24:	4393      	bics	r3, r2
    2b26:	4a0c      	ldr	r2, [pc, #48]	; (2b58 <pvPortMalloc+0x54>)
    2b28:	6013      	str	r3, [r2, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2b2a:	4b0d      	ldr	r3, [pc, #52]	; (2b60 <pvPortMalloc+0x5c>)
    2b2c:	681b      	ldr	r3, [r3, #0]
    2b2e:	18e4      	adds	r4, r4, r3
    2b30:	4a0c      	ldr	r2, [pc, #48]	; (2b64 <pvPortMalloc+0x60>)
    2b32:	4294      	cmp	r4, r2
    2b34:	d807      	bhi.n	2b46 <pvPortMalloc+0x42>
    2b36:	42a3      	cmp	r3, r4
    2b38:	d207      	bcs.n	2b4a <pvPortMalloc+0x46>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2b3a:	4a07      	ldr	r2, [pc, #28]	; (2b58 <pvPortMalloc+0x54>)
    2b3c:	6815      	ldr	r5, [r2, #0]
    2b3e:	18ed      	adds	r5, r5, r3
			xNextFreeByte += xWantedSize;
    2b40:	4b07      	ldr	r3, [pc, #28]	; (2b60 <pvPortMalloc+0x5c>)
    2b42:	601c      	str	r4, [r3, #0]
    2b44:	e002      	b.n	2b4c <pvPortMalloc+0x48>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2b46:	2500      	movs	r5, #0
    2b48:	e000      	b.n	2b4c <pvPortMalloc+0x48>
    2b4a:	2500      	movs	r5, #0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2b4c:	4b06      	ldr	r3, [pc, #24]	; (2b68 <pvPortMalloc+0x64>)
    2b4e:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
}
    2b50:	1c28      	adds	r0, r5, #0
    2b52:	bd38      	pop	{r3, r4, r5, pc}
    2b54:	000035cd 	.word	0x000035cd
    2b58:	20003f18 	.word	0x20003f18
    2b5c:	20000480 	.word	0x20000480
    2b60:	2000047c 	.word	0x2000047c
    2b64:	00003a8f 	.word	0x00003a8f
    2b68:	00003721 	.word	0x00003721

00002b6c <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
    2b6c:	2800      	cmp	r0, #0
    2b6e:	d001      	beq.n	2b74 <vPortFree+0x8>
    2b70:	b672      	cpsid	i
    2b72:	e7fe      	b.n	2b72 <vPortFree+0x6>
}
    2b74:	4770      	bx	lr
    2b76:	46c0      	nop			; (mov r8, r8)

00002b78 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2b78:	b538      	push	{r3, r4, r5, lr}
    2b7a:	1c04      	adds	r4, r0, #0
    2b7c:	1c15      	adds	r5, r2, #0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2b7e:	6c02      	ldr	r2, [r0, #64]	; 0x40
    2b80:	2a00      	cmp	r2, #0
    2b82:	d108      	bne.n	2b96 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2b84:	6803      	ldr	r3, [r0, #0]
    2b86:	2b00      	cmp	r3, #0
    2b88:	d12c      	bne.n	2be4 <prvCopyDataToQueue+0x6c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2b8a:	6840      	ldr	r0, [r0, #4]
    2b8c:	4b17      	ldr	r3, [pc, #92]	; (2bec <prvCopyDataToQueue+0x74>)
    2b8e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    2b90:	2300      	movs	r3, #0
    2b92:	6063      	str	r3, [r4, #4]
    2b94:	e026      	b.n	2be4 <prvCopyDataToQueue+0x6c>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2b96:	2d00      	cmp	r5, #0
    2b98:	d10d      	bne.n	2bb6 <prvCopyDataToQueue+0x3e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2b9a:	6880      	ldr	r0, [r0, #8]
    2b9c:	4b14      	ldr	r3, [pc, #80]	; (2bf0 <prvCopyDataToQueue+0x78>)
    2b9e:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2ba0:	68a3      	ldr	r3, [r4, #8]
    2ba2:	6c22      	ldr	r2, [r4, #64]	; 0x40
    2ba4:	4694      	mov	ip, r2
    2ba6:	4463      	add	r3, ip
    2ba8:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2baa:	6862      	ldr	r2, [r4, #4]
    2bac:	4293      	cmp	r3, r2
    2bae:	d319      	bcc.n	2be4 <prvCopyDataToQueue+0x6c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2bb0:	6823      	ldr	r3, [r4, #0]
    2bb2:	60a3      	str	r3, [r4, #8]
    2bb4:	e016      	b.n	2be4 <prvCopyDataToQueue+0x6c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2bb6:	68c0      	ldr	r0, [r0, #12]
    2bb8:	4b0d      	ldr	r3, [pc, #52]	; (2bf0 <prvCopyDataToQueue+0x78>)
    2bba:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2bbc:	6c23      	ldr	r3, [r4, #64]	; 0x40
    2bbe:	425b      	negs	r3, r3
    2bc0:	68e2      	ldr	r2, [r4, #12]
    2bc2:	18d2      	adds	r2, r2, r3
    2bc4:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2bc6:	6821      	ldr	r1, [r4, #0]
    2bc8:	428a      	cmp	r2, r1
    2bca:	d203      	bcs.n	2bd4 <prvCopyDataToQueue+0x5c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2bcc:	6862      	ldr	r2, [r4, #4]
    2bce:	4694      	mov	ip, r2
    2bd0:	4463      	add	r3, ip
    2bd2:	60e3      	str	r3, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2bd4:	2d02      	cmp	r5, #2
    2bd6:	d105      	bne.n	2be4 <prvCopyDataToQueue+0x6c>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bd8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2bda:	2b00      	cmp	r3, #0
    2bdc:	d002      	beq.n	2be4 <prvCopyDataToQueue+0x6c>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2bde:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2be0:	3b01      	subs	r3, #1
    2be2:	63a3      	str	r3, [r4, #56]	; 0x38
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2be4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2be6:	3301      	adds	r3, #1
    2be8:	63a3      	str	r3, [r4, #56]	; 0x38
}
    2bea:	bd38      	pop	{r3, r4, r5, pc}
    2bec:	00003ccd 	.word	0x00003ccd
    2bf0:	00004c6d 	.word	0x00004c6d

00002bf4 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
    2bf4:	b510      	push	{r4, lr}
    2bf6:	b082      	sub	sp, #8
    2bf8:	9001      	str	r0, [sp, #4]
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    2bfa:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
    2bfc:	2c00      	cmp	r4, #0
    2bfe:	d101      	bne.n	2c04 <prvNotifyQueueSetContainer+0x10>
    2c00:	b672      	cpsid	i
    2c02:	e7fe      	b.n	2c02 <prvNotifyQueueSetContainer+0xe>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
    2c04:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    2c06:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2c08:	429a      	cmp	r2, r3
    2c0a:	d301      	bcc.n	2c10 <prvNotifyQueueSetContainer+0x1c>
    2c0c:	b672      	cpsid	i
    2c0e:	e7fe      	b.n	2c0e <prvNotifyQueueSetContainer+0x1a>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    2c10:	6ba2      	ldr	r2, [r4, #56]	; 0x38
#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn = pdFALSE;
    2c12:	2000      	movs	r0, #0
		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    2c14:	4293      	cmp	r3, r2
    2c16:	d90e      	bls.n	2c36 <prvNotifyQueueSetContainer+0x42>
    2c18:	1c0a      	adds	r2, r1, #0
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copies is the handle of the queue that contains data. */
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    2c1a:	1c20      	adds	r0, r4, #0
    2c1c:	a901      	add	r1, sp, #4
    2c1e:	4b07      	ldr	r3, [pc, #28]	; (2c3c <prvNotifyQueueSetContainer+0x48>)
    2c20:	4798      	blx	r3
#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn = pdFALSE;
    2c22:	2000      	movs	r0, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copies is the handle of the queue that contains data. */
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
    2c24:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2c26:	2b00      	cmp	r3, #0
    2c28:	d005      	beq.n	2c36 <prvNotifyQueueSetContainer+0x42>
			{
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
    2c2a:	1c20      	adds	r0, r4, #0
    2c2c:	3024      	adds	r0, #36	; 0x24
    2c2e:	4b04      	ldr	r3, [pc, #16]	; (2c40 <prvNotifyQueueSetContainer+0x4c>)
    2c30:	4798      	blx	r3
#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn = pdFALSE;
    2c32:	1e43      	subs	r3, r0, #1
    2c34:	4198      	sbcs	r0, r3
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    2c36:	b002      	add	sp, #8
    2c38:	bd10      	pop	{r4, pc}
    2c3a:	46c0      	nop			; (mov r8, r8)
    2c3c:	00002b79 	.word	0x00002b79
    2c40:	00003af9 	.word	0x00003af9

00002c44 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2c44:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2c46:	6804      	ldr	r4, [r0, #0]
    2c48:	2c00      	cmp	r4, #0
    2c4a:	d00c      	beq.n	2c66 <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2c4c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    2c4e:	68c3      	ldr	r3, [r0, #12]
    2c50:	189b      	adds	r3, r3, r2
    2c52:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2c54:	6845      	ldr	r5, [r0, #4]
    2c56:	42ab      	cmp	r3, r5
    2c58:	d300      	bcc.n	2c5c <prvCopyDataFromQueue+0x18>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2c5a:	60c4      	str	r4, [r0, #12]
    2c5c:	1c0b      	adds	r3, r1, #0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2c5e:	68c1      	ldr	r1, [r0, #12]
    2c60:	1c18      	adds	r0, r3, #0
    2c62:	4b01      	ldr	r3, [pc, #4]	; (2c68 <prvCopyDataFromQueue+0x24>)
    2c64:	4798      	blx	r3
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2c66:	bd38      	pop	{r3, r4, r5, pc}
    2c68:	00004c6d 	.word	0x00004c6d

00002c6c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c6e:	1c04      	adds	r4, r0, #0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2c70:	4b24      	ldr	r3, [pc, #144]	; (2d04 <prvUnlockQueue+0x98>)
    2c72:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2c74:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2c76:	2b00      	cmp	r3, #0
    2c78:	dd1c      	ble.n	2cb4 <prvUnlockQueue+0x48>
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
    2c7a:	4d23      	ldr	r5, [pc, #140]	; (2d08 <prvUnlockQueue+0x9c>)
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c7c:	4e23      	ldr	r6, [pc, #140]	; (2d0c <prvUnlockQueue+0xa0>)
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
    2c7e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    2c80:	2b00      	cmp	r3, #0
    2c82:	d007      	beq.n	2c94 <prvUnlockQueue+0x28>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
    2c84:	1c20      	adds	r0, r4, #0
    2c86:	2100      	movs	r1, #0
    2c88:	47a8      	blx	r5
    2c8a:	2801      	cmp	r0, #1
    2c8c:	d10c      	bne.n	2ca8 <prvUnlockQueue+0x3c>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
    2c8e:	4b20      	ldr	r3, [pc, #128]	; (2d10 <prvUnlockQueue+0xa4>)
    2c90:	4798      	blx	r3
    2c92:	e009      	b.n	2ca8 <prvUnlockQueue+0x3c>
				}
				else
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c94:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2c96:	2b00      	cmp	r3, #0
    2c98:	d00c      	beq.n	2cb4 <prvUnlockQueue+0x48>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c9a:	1c20      	adds	r0, r4, #0
    2c9c:	3024      	adds	r0, #36	; 0x24
    2c9e:	47b0      	blx	r6
    2ca0:	2800      	cmp	r0, #0
    2ca2:	d001      	beq.n	2ca8 <prvUnlockQueue+0x3c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
    2ca4:	4b1a      	ldr	r3, [pc, #104]	; (2d10 <prvUnlockQueue+0xa4>)
    2ca6:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2ca8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2caa:	3b01      	subs	r3, #1
    2cac:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2cae:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2cb0:	2b00      	cmp	r3, #0
    2cb2:	dce4      	bgt.n	2c7e <prvUnlockQueue+0x12>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2cb4:	2301      	movs	r3, #1
    2cb6:	425b      	negs	r3, r3
    2cb8:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
    2cba:	4b16      	ldr	r3, [pc, #88]	; (2d14 <prvUnlockQueue+0xa8>)
    2cbc:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2cbe:	4b11      	ldr	r3, [pc, #68]	; (2d04 <prvUnlockQueue+0x98>)
    2cc0:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2cc2:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2cc4:	2b00      	cmp	r3, #0
    2cc6:	dd16      	ble.n	2cf6 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cc8:	6923      	ldr	r3, [r4, #16]
    2cca:	2b00      	cmp	r3, #0
    2ccc:	d104      	bne.n	2cd8 <prvUnlockQueue+0x6c>
    2cce:	e012      	b.n	2cf6 <prvUnlockQueue+0x8a>
    2cd0:	6923      	ldr	r3, [r4, #16]
    2cd2:	2b00      	cmp	r3, #0
    2cd4:	d104      	bne.n	2ce0 <prvUnlockQueue+0x74>
    2cd6:	e00e      	b.n	2cf6 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2cd8:	1c25      	adds	r5, r4, #0
    2cda:	3510      	adds	r5, #16
    2cdc:	4f0b      	ldr	r7, [pc, #44]	; (2d0c <prvUnlockQueue+0xa0>)
				{
					vTaskMissedYield();
    2cde:	4e0c      	ldr	r6, [pc, #48]	; (2d10 <prvUnlockQueue+0xa4>)
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2ce0:	1c28      	adds	r0, r5, #0
    2ce2:	47b8      	blx	r7
    2ce4:	2800      	cmp	r0, #0
    2ce6:	d000      	beq.n	2cea <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    2ce8:	47b0      	blx	r6
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2cea:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2cec:	3b01      	subs	r3, #1
    2cee:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2cf0:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2cf2:	2b00      	cmp	r3, #0
    2cf4:	dcec      	bgt.n	2cd0 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2cf6:	2301      	movs	r3, #1
    2cf8:	425b      	negs	r3, r3
    2cfa:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
    2cfc:	4b05      	ldr	r3, [pc, #20]	; (2d14 <prvUnlockQueue+0xa8>)
    2cfe:	4798      	blx	r3
}
    2d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2d02:	46c0      	nop			; (mov r8, r8)
    2d04:	000029cd 	.word	0x000029cd
    2d08:	00002bf5 	.word	0x00002bf5
    2d0c:	00003af9 	.word	0x00003af9
    2d10:	00003c11 	.word	0x00003c11
    2d14:	000029e5 	.word	0x000029e5

00002d18 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2d18:	b538      	push	{r3, r4, r5, lr}
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
    2d1a:	2800      	cmp	r0, #0
    2d1c:	d101      	bne.n	2d22 <xQueueGenericReset+0xa>
    2d1e:	b672      	cpsid	i
    2d20:	e7fe      	b.n	2d20 <xQueueGenericReset+0x8>
    2d22:	1c0d      	adds	r5, r1, #0
    2d24:	1c04      	adds	r4, r0, #0

	taskENTER_CRITICAL();
    2d26:	4b15      	ldr	r3, [pc, #84]	; (2d7c <xQueueGenericReset+0x64>)
    2d28:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2d2a:	6822      	ldr	r2, [r4, #0]
    2d2c:	6c21      	ldr	r1, [r4, #64]	; 0x40
    2d2e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2d30:	434b      	muls	r3, r1
    2d32:	18d0      	adds	r0, r2, r3
    2d34:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2d36:	2000      	movs	r0, #0
    2d38:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2d3a:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    2d3c:	1a5b      	subs	r3, r3, r1
    2d3e:	18d3      	adds	r3, r2, r3
    2d40:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
    2d42:	2301      	movs	r3, #1
    2d44:	425b      	negs	r3, r3
    2d46:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
    2d48:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
    2d4a:	2d00      	cmp	r5, #0
    2d4c:	d10b      	bne.n	2d66 <xQueueGenericReset+0x4e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d4e:	6923      	ldr	r3, [r4, #16]
    2d50:	2b00      	cmp	r3, #0
    2d52:	d00f      	beq.n	2d74 <xQueueGenericReset+0x5c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2d54:	1c20      	adds	r0, r4, #0
    2d56:	3010      	adds	r0, #16
    2d58:	4b09      	ldr	r3, [pc, #36]	; (2d80 <xQueueGenericReset+0x68>)
    2d5a:	4798      	blx	r3
    2d5c:	2801      	cmp	r0, #1
    2d5e:	d109      	bne.n	2d74 <xQueueGenericReset+0x5c>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2d60:	4b08      	ldr	r3, [pc, #32]	; (2d84 <xQueueGenericReset+0x6c>)
    2d62:	4798      	blx	r3
    2d64:	e006      	b.n	2d74 <xQueueGenericReset+0x5c>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2d66:	1c20      	adds	r0, r4, #0
    2d68:	3010      	adds	r0, #16
    2d6a:	4d07      	ldr	r5, [pc, #28]	; (2d88 <xQueueGenericReset+0x70>)
    2d6c:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2d6e:	1c20      	adds	r0, r4, #0
    2d70:	3024      	adds	r0, #36	; 0x24
    2d72:	47a8      	blx	r5
		}
	}
	taskEXIT_CRITICAL();
    2d74:	4b05      	ldr	r3, [pc, #20]	; (2d8c <xQueueGenericReset+0x74>)
    2d76:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    2d78:	2001      	movs	r0, #1
    2d7a:	bd38      	pop	{r3, r4, r5, pc}
    2d7c:	000029cd 	.word	0x000029cd
    2d80:	00003af9 	.word	0x00003af9
    2d84:	000029b5 	.word	0x000029b5
    2d88:	000028d1 	.word	0x000028d1
    2d8c:	000029e5 	.word	0x000029e5

00002d90 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2d90:	b570      	push	{r4, r5, r6, lr}
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    2d92:	2800      	cmp	r0, #0
    2d94:	d013      	beq.n	2dbe <xQueueGenericCreate+0x2e>
    2d96:	1c0e      	adds	r6, r1, #0
    2d98:	1c05      	adds	r5, r0, #0
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2d9a:	2050      	movs	r0, #80	; 0x50
    2d9c:	4b0e      	ldr	r3, [pc, #56]	; (2dd8 <xQueueGenericCreate+0x48>)
    2d9e:	4798      	blx	r3
    2da0:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
    2da2:	d00c      	beq.n	2dbe <xQueueGenericCreate+0x2e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2da4:	1c30      	adds	r0, r6, #0
    2da6:	4368      	muls	r0, r5
    2da8:	3001      	adds	r0, #1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    2daa:	4b0b      	ldr	r3, [pc, #44]	; (2dd8 <xQueueGenericCreate+0x48>)
    2dac:	4798      	blx	r3
    2dae:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
    2db0:	2800      	cmp	r0, #0
    2db2:	d106      	bne.n	2dc2 <xQueueGenericCreate+0x32>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2db4:	1c20      	adds	r0, r4, #0
    2db6:	4b09      	ldr	r3, [pc, #36]	; (2ddc <xQueueGenericCreate+0x4c>)
    2db8:	4798      	blx	r3
    2dba:	e000      	b.n	2dbe <xQueueGenericCreate+0x2e>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
    2dbc:	e7fe      	b.n	2dbc <xQueueGenericCreate+0x2c>
    2dbe:	b672      	cpsid	i
    2dc0:	e7fc      	b.n	2dbc <xQueueGenericCreate+0x2c>
			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2dc2:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
    2dc4:	6426      	str	r6, [r4, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2dc6:	1c20      	adds	r0, r4, #0
    2dc8:	2101      	movs	r1, #1
    2dca:	4b05      	ldr	r3, [pc, #20]	; (2de0 <xQueueGenericCreate+0x50>)
    2dcc:	4798      	blx	r3
				}
				#endif /* configUSE_TRACE_FACILITY */

				#if( configUSE_QUEUE_SETS == 1 )
				{
					pxNewQueue->pxQueueSetContainer = NULL;
    2dce:	2300      	movs	r3, #0
    2dd0:	64e3      	str	r3, [r4, #76]	; 0x4c
	}

	configASSERT( xReturn );

	return xReturn;
}
    2dd2:	1c20      	adds	r0, r4, #0
    2dd4:	bd70      	pop	{r4, r5, r6, pc}
    2dd6:	46c0      	nop			; (mov r8, r8)
    2dd8:	00002b05 	.word	0x00002b05
    2ddc:	00002b6d 	.word	0x00002b6d
    2de0:	00002d19 	.word	0x00002d19

00002de4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2de4:	b5f0      	push	{r4, r5, r6, r7, lr}
    2de6:	4657      	mov	r7, sl
    2de8:	464e      	mov	r6, r9
    2dea:	b4c0      	push	{r6, r7}
    2dec:	b085      	sub	sp, #20
    2dee:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
    2df0:	2800      	cmp	r0, #0
    2df2:	d101      	bne.n	2df8 <xQueueGenericSend+0x14>
    2df4:	b672      	cpsid	i
    2df6:	e7fe      	b.n	2df6 <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2df8:	2900      	cmp	r1, #0
    2dfa:	d104      	bne.n	2e06 <xQueueGenericSend+0x22>
    2dfc:	6c02      	ldr	r2, [r0, #64]	; 0x40
    2dfe:	2a00      	cmp	r2, #0
    2e00:	d001      	beq.n	2e06 <xQueueGenericSend+0x22>
    2e02:	b672      	cpsid	i
    2e04:	e7fe      	b.n	2e04 <xQueueGenericSend+0x20>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    2e06:	2b02      	cmp	r3, #2
    2e08:	d104      	bne.n	2e14 <xQueueGenericSend+0x30>
    2e0a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    2e0c:	2a01      	cmp	r2, #1
    2e0e:	d001      	beq.n	2e14 <xQueueGenericSend+0x30>
    2e10:	b672      	cpsid	i
    2e12:	e7fe      	b.n	2e12 <xQueueGenericSend+0x2e>
    2e14:	1c1d      	adds	r5, r3, #0
    2e16:	9100      	str	r1, [sp, #0]
    2e18:	1c04      	adds	r4, r0, #0
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    2e1a:	4b41      	ldr	r3, [pc, #260]	; (2f20 <xQueueGenericSend+0x13c>)
    2e1c:	4798      	blx	r3
    2e1e:	2800      	cmp	r0, #0
    2e20:	d104      	bne.n	2e2c <xQueueGenericSend+0x48>
    2e22:	9b01      	ldr	r3, [sp, #4]
    2e24:	2b00      	cmp	r3, #0
    2e26:	d003      	beq.n	2e30 <xQueueGenericSend+0x4c>
    2e28:	b672      	cpsid	i
    2e2a:	e7fe      	b.n	2e2a <xQueueGenericSend+0x46>
    2e2c:	2700      	movs	r7, #0
    2e2e:	e000      	b.n	2e32 <xQueueGenericSend+0x4e>
    2e30:	2700      	movs	r7, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2e32:	4e3c      	ldr	r6, [pc, #240]	; (2f24 <xQueueGenericSend+0x140>)
    2e34:	47b0      	blx	r6
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2e36:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2e38:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    2e3a:	4293      	cmp	r3, r2
    2e3c:	d301      	bcc.n	2e42 <xQueueGenericSend+0x5e>
    2e3e:	2d02      	cmp	r5, #2
    2e40:	d11f      	bne.n	2e82 <xQueueGenericSend+0x9e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2e42:	1c20      	adds	r0, r4, #0
    2e44:	9900      	ldr	r1, [sp, #0]
    2e46:	1c2a      	adds	r2, r5, #0
    2e48:	4b37      	ldr	r3, [pc, #220]	; (2f28 <xQueueGenericSend+0x144>)
    2e4a:	4798      	blx	r3

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
    2e4c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    2e4e:	2b00      	cmp	r3, #0
    2e50:	d008      	beq.n	2e64 <xQueueGenericSend+0x80>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    2e52:	1c20      	adds	r0, r4, #0
    2e54:	1c29      	adds	r1, r5, #0
    2e56:	4b35      	ldr	r3, [pc, #212]	; (2f2c <xQueueGenericSend+0x148>)
    2e58:	4798      	blx	r3
    2e5a:	2801      	cmp	r0, #1
    2e5c:	d10d      	bne.n	2e7a <xQueueGenericSend+0x96>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
    2e5e:	4b34      	ldr	r3, [pc, #208]	; (2f30 <xQueueGenericSend+0x14c>)
    2e60:	4798      	blx	r3
    2e62:	e00a      	b.n	2e7a <xQueueGenericSend+0x96>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e64:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2e66:	2b00      	cmp	r3, #0
    2e68:	d007      	beq.n	2e7a <xQueueGenericSend+0x96>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2e6a:	1c20      	adds	r0, r4, #0
    2e6c:	3024      	adds	r0, #36	; 0x24
    2e6e:	4b31      	ldr	r3, [pc, #196]	; (2f34 <xQueueGenericSend+0x150>)
    2e70:	4798      	blx	r3
    2e72:	2801      	cmp	r0, #1
    2e74:	d101      	bne.n	2e7a <xQueueGenericSend+0x96>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
    2e76:	4b2e      	ldr	r3, [pc, #184]	; (2f30 <xQueueGenericSend+0x14c>)
    2e78:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2e7a:	4b2f      	ldr	r3, [pc, #188]	; (2f38 <xQueueGenericSend+0x154>)
    2e7c:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2e7e:	2001      	movs	r0, #1
    2e80:	e049      	b.n	2f16 <xQueueGenericSend+0x132>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2e82:	9b01      	ldr	r3, [sp, #4]
    2e84:	2b00      	cmp	r3, #0
    2e86:	d103      	bne.n	2e90 <xQueueGenericSend+0xac>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2e88:	4b2b      	ldr	r3, [pc, #172]	; (2f38 <xQueueGenericSend+0x154>)
    2e8a:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2e8c:	2000      	movs	r0, #0
    2e8e:	e042      	b.n	2f16 <xQueueGenericSend+0x132>
				}
				else if( xEntryTimeSet == pdFALSE )
    2e90:	2f00      	cmp	r7, #0
    2e92:	d103      	bne.n	2e9c <xQueueGenericSend+0xb8>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2e94:	a802      	add	r0, sp, #8
    2e96:	4b29      	ldr	r3, [pc, #164]	; (2f3c <xQueueGenericSend+0x158>)
    2e98:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    2e9a:	3701      	adds	r7, #1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2e9c:	4b26      	ldr	r3, [pc, #152]	; (2f38 <xQueueGenericSend+0x154>)
    2e9e:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2ea0:	4b27      	ldr	r3, [pc, #156]	; (2f40 <xQueueGenericSend+0x15c>)
    2ea2:	4798      	blx	r3
		prvLockQueue( pxQueue );
    2ea4:	4b1f      	ldr	r3, [pc, #124]	; (2f24 <xQueueGenericSend+0x140>)
    2ea6:	4798      	blx	r3
    2ea8:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2eaa:	3301      	adds	r3, #1
    2eac:	d101      	bne.n	2eb2 <xQueueGenericSend+0xce>
    2eae:	2300      	movs	r3, #0
    2eb0:	6463      	str	r3, [r4, #68]	; 0x44
    2eb2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2eb4:	3301      	adds	r3, #1
    2eb6:	d101      	bne.n	2ebc <xQueueGenericSend+0xd8>
    2eb8:	2300      	movs	r3, #0
    2eba:	64a3      	str	r3, [r4, #72]	; 0x48
    2ebc:	4b1e      	ldr	r3, [pc, #120]	; (2f38 <xQueueGenericSend+0x154>)
    2ebe:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ec0:	a802      	add	r0, sp, #8
    2ec2:	a901      	add	r1, sp, #4
    2ec4:	4b1f      	ldr	r3, [pc, #124]	; (2f44 <xQueueGenericSend+0x160>)
    2ec6:	4798      	blx	r3
    2ec8:	2800      	cmp	r0, #0
    2eca:	d11e      	bne.n	2f0a <xQueueGenericSend+0x126>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ecc:	4b15      	ldr	r3, [pc, #84]	; (2f24 <xQueueGenericSend+0x140>)
    2ece:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2ed0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2ed2:	469a      	mov	sl, r3
    2ed4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2ed6:	4699      	mov	r9, r3
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2ed8:	4b17      	ldr	r3, [pc, #92]	; (2f38 <xQueueGenericSend+0x154>)
    2eda:	4798      	blx	r3
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2edc:	45ca      	cmp	sl, r9
    2ede:	d10e      	bne.n	2efe <xQueueGenericSend+0x11a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2ee0:	1c20      	adds	r0, r4, #0
    2ee2:	3010      	adds	r0, #16
    2ee4:	9901      	ldr	r1, [sp, #4]
    2ee6:	4b18      	ldr	r3, [pc, #96]	; (2f48 <xQueueGenericSend+0x164>)
    2ee8:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2eea:	1c20      	adds	r0, r4, #0
    2eec:	4b17      	ldr	r3, [pc, #92]	; (2f4c <xQueueGenericSend+0x168>)
    2eee:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2ef0:	4b17      	ldr	r3, [pc, #92]	; (2f50 <xQueueGenericSend+0x16c>)
    2ef2:	4798      	blx	r3
    2ef4:	2800      	cmp	r0, #0
    2ef6:	d19d      	bne.n	2e34 <xQueueGenericSend+0x50>
				{
					portYIELD_WITHIN_API();
    2ef8:	4b0d      	ldr	r3, [pc, #52]	; (2f30 <xQueueGenericSend+0x14c>)
    2efa:	4798      	blx	r3
    2efc:	e79a      	b.n	2e34 <xQueueGenericSend+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2efe:	1c20      	adds	r0, r4, #0
    2f00:	4b12      	ldr	r3, [pc, #72]	; (2f4c <xQueueGenericSend+0x168>)
    2f02:	4798      	blx	r3
				( void ) xTaskResumeAll();
    2f04:	4b12      	ldr	r3, [pc, #72]	; (2f50 <xQueueGenericSend+0x16c>)
    2f06:	4798      	blx	r3
    2f08:	e794      	b.n	2e34 <xQueueGenericSend+0x50>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2f0a:	1c20      	adds	r0, r4, #0
    2f0c:	4b0f      	ldr	r3, [pc, #60]	; (2f4c <xQueueGenericSend+0x168>)
    2f0e:	4798      	blx	r3
			( void ) xTaskResumeAll();
    2f10:	4b0f      	ldr	r3, [pc, #60]	; (2f50 <xQueueGenericSend+0x16c>)
    2f12:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2f14:	2000      	movs	r0, #0
		}
	}
}
    2f16:	b005      	add	sp, #20
    2f18:	bc0c      	pop	{r2, r3}
    2f1a:	4691      	mov	r9, r2
    2f1c:	469a      	mov	sl, r3
    2f1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2f20:	00003c29 	.word	0x00003c29
    2f24:	000029cd 	.word	0x000029cd
    2f28:	00002b79 	.word	0x00002b79
    2f2c:	00002bf5 	.word	0x00002bf5
    2f30:	000029b5 	.word	0x000029b5
    2f34:	00003af9 	.word	0x00003af9
    2f38:	000029e5 	.word	0x000029e5
    2f3c:	00003b81 	.word	0x00003b81
    2f40:	000035cd 	.word	0x000035cd
    2f44:	00003ba1 	.word	0x00003ba1
    2f48:	00003a61 	.word	0x00003a61
    2f4c:	00002c6d 	.word	0x00002c6d
    2f50:	00003721 	.word	0x00003721

00002f54 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2f54:	b538      	push	{r3, r4, r5, lr}
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2f56:	2050      	movs	r0, #80	; 0x50
    2f58:	4b11      	ldr	r3, [pc, #68]	; (2fa0 <xQueueCreateMutex+0x4c>)
    2f5a:	4798      	blx	r3
    2f5c:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
    2f5e:	d001      	beq.n	2f64 <xQueueCreateMutex+0x10>
    2f60:	e002      	b.n	2f68 <xQueueCreateMutex+0x14>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
    2f62:	e7fe      	b.n	2f62 <xQueueCreateMutex+0xe>
    2f64:	b672      	cpsid	i
    2f66:	e7fc      	b.n	2f62 <xQueueCreateMutex+0xe>
		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    2f68:	2300      	movs	r3, #0
    2f6a:	6043      	str	r3, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2f6c:	6003      	str	r3, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    2f6e:	6083      	str	r3, [r0, #8]
			pxNewQueue->u.pcReadFrom = NULL;
    2f70:	60c3      	str	r3, [r0, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2f72:	6383      	str	r3, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    2f74:	2201      	movs	r2, #1
    2f76:	63c2      	str	r2, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    2f78:	6403      	str	r3, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
    2f7a:	3a02      	subs	r2, #2
    2f7c:	6442      	str	r2, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
    2f7e:	6482      	str	r2, [r0, #72]	; 0x48
			}
			#endif

			#if ( configUSE_QUEUE_SETS == 1 )
			{
				pxNewQueue->pxQueueSetContainer = NULL;
    2f80:	64c3      	str	r3, [r0, #76]	; 0x4c
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2f82:	3010      	adds	r0, #16
    2f84:	4d07      	ldr	r5, [pc, #28]	; (2fa4 <xQueueCreateMutex+0x50>)
    2f86:	47a8      	blx	r5
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2f88:	1c20      	adds	r0, r4, #0
    2f8a:	3024      	adds	r0, #36	; 0x24
    2f8c:	47a8      	blx	r5

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    2f8e:	1c20      	adds	r0, r4, #0
    2f90:	2100      	movs	r1, #0
    2f92:	2200      	movs	r2, #0
    2f94:	2300      	movs	r3, #0
    2f96:	4d04      	ldr	r5, [pc, #16]	; (2fa8 <xQueueCreateMutex+0x54>)
    2f98:	47a8      	blx	r5
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2f9a:	1c20      	adds	r0, r4, #0
    2f9c:	bd38      	pop	{r3, r4, r5, pc}
    2f9e:	46c0      	nop			; (mov r8, r8)
    2fa0:	00002b05 	.word	0x00002b05
    2fa4:	000028d1 	.word	0x000028d1
    2fa8:	00002de5 	.word	0x00002de5

00002fac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2fac:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fae:	b083      	sub	sp, #12
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
    2fb0:	2800      	cmp	r0, #0
    2fb2:	d101      	bne.n	2fb8 <xQueueGenericSendFromISR+0xc>
    2fb4:	b672      	cpsid	i
    2fb6:	e7fe      	b.n	2fb6 <xQueueGenericSendFromISR+0xa>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2fb8:	2900      	cmp	r1, #0
    2fba:	d104      	bne.n	2fc6 <xQueueGenericSendFromISR+0x1a>
    2fbc:	6c04      	ldr	r4, [r0, #64]	; 0x40
    2fbe:	2c00      	cmp	r4, #0
    2fc0:	d001      	beq.n	2fc6 <xQueueGenericSendFromISR+0x1a>
    2fc2:	b672      	cpsid	i
    2fc4:	e7fe      	b.n	2fc4 <xQueueGenericSendFromISR+0x18>
    2fc6:	1c1d      	adds	r5, r3, #0
    2fc8:	1c17      	adds	r7, r2, #0
    2fca:	9101      	str	r1, [sp, #4]
    2fcc:	1c04      	adds	r4, r0, #0
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    2fce:	2b02      	cmp	r3, #2
    2fd0:	d138      	bne.n	3044 <xQueueGenericSendFromISR+0x98>
    2fd2:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    2fd4:	2b01      	cmp	r3, #1
    2fd6:	d030      	beq.n	303a <xQueueGenericSendFromISR+0x8e>
    2fd8:	b672      	cpsid	i
    2fda:	e7fe      	b.n	2fda <xQueueGenericSendFromISR+0x2e>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2fdc:	1c20      	adds	r0, r4, #0
    2fde:	9901      	ldr	r1, [sp, #4]
    2fe0:	1c2a      	adds	r2, r5, #0
    2fe2:	4b1f      	ldr	r3, [pc, #124]	; (3060 <xQueueGenericSendFromISR+0xb4>)
    2fe4:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2fe6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2fe8:	3301      	adds	r3, #1
    2fea:	d11d      	bne.n	3028 <xQueueGenericSendFromISR+0x7c>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
    2fec:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    2fee:	2b00      	cmp	r3, #0
    2ff0:	d00b      	beq.n	300a <xQueueGenericSendFromISR+0x5e>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    2ff2:	1c20      	adds	r0, r4, #0
    2ff4:	1c29      	adds	r1, r5, #0
    2ff6:	4b1b      	ldr	r3, [pc, #108]	; (3064 <xQueueGenericSendFromISR+0xb8>)
    2ff8:	4798      	blx	r3
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2ffa:	2501      	movs	r5, #1
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    2ffc:	2801      	cmp	r0, #1
    2ffe:	d129      	bne.n	3054 <xQueueGenericSendFromISR+0xa8>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3000:	2f00      	cmp	r7, #0
    3002:	d016      	beq.n	3032 <xQueueGenericSendFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3004:	2301      	movs	r3, #1
    3006:	603b      	str	r3, [r7, #0]
    3008:	e024      	b.n	3054 <xQueueGenericSendFromISR+0xa8>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    300a:	2501      	movs	r5, #1
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    300c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    300e:	2b00      	cmp	r3, #0
    3010:	d020      	beq.n	3054 <xQueueGenericSendFromISR+0xa8>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3012:	1c20      	adds	r0, r4, #0
    3014:	3024      	adds	r0, #36	; 0x24
    3016:	4b14      	ldr	r3, [pc, #80]	; (3068 <xQueueGenericSendFromISR+0xbc>)
    3018:	4798      	blx	r3
    301a:	2800      	cmp	r0, #0
    301c:	d01a      	beq.n	3054 <xQueueGenericSendFromISR+0xa8>
							{
								/* The task waiting has a higher priority so record that a
								context	switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
    301e:	2f00      	cmp	r7, #0
    3020:	d009      	beq.n	3036 <xQueueGenericSendFromISR+0x8a>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
    3022:	2301      	movs	r3, #1
    3024:	603b      	str	r3, [r7, #0]
    3026:	e015      	b.n	3054 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3028:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    302a:	3301      	adds	r3, #1
    302c:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
    302e:	2501      	movs	r5, #1
    3030:	e010      	b.n	3054 <xQueueGenericSendFromISR+0xa8>
    3032:	2501      	movs	r5, #1
    3034:	e00e      	b.n	3054 <xQueueGenericSendFromISR+0xa8>
    3036:	2501      	movs	r5, #1
    3038:	e00c      	b.n	3054 <xQueueGenericSendFromISR+0xa8>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    303a:	4b0c      	ldr	r3, [pc, #48]	; (306c <xQueueGenericSendFromISR+0xc0>)
    303c:	4798      	blx	r3
    303e:	1c06      	adds	r6, r0, #0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3040:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3042:	e7cb      	b.n	2fdc <xQueueGenericSendFromISR+0x30>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3044:	4b09      	ldr	r3, [pc, #36]	; (306c <xQueueGenericSendFromISR+0xc0>)
    3046:	4798      	blx	r3
    3048:	1c06      	adds	r6, r0, #0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    304a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    304c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    304e:	4293      	cmp	r3, r2
    3050:	d3c4      	bcc.n	2fdc <xQueueGenericSendFromISR+0x30>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3052:	2500      	movs	r5, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    3054:	1c30      	adds	r0, r6, #0
    3056:	4b06      	ldr	r3, [pc, #24]	; (3070 <xQueueGenericSendFromISR+0xc4>)
    3058:	4798      	blx	r3

	return xReturn;
}
    305a:	1c28      	adds	r0, r5, #0
    305c:	b003      	add	sp, #12
    305e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3060:	00002b79 	.word	0x00002b79
    3064:	00002bf5 	.word	0x00002bf5
    3068:	00003af9 	.word	0x00003af9
    306c:	00002a05 	.word	0x00002a05
    3070:	00002a11 	.word	0x00002a11

00003074 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3074:	b5f0      	push	{r4, r5, r6, r7, lr}
    3076:	464f      	mov	r7, r9
    3078:	b480      	push	{r7}
    307a:	b084      	sub	sp, #16
    307c:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
    307e:	2800      	cmp	r0, #0
    3080:	d101      	bne.n	3086 <xQueueGenericReceive+0x12>
    3082:	b672      	cpsid	i
    3084:	e7fe      	b.n	3084 <xQueueGenericReceive+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3086:	2900      	cmp	r1, #0
    3088:	d104      	bne.n	3094 <xQueueGenericReceive+0x20>
    308a:	6c02      	ldr	r2, [r0, #64]	; 0x40
    308c:	2a00      	cmp	r2, #0
    308e:	d001      	beq.n	3094 <xQueueGenericReceive+0x20>
    3090:	b672      	cpsid	i
    3092:	e7fe      	b.n	3092 <xQueueGenericReceive+0x1e>
    3094:	1c1e      	adds	r6, r3, #0
    3096:	9100      	str	r1, [sp, #0]
    3098:	1c04      	adds	r4, r0, #0
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    309a:	4b4a      	ldr	r3, [pc, #296]	; (31c4 <xQueueGenericReceive+0x150>)
    309c:	4798      	blx	r3
    309e:	2800      	cmp	r0, #0
    30a0:	d104      	bne.n	30ac <xQueueGenericReceive+0x38>
    30a2:	9b01      	ldr	r3, [sp, #4]
    30a4:	2b00      	cmp	r3, #0
    30a6:	d003      	beq.n	30b0 <xQueueGenericReceive+0x3c>
    30a8:	b672      	cpsid	i
    30aa:	e7fe      	b.n	30aa <xQueueGenericReceive+0x36>
    30ac:	2700      	movs	r7, #0
    30ae:	e000      	b.n	30b2 <xQueueGenericReceive+0x3e>
    30b0:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    30b2:	4d45      	ldr	r5, [pc, #276]	; (31c8 <xQueueGenericReceive+0x154>)
    30b4:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    30b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    30b8:	2b00      	cmp	r3, #0
    30ba:	d02b      	beq.n	3114 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    30bc:	68e7      	ldr	r7, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    30be:	1c20      	adds	r0, r4, #0
    30c0:	9900      	ldr	r1, [sp, #0]
    30c2:	4b42      	ldr	r3, [pc, #264]	; (31cc <xQueueGenericReceive+0x158>)
    30c4:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
    30c6:	2e00      	cmp	r6, #0
    30c8:	d114      	bne.n	30f4 <xQueueGenericReceive+0x80>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    30ca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    30cc:	3b01      	subs	r3, #1
    30ce:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    30d0:	6823      	ldr	r3, [r4, #0]
    30d2:	2b00      	cmp	r3, #0
    30d4:	d102      	bne.n	30dc <xQueueGenericReceive+0x68>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    30d6:	4b3e      	ldr	r3, [pc, #248]	; (31d0 <xQueueGenericReceive+0x15c>)
    30d8:	4798      	blx	r3
    30da:	6060      	str	r0, [r4, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30dc:	6923      	ldr	r3, [r4, #16]
    30de:	2b00      	cmp	r3, #0
    30e0:	d014      	beq.n	310c <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    30e2:	1c20      	adds	r0, r4, #0
    30e4:	3010      	adds	r0, #16
    30e6:	4b3b      	ldr	r3, [pc, #236]	; (31d4 <xQueueGenericReceive+0x160>)
    30e8:	4798      	blx	r3
    30ea:	2801      	cmp	r0, #1
    30ec:	d10e      	bne.n	310c <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    30ee:	4b3a      	ldr	r3, [pc, #232]	; (31d8 <xQueueGenericReceive+0x164>)
    30f0:	4798      	blx	r3
    30f2:	e00b      	b.n	310c <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    30f4:	60e7      	str	r7, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    30f8:	2b00      	cmp	r3, #0
    30fa:	d007      	beq.n	310c <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30fc:	1c20      	adds	r0, r4, #0
    30fe:	3024      	adds	r0, #36	; 0x24
    3100:	4b34      	ldr	r3, [pc, #208]	; (31d4 <xQueueGenericReceive+0x160>)
    3102:	4798      	blx	r3
    3104:	2800      	cmp	r0, #0
    3106:	d001      	beq.n	310c <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3108:	4b33      	ldr	r3, [pc, #204]	; (31d8 <xQueueGenericReceive+0x164>)
    310a:	4798      	blx	r3
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    310c:	4b33      	ldr	r3, [pc, #204]	; (31dc <xQueueGenericReceive+0x168>)
    310e:	4798      	blx	r3
				return pdPASS;
    3110:	2001      	movs	r0, #1
    3112:	e052      	b.n	31ba <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3114:	9b01      	ldr	r3, [sp, #4]
    3116:	2b00      	cmp	r3, #0
    3118:	d103      	bne.n	3122 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    311a:	4b30      	ldr	r3, [pc, #192]	; (31dc <xQueueGenericReceive+0x168>)
    311c:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    311e:	2000      	movs	r0, #0
    3120:	e04b      	b.n	31ba <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
    3122:	2f00      	cmp	r7, #0
    3124:	d103      	bne.n	312e <xQueueGenericReceive+0xba>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3126:	a802      	add	r0, sp, #8
    3128:	4b2d      	ldr	r3, [pc, #180]	; (31e0 <xQueueGenericReceive+0x16c>)
    312a:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    312c:	3701      	adds	r7, #1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    312e:	4b2b      	ldr	r3, [pc, #172]	; (31dc <xQueueGenericReceive+0x168>)
    3130:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3132:	4b2c      	ldr	r3, [pc, #176]	; (31e4 <xQueueGenericReceive+0x170>)
    3134:	4798      	blx	r3
		prvLockQueue( pxQueue );
    3136:	4b24      	ldr	r3, [pc, #144]	; (31c8 <xQueueGenericReceive+0x154>)
    3138:	4798      	blx	r3
    313a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    313c:	3301      	adds	r3, #1
    313e:	d101      	bne.n	3144 <xQueueGenericReceive+0xd0>
    3140:	2300      	movs	r3, #0
    3142:	6463      	str	r3, [r4, #68]	; 0x44
    3144:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    3146:	3301      	adds	r3, #1
    3148:	d101      	bne.n	314e <xQueueGenericReceive+0xda>
    314a:	2300      	movs	r3, #0
    314c:	64a3      	str	r3, [r4, #72]	; 0x48
    314e:	4b23      	ldr	r3, [pc, #140]	; (31dc <xQueueGenericReceive+0x168>)
    3150:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3152:	a802      	add	r0, sp, #8
    3154:	a901      	add	r1, sp, #4
    3156:	4b24      	ldr	r3, [pc, #144]	; (31e8 <xQueueGenericReceive+0x174>)
    3158:	4798      	blx	r3
    315a:	2800      	cmp	r0, #0
    315c:	d127      	bne.n	31ae <xQueueGenericReceive+0x13a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    315e:	4b1a      	ldr	r3, [pc, #104]	; (31c8 <xQueueGenericReceive+0x154>)
    3160:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3162:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3164:	4699      	mov	r9, r3
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3166:	4b1d      	ldr	r3, [pc, #116]	; (31dc <xQueueGenericReceive+0x168>)
    3168:	4798      	blx	r3
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    316a:	464b      	mov	r3, r9
    316c:	2b00      	cmp	r3, #0
    316e:	d118      	bne.n	31a2 <xQueueGenericReceive+0x12e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3170:	6823      	ldr	r3, [r4, #0]
    3172:	2b00      	cmp	r3, #0
    3174:	d106      	bne.n	3184 <xQueueGenericReceive+0x110>
					{
						taskENTER_CRITICAL();
    3176:	4b14      	ldr	r3, [pc, #80]	; (31c8 <xQueueGenericReceive+0x154>)
    3178:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    317a:	6860      	ldr	r0, [r4, #4]
    317c:	4b1b      	ldr	r3, [pc, #108]	; (31ec <xQueueGenericReceive+0x178>)
    317e:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
    3180:	4b16      	ldr	r3, [pc, #88]	; (31dc <xQueueGenericReceive+0x168>)
    3182:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3184:	1c20      	adds	r0, r4, #0
    3186:	3024      	adds	r0, #36	; 0x24
    3188:	9901      	ldr	r1, [sp, #4]
    318a:	4b19      	ldr	r3, [pc, #100]	; (31f0 <xQueueGenericReceive+0x17c>)
    318c:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    318e:	1c20      	adds	r0, r4, #0
    3190:	4b18      	ldr	r3, [pc, #96]	; (31f4 <xQueueGenericReceive+0x180>)
    3192:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    3194:	4b18      	ldr	r3, [pc, #96]	; (31f8 <xQueueGenericReceive+0x184>)
    3196:	4798      	blx	r3
    3198:	2800      	cmp	r0, #0
    319a:	d18b      	bne.n	30b4 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    319c:	4b0e      	ldr	r3, [pc, #56]	; (31d8 <xQueueGenericReceive+0x164>)
    319e:	4798      	blx	r3
    31a0:	e788      	b.n	30b4 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    31a2:	1c20      	adds	r0, r4, #0
    31a4:	4b13      	ldr	r3, [pc, #76]	; (31f4 <xQueueGenericReceive+0x180>)
    31a6:	4798      	blx	r3
				( void ) xTaskResumeAll();
    31a8:	4b13      	ldr	r3, [pc, #76]	; (31f8 <xQueueGenericReceive+0x184>)
    31aa:	4798      	blx	r3
    31ac:	e782      	b.n	30b4 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    31ae:	1c20      	adds	r0, r4, #0
    31b0:	4b10      	ldr	r3, [pc, #64]	; (31f4 <xQueueGenericReceive+0x180>)
    31b2:	4798      	blx	r3
			( void ) xTaskResumeAll();
    31b4:	4b10      	ldr	r3, [pc, #64]	; (31f8 <xQueueGenericReceive+0x184>)
    31b6:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    31b8:	2000      	movs	r0, #0
		}
	}
}
    31ba:	b004      	add	sp, #16
    31bc:	bc04      	pop	{r2}
    31be:	4691      	mov	r9, r2
    31c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    31c2:	46c0      	nop			; (mov r8, r8)
    31c4:	00003c29 	.word	0x00003c29
    31c8:	000029cd 	.word	0x000029cd
    31cc:	00002c45 	.word	0x00002c45
    31d0:	00003c1d 	.word	0x00003c1d
    31d4:	00003af9 	.word	0x00003af9
    31d8:	000029b5 	.word	0x000029b5
    31dc:	000029e5 	.word	0x000029e5
    31e0:	00003b81 	.word	0x00003b81
    31e4:	000035cd 	.word	0x000035cd
    31e8:	00003ba1 	.word	0x00003ba1
    31ec:	00003c49 	.word	0x00003c49
    31f0:	00003a61 	.word	0x00003a61
    31f4:	00002c6d 	.word	0x00002c6d
    31f8:	00003721 	.word	0x00003721

000031fc <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    31fc:	b538      	push	{r3, r4, r5, lr}
    31fe:	1c04      	adds	r4, r0, #0
    3200:	1c0d      	adds	r5, r1, #0
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    3202:	4b0d      	ldr	r3, [pc, #52]	; (3238 <vQueueWaitForMessageRestricted+0x3c>)
    3204:	4798      	blx	r3
    3206:	6c63      	ldr	r3, [r4, #68]	; 0x44
    3208:	3301      	adds	r3, #1
    320a:	d101      	bne.n	3210 <vQueueWaitForMessageRestricted+0x14>
    320c:	2300      	movs	r3, #0
    320e:	6463      	str	r3, [r4, #68]	; 0x44
    3210:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    3212:	3301      	adds	r3, #1
    3214:	d101      	bne.n	321a <vQueueWaitForMessageRestricted+0x1e>
    3216:	2300      	movs	r3, #0
    3218:	64a3      	str	r3, [r4, #72]	; 0x48
    321a:	4b08      	ldr	r3, [pc, #32]	; (323c <vQueueWaitForMessageRestricted+0x40>)
    321c:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    321e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3220:	2b00      	cmp	r3, #0
    3222:	d104      	bne.n	322e <vQueueWaitForMessageRestricted+0x32>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3224:	1c20      	adds	r0, r4, #0
    3226:	3024      	adds	r0, #36	; 0x24
    3228:	1c29      	adds	r1, r5, #0
    322a:	4b05      	ldr	r3, [pc, #20]	; (3240 <vQueueWaitForMessageRestricted+0x44>)
    322c:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    322e:	1c20      	adds	r0, r4, #0
    3230:	4b04      	ldr	r3, [pc, #16]	; (3244 <vQueueWaitForMessageRestricted+0x48>)
    3232:	4798      	blx	r3
	}
    3234:	bd38      	pop	{r3, r4, r5, pc}
    3236:	46c0      	nop			; (mov r8, r8)
    3238:	000029cd 	.word	0x000029cd
    323c:	000029e5 	.word	0x000029e5
    3240:	00003ab9 	.word	0x00003ab9
    3244:	00002c6d 	.word	0x00002c6d

00003248 <prvTaskIsTaskSuspended>:

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
    3248:	2800      	cmp	r0, #0
    324a:	d101      	bne.n	3250 <prvTaskIsTaskSuspended+0x8>
    324c:	b672      	cpsid	i
    324e:	e7fe      	b.n	324e <prvTaskIsTaskSuspended+0x6>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    3250:	2100      	movs	r1, #0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3252:	4a07      	ldr	r2, [pc, #28]	; (3270 <prvTaskIsTaskSuspended+0x28>)
    3254:	6943      	ldr	r3, [r0, #20]
    3256:	4293      	cmp	r3, r2
    3258:	d107      	bne.n	326a <prvTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    325a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    325c:	4a05      	ldr	r2, [pc, #20]	; (3274 <prvTaskIsTaskSuspended+0x2c>)
    325e:	4293      	cmp	r3, r2
    3260:	d002      	beq.n	3268 <prvTaskIsTaskSuspended+0x20>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    3262:	4259      	negs	r1, r3
    3264:	4159      	adcs	r1, r3
    3266:	e000      	b.n	326a <prvTaskIsTaskSuspended+0x22>
    3268:	2100      	movs	r1, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    326a:	1c08      	adds	r0, r1, #0
    326c:	4770      	bx	lr
    326e:	46c0      	nop			; (mov r8, r8)
    3270:	20003ffc 	.word	0x20003ffc
    3274:	20003fd4 	.word	0x20003fd4

00003278 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3278:	4b08      	ldr	r3, [pc, #32]	; (329c <prvResetNextTaskUnblockTime+0x24>)
    327a:	681b      	ldr	r3, [r3, #0]
    327c:	681b      	ldr	r3, [r3, #0]
    327e:	2b00      	cmp	r3, #0
    3280:	d104      	bne.n	328c <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3282:	2201      	movs	r2, #1
    3284:	4252      	negs	r2, r2
    3286:	4b06      	ldr	r3, [pc, #24]	; (32a0 <prvResetNextTaskUnblockTime+0x28>)
    3288:	601a      	str	r2, [r3, #0]
    328a:	e006      	b.n	329a <prvResetNextTaskUnblockTime+0x22>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    328c:	4b03      	ldr	r3, [pc, #12]	; (329c <prvResetNextTaskUnblockTime+0x24>)
    328e:	681b      	ldr	r3, [r3, #0]
    3290:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    3292:	68db      	ldr	r3, [r3, #12]
    3294:	685a      	ldr	r2, [r3, #4]
    3296:	4b02      	ldr	r3, [pc, #8]	; (32a0 <prvResetNextTaskUnblockTime+0x28>)
    3298:	601a      	str	r2, [r3, #0]
	}
}
    329a:	4770      	bx	lr
    329c:	20003f20 	.word	0x20003f20
    32a0:	2000001c 	.word	0x2000001c

000032a4 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    32a4:	b510      	push	{r4, lr}
    32a6:	1e04      	subs	r4, r0, #0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    32a8:	4b0e      	ldr	r3, [pc, #56]	; (32e4 <prvAddCurrentTaskToDelayedList+0x40>)
    32aa:	681b      	ldr	r3, [r3, #0]
    32ac:	6058      	str	r0, [r3, #4]

	if( xTimeToWake < xTickCount )
    32ae:	4b0e      	ldr	r3, [pc, #56]	; (32e8 <prvAddCurrentTaskToDelayedList+0x44>)
    32b0:	681b      	ldr	r3, [r3, #0]
    32b2:	429c      	cmp	r4, r3
    32b4:	d207      	bcs.n	32c6 <prvAddCurrentTaskToDelayedList+0x22>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    32b6:	4b0d      	ldr	r3, [pc, #52]	; (32ec <prvAddCurrentTaskToDelayedList+0x48>)
    32b8:	6818      	ldr	r0, [r3, #0]
    32ba:	4b0a      	ldr	r3, [pc, #40]	; (32e4 <prvAddCurrentTaskToDelayedList+0x40>)
    32bc:	6819      	ldr	r1, [r3, #0]
    32be:	3104      	adds	r1, #4
    32c0:	4b0b      	ldr	r3, [pc, #44]	; (32f0 <prvAddCurrentTaskToDelayedList+0x4c>)
    32c2:	4798      	blx	r3
    32c4:	e00c      	b.n	32e0 <prvAddCurrentTaskToDelayedList+0x3c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    32c6:	4b0b      	ldr	r3, [pc, #44]	; (32f4 <prvAddCurrentTaskToDelayedList+0x50>)
    32c8:	6818      	ldr	r0, [r3, #0]
    32ca:	4b06      	ldr	r3, [pc, #24]	; (32e4 <prvAddCurrentTaskToDelayedList+0x40>)
    32cc:	6819      	ldr	r1, [r3, #0]
    32ce:	3104      	adds	r1, #4
    32d0:	4b07      	ldr	r3, [pc, #28]	; (32f0 <prvAddCurrentTaskToDelayedList+0x4c>)
    32d2:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    32d4:	4b08      	ldr	r3, [pc, #32]	; (32f8 <prvAddCurrentTaskToDelayedList+0x54>)
    32d6:	681b      	ldr	r3, [r3, #0]
    32d8:	429c      	cmp	r4, r3
    32da:	d201      	bcs.n	32e0 <prvAddCurrentTaskToDelayedList+0x3c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    32dc:	4b06      	ldr	r3, [pc, #24]	; (32f8 <prvAddCurrentTaskToDelayedList+0x54>)
    32de:	601c      	str	r4, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    32e0:	bd10      	pop	{r4, pc}
    32e2:	46c0      	nop			; (mov r8, r8)
    32e4:	20003fd0 	.word	0x20003fd0
    32e8:	20003fec 	.word	0x20003fec
    32ec:	20003ff0 	.word	0x20003ff0
    32f0:	00002909 	.word	0x00002909
    32f4:	20003f20 	.word	0x20003f20
    32f8:	2000001c 	.word	0x2000001c

000032fc <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    32fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    32fe:	464f      	mov	r7, r9
    3300:	4646      	mov	r6, r8
    3302:	b4c0      	push	{r6, r7}
    3304:	b085      	sub	sp, #20
    3306:	9c0c      	ldr	r4, [sp, #48]	; 0x30
BaseType_t xReturn;
TCB_t * pxNewTCB;

	configASSERT( pxTaskCode );
    3308:	2800      	cmp	r0, #0
    330a:	d101      	bne.n	3310 <xTaskGenericCreate+0x14>
    330c:	b672      	cpsid	i
    330e:	e7fe      	b.n	330e <xTaskGenericCreate+0x12>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    3310:	2c04      	cmp	r4, #4
    3312:	d901      	bls.n	3318 <xTaskGenericCreate+0x1c>
    3314:	b672      	cpsid	i
    3316:	e7fe      	b.n	3316 <xTaskGenericCreate+0x1a>
    3318:	9303      	str	r3, [sp, #12]
    331a:	1c16      	adds	r6, r2, #0
    331c:	1c0d      	adds	r5, r1, #0
    331e:	9002      	str	r0, [sp, #8]
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    3320:	2040      	movs	r0, #64	; 0x40
    3322:	4b5a      	ldr	r3, [pc, #360]	; (348c <xTaskGenericCreate+0x190>)
    3324:	4798      	blx	r3
    3326:	1e07      	subs	r7, r0, #0

	if( pxNewTCB != NULL )
    3328:	d100      	bne.n	332c <xTaskGenericCreate+0x30>
    332a:	e0a8      	b.n	347e <xTaskGenericCreate+0x182>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    332c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    332e:	2b00      	cmp	r3, #0
    3330:	d000      	beq.n	3334 <xTaskGenericCreate+0x38>
    3332:	e0a1      	b.n	3478 <xTaskGenericCreate+0x17c>
    3334:	00b0      	lsls	r0, r6, #2
    3336:	4b55      	ldr	r3, [pc, #340]	; (348c <xTaskGenericCreate+0x190>)
    3338:	4798      	blx	r3
    333a:	6338      	str	r0, [r7, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
    333c:	2800      	cmp	r0, #0
    333e:	d103      	bne.n	3348 <xTaskGenericCreate+0x4c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3340:	1c38      	adds	r0, r7, #0
    3342:	4b53      	ldr	r3, [pc, #332]	; (3490 <xTaskGenericCreate+0x194>)
    3344:	4798      	blx	r3
    3346:	e09a      	b.n	347e <xTaskGenericCreate+0x182>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    3348:	4b52      	ldr	r3, [pc, #328]	; (3494 <xTaskGenericCreate+0x198>)
    334a:	18f3      	adds	r3, r6, r3
    334c:	009b      	lsls	r3, r3, #2
    334e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    3350:	4694      	mov	ip, r2
    3352:	4463      	add	r3, ip
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    3354:	2207      	movs	r2, #7
    3356:	4393      	bics	r3, r2
    3358:	4698      	mov	r8, r3
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    335a:	782a      	ldrb	r2, [r5, #0]
    335c:	2334      	movs	r3, #52	; 0x34
    335e:	54fa      	strb	r2, [r7, r3]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3360:	782b      	ldrb	r3, [r5, #0]
    3362:	2b00      	cmp	r3, #0
    3364:	d00d      	beq.n	3382 <xTaskGenericCreate+0x86>
    3366:	1c69      	adds	r1, r5, #1
    3368:	1c3b      	adds	r3, r7, #0
    336a:	3335      	adds	r3, #53	; 0x35
    336c:	1c3a      	adds	r2, r7, #0
    336e:	323c      	adds	r2, #60	; 0x3c
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    3370:	7808      	ldrb	r0, [r1, #0]
    3372:	7018      	strb	r0, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3374:	7808      	ldrb	r0, [r1, #0]
    3376:	2800      	cmp	r0, #0
    3378:	d003      	beq.n	3382 <xTaskGenericCreate+0x86>
    337a:	3101      	adds	r1, #1
    337c:	3301      	adds	r3, #1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    337e:	4293      	cmp	r3, r2
    3380:	d1f6      	bne.n	3370 <xTaskGenericCreate+0x74>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3382:	2200      	movs	r2, #0
    3384:	233b      	movs	r3, #59	; 0x3b
    3386:	54fa      	strb	r2, [r7, r3]
    3388:	1e25      	subs	r5, r4, #0
    338a:	2d04      	cmp	r5, #4
    338c:	d900      	bls.n	3390 <xTaskGenericCreate+0x94>
    338e:	2504      	movs	r5, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    3390:	62fd      	str	r5, [r7, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    3392:	63fd      	str	r5, [r7, #60]	; 0x3c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3394:	1d3b      	adds	r3, r7, #4
    3396:	9301      	str	r3, [sp, #4]
    3398:	1c18      	adds	r0, r3, #0
    339a:	4e3f      	ldr	r6, [pc, #252]	; (3498 <xTaskGenericCreate+0x19c>)
    339c:	47b0      	blx	r6
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    339e:	1c38      	adds	r0, r7, #0
    33a0:	3018      	adds	r0, #24
    33a2:	47b0      	blx	r6

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    33a4:	613f      	str	r7, [r7, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    33a6:	2305      	movs	r3, #5
    33a8:	1b5b      	subs	r3, r3, r5
    33aa:	61bb      	str	r3, [r7, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    33ac:	627f      	str	r7, [r7, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    33ae:	4640      	mov	r0, r8
    33b0:	9902      	ldr	r1, [sp, #8]
    33b2:	9a03      	ldr	r2, [sp, #12]
    33b4:	4b39      	ldr	r3, [pc, #228]	; (349c <xTaskGenericCreate+0x1a0>)
    33b6:	4798      	blx	r3
    33b8:	6038      	str	r0, [r7, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    33ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    33bc:	2b00      	cmp	r3, #0
    33be:	d000      	beq.n	33c2 <xTaskGenericCreate+0xc6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    33c0:	601f      	str	r7, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    33c2:	4b37      	ldr	r3, [pc, #220]	; (34a0 <xTaskGenericCreate+0x1a4>)
    33c4:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
    33c6:	4a37      	ldr	r2, [pc, #220]	; (34a4 <xTaskGenericCreate+0x1a8>)
    33c8:	6813      	ldr	r3, [r2, #0]
    33ca:	3301      	adds	r3, #1
    33cc:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
    33ce:	4b36      	ldr	r3, [pc, #216]	; (34a8 <xTaskGenericCreate+0x1ac>)
    33d0:	681b      	ldr	r3, [r3, #0]
    33d2:	2b00      	cmp	r3, #0
    33d4:	d122      	bne.n	341c <xTaskGenericCreate+0x120>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    33d6:	4b34      	ldr	r3, [pc, #208]	; (34a8 <xTaskGenericCreate+0x1ac>)
    33d8:	601f      	str	r7, [r3, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    33da:	6813      	ldr	r3, [r2, #0]
    33dc:	2b01      	cmp	r3, #1
    33de:	d128      	bne.n	3432 <xTaskGenericCreate+0x136>
    33e0:	4d32      	ldr	r5, [pc, #200]	; (34ac <xTaskGenericCreate+0x1b0>)
    33e2:	3363      	adds	r3, #99	; 0x63
    33e4:	4699      	mov	r9, r3
    33e6:	44a9      	add	r9, r5
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    33e8:	4e31      	ldr	r6, [pc, #196]	; (34b0 <xTaskGenericCreate+0x1b4>)
    33ea:	1c28      	adds	r0, r5, #0
    33ec:	47b0      	blx	r6
    33ee:	3514      	adds	r5, #20

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    33f0:	454d      	cmp	r5, r9
    33f2:	d1fa      	bne.n	33ea <xTaskGenericCreate+0xee>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    33f4:	4b2f      	ldr	r3, [pc, #188]	; (34b4 <xTaskGenericCreate+0x1b8>)
    33f6:	4699      	mov	r9, r3
    33f8:	1c18      	adds	r0, r3, #0
    33fa:	4d2d      	ldr	r5, [pc, #180]	; (34b0 <xTaskGenericCreate+0x1b4>)
    33fc:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList2 );
    33fe:	4e2e      	ldr	r6, [pc, #184]	; (34b8 <xTaskGenericCreate+0x1bc>)
    3400:	1c30      	adds	r0, r6, #0
    3402:	47a8      	blx	r5
	vListInitialise( &xPendingReadyList );
    3404:	482d      	ldr	r0, [pc, #180]	; (34bc <xTaskGenericCreate+0x1c0>)
    3406:	47a8      	blx	r5

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3408:	482d      	ldr	r0, [pc, #180]	; (34c0 <xTaskGenericCreate+0x1c4>)
    340a:	47a8      	blx	r5
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    340c:	482d      	ldr	r0, [pc, #180]	; (34c4 <xTaskGenericCreate+0x1c8>)
    340e:	47a8      	blx	r5
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3410:	4b2d      	ldr	r3, [pc, #180]	; (34c8 <xTaskGenericCreate+0x1cc>)
    3412:	464a      	mov	r2, r9
    3414:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3416:	4b2d      	ldr	r3, [pc, #180]	; (34cc <xTaskGenericCreate+0x1d0>)
    3418:	601e      	str	r6, [r3, #0]
    341a:	e00a      	b.n	3432 <xTaskGenericCreate+0x136>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    341c:	4b2c      	ldr	r3, [pc, #176]	; (34d0 <xTaskGenericCreate+0x1d4>)
    341e:	681b      	ldr	r3, [r3, #0]
    3420:	2b00      	cmp	r3, #0
    3422:	d106      	bne.n	3432 <xTaskGenericCreate+0x136>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3424:	4b20      	ldr	r3, [pc, #128]	; (34a8 <xTaskGenericCreate+0x1ac>)
    3426:	681b      	ldr	r3, [r3, #0]
    3428:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    342a:	429c      	cmp	r4, r3
    342c:	d301      	bcc.n	3432 <xTaskGenericCreate+0x136>
					{
						pxCurrentTCB = pxNewTCB;
    342e:	4b1e      	ldr	r3, [pc, #120]	; (34a8 <xTaskGenericCreate+0x1ac>)
    3430:	601f      	str	r7, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    3432:	4a28      	ldr	r2, [pc, #160]	; (34d4 <xTaskGenericCreate+0x1d8>)
    3434:	6813      	ldr	r3, [r2, #0]
    3436:	3301      	adds	r3, #1
    3438:	6013      	str	r3, [r2, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    343a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    343c:	4a26      	ldr	r2, [pc, #152]	; (34d8 <xTaskGenericCreate+0x1dc>)
    343e:	6812      	ldr	r2, [r2, #0]
    3440:	4293      	cmp	r3, r2
    3442:	d901      	bls.n	3448 <xTaskGenericCreate+0x14c>
    3444:	4a24      	ldr	r2, [pc, #144]	; (34d8 <xTaskGenericCreate+0x1dc>)
    3446:	6013      	str	r3, [r2, #0]
    3448:	0098      	lsls	r0, r3, #2
    344a:	18c3      	adds	r3, r0, r3
    344c:	009b      	lsls	r3, r3, #2
    344e:	4817      	ldr	r0, [pc, #92]	; (34ac <xTaskGenericCreate+0x1b0>)
    3450:	18c0      	adds	r0, r0, r3
    3452:	9901      	ldr	r1, [sp, #4]
    3454:	4b21      	ldr	r3, [pc, #132]	; (34dc <xTaskGenericCreate+0x1e0>)
    3456:	4798      	blx	r3

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3458:	4b21      	ldr	r3, [pc, #132]	; (34e0 <xTaskGenericCreate+0x1e4>)
    345a:	4798      	blx	r3
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    345c:	4b1c      	ldr	r3, [pc, #112]	; (34d0 <xTaskGenericCreate+0x1d4>)
    345e:	681b      	ldr	r3, [r3, #0]
    3460:	2001      	movs	r0, #1
    3462:	2b00      	cmp	r3, #0
    3464:	d00d      	beq.n	3482 <xTaskGenericCreate+0x186>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3466:	4b10      	ldr	r3, [pc, #64]	; (34a8 <xTaskGenericCreate+0x1ac>)
    3468:	681b      	ldr	r3, [r3, #0]
    346a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    346c:	429c      	cmp	r4, r3
    346e:	d908      	bls.n	3482 <xTaskGenericCreate+0x186>
			{
				taskYIELD_IF_USING_PREEMPTION();
    3470:	4b1c      	ldr	r3, [pc, #112]	; (34e4 <xTaskGenericCreate+0x1e8>)
    3472:	4798      	blx	r3
    3474:	2001      	movs	r0, #1
    3476:	e004      	b.n	3482 <xTaskGenericCreate+0x186>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3478:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    347a:	6303      	str	r3, [r0, #48]	; 0x30
    347c:	e764      	b.n	3348 <xTaskGenericCreate+0x4c>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    347e:	2001      	movs	r0, #1
    3480:	4240      	negs	r0, r0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    3482:	b005      	add	sp, #20
    3484:	bc0c      	pop	{r2, r3}
    3486:	4690      	mov	r8, r2
    3488:	4699      	mov	r9, r3
    348a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    348c:	00002b05 	.word	0x00002b05
    3490:	00002b6d 	.word	0x00002b6d
    3494:	3fffffff 	.word	0x3fffffff
    3498:	000028e9 	.word	0x000028e9
    349c:	00002991 	.word	0x00002991
    34a0:	000029cd 	.word	0x000029cd
    34a4:	20003ff8 	.word	0x20003ff8
    34a8:	20003fd0 	.word	0x20003fd0
    34ac:	20003f58 	.word	0x20003f58
    34b0:	000028d1 	.word	0x000028d1
    34b4:	20003f2c 	.word	0x20003f2c
    34b8:	20003f40 	.word	0x20003f40
    34bc:	20003fd4 	.word	0x20003fd4
    34c0:	20003fbc 	.word	0x20003fbc
    34c4:	20003ffc 	.word	0x20003ffc
    34c8:	20003f20 	.word	0x20003f20
    34cc:	20003ff0 	.word	0x20003ff0
    34d0:	20003f24 	.word	0x20003f24
    34d4:	20003ff4 	.word	0x20003ff4
    34d8:	20004010 	.word	0x20004010
    34dc:	000028f1 	.word	0x000028f1
    34e0:	000029e5 	.word	0x000029e5
    34e4:	000029b5 	.word	0x000029b5

000034e8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    34e8:	b538      	push	{r3, r4, r5, lr}
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
    34ea:	2800      	cmp	r0, #0
    34ec:	d101      	bne.n	34f2 <vTaskResume+0xa>
    34ee:	b672      	cpsid	i
    34f0:	e7fe      	b.n	34f0 <vTaskResume+0x8>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    34f2:	4b15      	ldr	r3, [pc, #84]	; (3548 <vTaskResume+0x60>)
    34f4:	681b      	ldr	r3, [r3, #0]
    34f6:	4298      	cmp	r0, r3
    34f8:	d024      	beq.n	3544 <vTaskResume+0x5c>
    34fa:	1c05      	adds	r5, r0, #0
		{
			taskENTER_CRITICAL();
    34fc:	4b13      	ldr	r3, [pc, #76]	; (354c <vTaskResume+0x64>)
    34fe:	4798      	blx	r3
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    3500:	1c28      	adds	r0, r5, #0
    3502:	4b13      	ldr	r3, [pc, #76]	; (3550 <vTaskResume+0x68>)
    3504:	4798      	blx	r3
    3506:	2801      	cmp	r0, #1
    3508:	d11a      	bne.n	3540 <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    350a:	1d2c      	adds	r4, r5, #4
    350c:	1c20      	adds	r0, r4, #0
    350e:	4b11      	ldr	r3, [pc, #68]	; (3554 <vTaskResume+0x6c>)
    3510:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    3512:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    3514:	4a10      	ldr	r2, [pc, #64]	; (3558 <vTaskResume+0x70>)
    3516:	6812      	ldr	r2, [r2, #0]
    3518:	4293      	cmp	r3, r2
    351a:	d901      	bls.n	3520 <vTaskResume+0x38>
    351c:	4a0e      	ldr	r2, [pc, #56]	; (3558 <vTaskResume+0x70>)
    351e:	6013      	str	r3, [r2, #0]
    3520:	0098      	lsls	r0, r3, #2
    3522:	18c3      	adds	r3, r0, r3
    3524:	009b      	lsls	r3, r3, #2
    3526:	480d      	ldr	r0, [pc, #52]	; (355c <vTaskResume+0x74>)
    3528:	18c0      	adds	r0, r0, r3
    352a:	1c21      	adds	r1, r4, #0
    352c:	4b0c      	ldr	r3, [pc, #48]	; (3560 <vTaskResume+0x78>)
    352e:	4798      	blx	r3

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3530:	4b05      	ldr	r3, [pc, #20]	; (3548 <vTaskResume+0x60>)
    3532:	681b      	ldr	r3, [r3, #0]
    3534:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    3536:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3538:	429a      	cmp	r2, r3
    353a:	d301      	bcc.n	3540 <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    353c:	4b09      	ldr	r3, [pc, #36]	; (3564 <vTaskResume+0x7c>)
    353e:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3540:	4b09      	ldr	r3, [pc, #36]	; (3568 <vTaskResume+0x80>)
    3542:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3544:	bd38      	pop	{r3, r4, r5, pc}
    3546:	46c0      	nop			; (mov r8, r8)
    3548:	20003fd0 	.word	0x20003fd0
    354c:	000029cd 	.word	0x000029cd
    3550:	00003249 	.word	0x00003249
    3554:	00002939 	.word	0x00002939
    3558:	20004010 	.word	0x20004010
    355c:	20003f58 	.word	0x20003f58
    3560:	000028f1 	.word	0x000028f1
    3564:	000029b5 	.word	0x000029b5
    3568:	000029e5 	.word	0x000029e5

0000356c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    356c:	b510      	push	{r4, lr}
    356e:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3570:	2300      	movs	r3, #0
    3572:	9300      	str	r3, [sp, #0]
    3574:	9301      	str	r3, [sp, #4]
    3576:	9302      	str	r3, [sp, #8]
    3578:	9303      	str	r3, [sp, #12]
    357a:	480d      	ldr	r0, [pc, #52]	; (35b0 <vTaskStartScheduler+0x44>)
    357c:	490d      	ldr	r1, [pc, #52]	; (35b4 <vTaskStartScheduler+0x48>)
    357e:	2264      	movs	r2, #100	; 0x64
    3580:	4c0d      	ldr	r4, [pc, #52]	; (35b8 <vTaskStartScheduler+0x4c>)
    3582:	47a0      	blx	r4
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    3584:	2801      	cmp	r0, #1
    3586:	d10d      	bne.n	35a4 <vTaskStartScheduler+0x38>
		{
			xReturn = xTimerCreateTimerTask();
    3588:	4b0c      	ldr	r3, [pc, #48]	; (35bc <vTaskStartScheduler+0x50>)
    358a:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    358c:	2801      	cmp	r0, #1
    358e:	d109      	bne.n	35a4 <vTaskStartScheduler+0x38>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3590:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    3592:	2201      	movs	r2, #1
    3594:	4b0a      	ldr	r3, [pc, #40]	; (35c0 <vTaskStartScheduler+0x54>)
    3596:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
    3598:	2200      	movs	r2, #0
    359a:	4b0a      	ldr	r3, [pc, #40]	; (35c4 <vTaskStartScheduler+0x58>)
    359c:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    359e:	4b0a      	ldr	r3, [pc, #40]	; (35c8 <vTaskStartScheduler+0x5c>)
    35a0:	4798      	blx	r3
    35a2:	e003      	b.n	35ac <vTaskStartScheduler+0x40>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
    35a4:	2800      	cmp	r0, #0
    35a6:	d101      	bne.n	35ac <vTaskStartScheduler+0x40>
    35a8:	b672      	cpsid	i
    35aa:	e7fe      	b.n	35aa <vTaskStartScheduler+0x3e>
	}
}
    35ac:	b004      	add	sp, #16
    35ae:	bd10      	pop	{r4, pc}
    35b0:	00003875 	.word	0x00003875
    35b4:	00004f74 	.word	0x00004f74
    35b8:	000032fd 	.word	0x000032fd
    35bc:	00003dd9 	.word	0x00003dd9
    35c0:	20003f24 	.word	0x20003f24
    35c4:	20003fec 	.word	0x20003fec
    35c8:	00002ac5 	.word	0x00002ac5

000035cc <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    35cc:	4a02      	ldr	r2, [pc, #8]	; (35d8 <vTaskSuspendAll+0xc>)
    35ce:	6813      	ldr	r3, [r2, #0]
    35d0:	3301      	adds	r3, #1
    35d2:	6013      	str	r3, [r2, #0]
}
    35d4:	4770      	bx	lr
    35d6:	46c0      	nop			; (mov r8, r8)
    35d8:	20003fe8 	.word	0x20003fe8

000035dc <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    35dc:	b510      	push	{r4, lr}
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    35de:	4b04      	ldr	r3, [pc, #16]	; (35f0 <xTaskGetTickCount+0x14>)
    35e0:	4798      	blx	r3
	{
		xTicks = xTickCount;
    35e2:	4b04      	ldr	r3, [pc, #16]	; (35f4 <xTaskGetTickCount+0x18>)
    35e4:	681c      	ldr	r4, [r3, #0]
	}
	taskEXIT_CRITICAL();
    35e6:	4b04      	ldr	r3, [pc, #16]	; (35f8 <xTaskGetTickCount+0x1c>)
    35e8:	4798      	blx	r3

	return xTicks;
}
    35ea:	1c20      	adds	r0, r4, #0
    35ec:	bd10      	pop	{r4, pc}
    35ee:	46c0      	nop			; (mov r8, r8)
    35f0:	000029cd 	.word	0x000029cd
    35f4:	20003fec 	.word	0x20003fec
    35f8:	000029e5 	.word	0x000029e5

000035fc <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    35fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    35fe:	b083      	sub	sp, #12

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3600:	4b39      	ldr	r3, [pc, #228]	; (36e8 <xTaskIncrementTick+0xec>)
    3602:	681b      	ldr	r3, [r3, #0]
    3604:	2b00      	cmp	r3, #0
    3606:	d162      	bne.n	36ce <xTaskIncrementTick+0xd2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3608:	4b38      	ldr	r3, [pc, #224]	; (36ec <xTaskIncrementTick+0xf0>)
    360a:	681a      	ldr	r2, [r3, #0]
    360c:	3201      	adds	r2, #1
    360e:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3610:	681c      	ldr	r4, [r3, #0]

			if( xConstTickCount == ( TickType_t ) 0U )
    3612:	2c00      	cmp	r4, #0
    3614:	d112      	bne.n	363c <xTaskIncrementTick+0x40>
			{
				taskSWITCH_DELAYED_LISTS();
    3616:	4b36      	ldr	r3, [pc, #216]	; (36f0 <xTaskIncrementTick+0xf4>)
    3618:	681b      	ldr	r3, [r3, #0]
    361a:	681b      	ldr	r3, [r3, #0]
    361c:	2b00      	cmp	r3, #0
    361e:	d001      	beq.n	3624 <xTaskIncrementTick+0x28>
    3620:	b672      	cpsid	i
    3622:	e7fe      	b.n	3622 <xTaskIncrementTick+0x26>
    3624:	4a32      	ldr	r2, [pc, #200]	; (36f0 <xTaskIncrementTick+0xf4>)
    3626:	6811      	ldr	r1, [r2, #0]
    3628:	4b32      	ldr	r3, [pc, #200]	; (36f4 <xTaskIncrementTick+0xf8>)
    362a:	6818      	ldr	r0, [r3, #0]
    362c:	6010      	str	r0, [r2, #0]
    362e:	6019      	str	r1, [r3, #0]
    3630:	4a31      	ldr	r2, [pc, #196]	; (36f8 <xTaskIncrementTick+0xfc>)
    3632:	6813      	ldr	r3, [r2, #0]
    3634:	3301      	adds	r3, #1
    3636:	6013      	str	r3, [r2, #0]
    3638:	4b30      	ldr	r3, [pc, #192]	; (36fc <xTaskIncrementTick+0x100>)
    363a:	4798      	blx	r3

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    363c:	4b30      	ldr	r3, [pc, #192]	; (3700 <xTaskIncrementTick+0x104>)
    363e:	681b      	ldr	r3, [r3, #0]

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3640:	2600      	movs	r6, #0

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3642:	429c      	cmp	r4, r3
    3644:	d337      	bcc.n	36b6 <xTaskIncrementTick+0xba>
    3646:	2600      	movs	r6, #0
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3648:	4d29      	ldr	r5, [pc, #164]	; (36f0 <xTaskIncrementTick+0xf4>)
    364a:	682b      	ldr	r3, [r5, #0]
    364c:	681b      	ldr	r3, [r3, #0]
    364e:	2b00      	cmp	r3, #0
    3650:	d104      	bne.n	365c <xTaskIncrementTick+0x60>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3652:	2201      	movs	r2, #1
    3654:	4252      	negs	r2, r2
    3656:	4b2a      	ldr	r3, [pc, #168]	; (3700 <xTaskIncrementTick+0x104>)
    3658:	601a      	str	r2, [r3, #0]
						break;
    365a:	e02c      	b.n	36b6 <xTaskIncrementTick+0xba>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    365c:	4b24      	ldr	r3, [pc, #144]	; (36f0 <xTaskIncrementTick+0xf4>)
    365e:	681b      	ldr	r3, [r3, #0]
    3660:	68db      	ldr	r3, [r3, #12]
    3662:	68df      	ldr	r7, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3664:	687b      	ldr	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
    3666:	429c      	cmp	r4, r3
    3668:	d202      	bcs.n	3670 <xTaskIncrementTick+0x74>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    366a:	4a25      	ldr	r2, [pc, #148]	; (3700 <xTaskIncrementTick+0x104>)
    366c:	6013      	str	r3, [r2, #0]
							break;
    366e:	e022      	b.n	36b6 <xTaskIncrementTick+0xba>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3670:	1d3b      	adds	r3, r7, #4
    3672:	9301      	str	r3, [sp, #4]
    3674:	1c18      	adds	r0, r3, #0
    3676:	4b23      	ldr	r3, [pc, #140]	; (3704 <xTaskIncrementTick+0x108>)
    3678:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    367a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    367c:	2b00      	cmp	r3, #0
    367e:	d003      	beq.n	3688 <xTaskIncrementTick+0x8c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3680:	1c38      	adds	r0, r7, #0
    3682:	3018      	adds	r0, #24
    3684:	4b1f      	ldr	r3, [pc, #124]	; (3704 <xTaskIncrementTick+0x108>)
    3686:	4798      	blx	r3
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3688:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    368a:	4a1f      	ldr	r2, [pc, #124]	; (3708 <xTaskIncrementTick+0x10c>)
    368c:	6812      	ldr	r2, [r2, #0]
    368e:	4293      	cmp	r3, r2
    3690:	d901      	bls.n	3696 <xTaskIncrementTick+0x9a>
    3692:	4a1d      	ldr	r2, [pc, #116]	; (3708 <xTaskIncrementTick+0x10c>)
    3694:	6013      	str	r3, [r2, #0]
    3696:	0098      	lsls	r0, r3, #2
    3698:	18c3      	adds	r3, r0, r3
    369a:	009b      	lsls	r3, r3, #2
    369c:	481b      	ldr	r0, [pc, #108]	; (370c <xTaskIncrementTick+0x110>)
    369e:	18c0      	adds	r0, r0, r3
    36a0:	9901      	ldr	r1, [sp, #4]
    36a2:	4b1b      	ldr	r3, [pc, #108]	; (3710 <xTaskIncrementTick+0x114>)
    36a4:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    36a6:	4b1b      	ldr	r3, [pc, #108]	; (3714 <xTaskIncrementTick+0x118>)
    36a8:	681b      	ldr	r3, [r3, #0]
    36aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    36ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    36ae:	429a      	cmp	r2, r3
    36b0:	d3cb      	bcc.n	364a <xTaskIncrementTick+0x4e>
							{
								xSwitchRequired = pdTRUE;
    36b2:	2601      	movs	r6, #1
    36b4:	e7c9      	b.n	364a <xTaskIncrementTick+0x4e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    36b6:	4b17      	ldr	r3, [pc, #92]	; (3714 <xTaskIncrementTick+0x118>)
    36b8:	681b      	ldr	r3, [r3, #0]
    36ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    36bc:	009a      	lsls	r2, r3, #2
    36be:	18d3      	adds	r3, r2, r3
    36c0:	009b      	lsls	r3, r3, #2
    36c2:	4a12      	ldr	r2, [pc, #72]	; (370c <xTaskIncrementTick+0x110>)
    36c4:	589b      	ldr	r3, [r3, r2]
    36c6:	2b01      	cmp	r3, #1
    36c8:	d906      	bls.n	36d8 <xTaskIncrementTick+0xdc>
			{
				xSwitchRequired = pdTRUE;
    36ca:	2601      	movs	r6, #1
    36cc:	e004      	b.n	36d8 <xTaskIncrementTick+0xdc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    36ce:	4a12      	ldr	r2, [pc, #72]	; (3718 <xTaskIncrementTick+0x11c>)
    36d0:	6813      	ldr	r3, [r2, #0]
    36d2:	3301      	adds	r3, #1
    36d4:	6013      	str	r3, [r2, #0]

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    36d6:	2600      	movs	r6, #0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    36d8:	4b10      	ldr	r3, [pc, #64]	; (371c <xTaskIncrementTick+0x120>)
    36da:	681b      	ldr	r3, [r3, #0]
    36dc:	2b00      	cmp	r3, #0
    36de:	d000      	beq.n	36e2 <xTaskIncrementTick+0xe6>
		{
			xSwitchRequired = pdTRUE;
    36e0:	2601      	movs	r6, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    36e2:	1c30      	adds	r0, r6, #0
    36e4:	b003      	add	sp, #12
    36e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    36e8:	20003fe8 	.word	0x20003fe8
    36ec:	20003fec 	.word	0x20003fec
    36f0:	20003f20 	.word	0x20003f20
    36f4:	20003ff0 	.word	0x20003ff0
    36f8:	20003f1c 	.word	0x20003f1c
    36fc:	00003279 	.word	0x00003279
    3700:	2000001c 	.word	0x2000001c
    3704:	00002939 	.word	0x00002939
    3708:	20004010 	.word	0x20004010
    370c:	20003f58 	.word	0x20003f58
    3710:	000028f1 	.word	0x000028f1
    3714:	20003fd0 	.word	0x20003fd0
    3718:	20003f54 	.word	0x20003f54
    371c:	20004014 	.word	0x20004014

00003720 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
    3722:	4b2f      	ldr	r3, [pc, #188]	; (37e0 <xTaskResumeAll+0xc0>)
    3724:	681b      	ldr	r3, [r3, #0]
    3726:	2b00      	cmp	r3, #0
    3728:	d101      	bne.n	372e <xTaskResumeAll+0xe>
    372a:	b672      	cpsid	i
    372c:	e7fe      	b.n	372c <xTaskResumeAll+0xc>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    372e:	4b2d      	ldr	r3, [pc, #180]	; (37e4 <xTaskResumeAll+0xc4>)
    3730:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
    3732:	4b2b      	ldr	r3, [pc, #172]	; (37e0 <xTaskResumeAll+0xc0>)
    3734:	681a      	ldr	r2, [r3, #0]
    3736:	3a01      	subs	r2, #1
    3738:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    373a:	681b      	ldr	r3, [r3, #0]
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    373c:	2400      	movs	r4, #0
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    373e:	2b00      	cmp	r3, #0
    3740:	d14a      	bne.n	37d8 <xTaskResumeAll+0xb8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3742:	4b29      	ldr	r3, [pc, #164]	; (37e8 <xTaskResumeAll+0xc8>)
    3744:	681b      	ldr	r3, [r3, #0]
    3746:	2b00      	cmp	r3, #0
    3748:	d123      	bne.n	3792 <xTaskResumeAll+0x72>
    374a:	e045      	b.n	37d8 <xTaskResumeAll+0xb8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    374c:	68fb      	ldr	r3, [r7, #12]
    374e:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3750:	1c30      	adds	r0, r6, #0
    3752:	3018      	adds	r0, #24
    3754:	4b25      	ldr	r3, [pc, #148]	; (37ec <xTaskResumeAll+0xcc>)
    3756:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3758:	1d35      	adds	r5, r6, #4
    375a:	1c28      	adds	r0, r5, #0
    375c:	4b23      	ldr	r3, [pc, #140]	; (37ec <xTaskResumeAll+0xcc>)
    375e:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    3760:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    3762:	4a23      	ldr	r2, [pc, #140]	; (37f0 <xTaskResumeAll+0xd0>)
    3764:	6812      	ldr	r2, [r2, #0]
    3766:	4293      	cmp	r3, r2
    3768:	d901      	bls.n	376e <xTaskResumeAll+0x4e>
    376a:	4a21      	ldr	r2, [pc, #132]	; (37f0 <xTaskResumeAll+0xd0>)
    376c:	6013      	str	r3, [r2, #0]
    376e:	0098      	lsls	r0, r3, #2
    3770:	18c3      	adds	r3, r0, r3
    3772:	009b      	lsls	r3, r3, #2
    3774:	481f      	ldr	r0, [pc, #124]	; (37f4 <xTaskResumeAll+0xd4>)
    3776:	18c0      	adds	r0, r0, r3
    3778:	1c29      	adds	r1, r5, #0
    377a:	4b1f      	ldr	r3, [pc, #124]	; (37f8 <xTaskResumeAll+0xd8>)
    377c:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    377e:	4b1f      	ldr	r3, [pc, #124]	; (37fc <xTaskResumeAll+0xdc>)
    3780:	681b      	ldr	r3, [r3, #0]
    3782:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    3784:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3786:	429a      	cmp	r2, r3
    3788:	d305      	bcc.n	3796 <xTaskResumeAll+0x76>
					{
						xYieldPending = pdTRUE;
    378a:	2201      	movs	r2, #1
    378c:	4b1c      	ldr	r3, [pc, #112]	; (3800 <xTaskResumeAll+0xe0>)
    378e:	601a      	str	r2, [r3, #0]
    3790:	e001      	b.n	3796 <xTaskResumeAll+0x76>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3792:	4c1c      	ldr	r4, [pc, #112]	; (3804 <xTaskResumeAll+0xe4>)
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3794:	1c27      	adds	r7, r4, #0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3796:	6823      	ldr	r3, [r4, #0]
    3798:	2b00      	cmp	r3, #0
    379a:	d1d7      	bne.n	374c <xTaskResumeAll+0x2c>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    379c:	4b1a      	ldr	r3, [pc, #104]	; (3808 <xTaskResumeAll+0xe8>)
    379e:	681b      	ldr	r3, [r3, #0]
    37a0:	2b00      	cmp	r3, #0
    37a2:	d011      	beq.n	37c8 <xTaskResumeAll+0xa8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    37a4:	4b18      	ldr	r3, [pc, #96]	; (3808 <xTaskResumeAll+0xe8>)
    37a6:	681b      	ldr	r3, [r3, #0]
    37a8:	2b00      	cmp	r3, #0
    37aa:	d00d      	beq.n	37c8 <xTaskResumeAll+0xa8>
					{
						if( xTaskIncrementTick() != pdFALSE )
    37ac:	4e17      	ldr	r6, [pc, #92]	; (380c <xTaskResumeAll+0xec>)
						{
							xYieldPending = pdTRUE;
    37ae:	4d14      	ldr	r5, [pc, #80]	; (3800 <xTaskResumeAll+0xe0>)
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    37b0:	4c15      	ldr	r4, [pc, #84]	; (3808 <xTaskResumeAll+0xe8>)
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    37b2:	47b0      	blx	r6
    37b4:	2800      	cmp	r0, #0
    37b6:	d001      	beq.n	37bc <xTaskResumeAll+0x9c>
						{
							xYieldPending = pdTRUE;
    37b8:	2301      	movs	r3, #1
    37ba:	602b      	str	r3, [r5, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    37bc:	6823      	ldr	r3, [r4, #0]
    37be:	3b01      	subs	r3, #1
    37c0:	6023      	str	r3, [r4, #0]
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    37c2:	6823      	ldr	r3, [r4, #0]
    37c4:	2b00      	cmp	r3, #0
    37c6:	d1f4      	bne.n	37b2 <xTaskResumeAll+0x92>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    37c8:	4b0d      	ldr	r3, [pc, #52]	; (3800 <xTaskResumeAll+0xe0>)
    37ca:	681b      	ldr	r3, [r3, #0]
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    37cc:	2400      	movs	r4, #0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    37ce:	2b01      	cmp	r3, #1
    37d0:	d102      	bne.n	37d8 <xTaskResumeAll+0xb8>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    37d2:	4b0f      	ldr	r3, [pc, #60]	; (3810 <xTaskResumeAll+0xf0>)
    37d4:	4798      	blx	r3

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    37d6:	3401      	adds	r4, #1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    37d8:	4b0e      	ldr	r3, [pc, #56]	; (3814 <xTaskResumeAll+0xf4>)
    37da:	4798      	blx	r3

	return xAlreadyYielded;
}
    37dc:	1c20      	adds	r0, r4, #0
    37de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    37e0:	20003fe8 	.word	0x20003fe8
    37e4:	000029cd 	.word	0x000029cd
    37e8:	20003ff8 	.word	0x20003ff8
    37ec:	00002939 	.word	0x00002939
    37f0:	20004010 	.word	0x20004010
    37f4:	20003f58 	.word	0x20003f58
    37f8:	000028f1 	.word	0x000028f1
    37fc:	20003fd0 	.word	0x20003fd0
    3800:	20004014 	.word	0x20004014
    3804:	20003fd4 	.word	0x20003fd4
    3808:	20003f54 	.word	0x20003f54
    380c:	000035fd 	.word	0x000035fd
    3810:	000029b5 	.word	0x000029b5
    3814:	000029e5 	.word	0x000029e5

00003818 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3818:	b510      	push	{r4, lr}
    381a:	1e04      	subs	r4, r0, #0
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    381c:	d016      	beq.n	384c <vTaskDelay+0x34>
		{
			configASSERT( uxSchedulerSuspended == 0 );
    381e:	4b0d      	ldr	r3, [pc, #52]	; (3854 <vTaskDelay+0x3c>)
    3820:	681b      	ldr	r3, [r3, #0]
    3822:	2b00      	cmp	r3, #0
    3824:	d001      	beq.n	382a <vTaskDelay+0x12>
    3826:	b672      	cpsid	i
    3828:	e7fe      	b.n	3828 <vTaskDelay+0x10>
			vTaskSuspendAll();
    382a:	4b0b      	ldr	r3, [pc, #44]	; (3858 <vTaskDelay+0x40>)
    382c:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    382e:	4b0b      	ldr	r3, [pc, #44]	; (385c <vTaskDelay+0x44>)
    3830:	681b      	ldr	r3, [r3, #0]
    3832:	18e4      	adds	r4, r4, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3834:	4b0a      	ldr	r3, [pc, #40]	; (3860 <vTaskDelay+0x48>)
    3836:	6818      	ldr	r0, [r3, #0]
    3838:	3004      	adds	r0, #4
    383a:	4b0a      	ldr	r3, [pc, #40]	; (3864 <vTaskDelay+0x4c>)
    383c:	4798      	blx	r3
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    383e:	1c20      	adds	r0, r4, #0
    3840:	4b09      	ldr	r3, [pc, #36]	; (3868 <vTaskDelay+0x50>)
    3842:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
    3844:	4b09      	ldr	r3, [pc, #36]	; (386c <vTaskDelay+0x54>)
    3846:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3848:	2800      	cmp	r0, #0
    384a:	d101      	bne.n	3850 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    384c:	4b08      	ldr	r3, [pc, #32]	; (3870 <vTaskDelay+0x58>)
    384e:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3850:	bd10      	pop	{r4, pc}
    3852:	46c0      	nop			; (mov r8, r8)
    3854:	20003fe8 	.word	0x20003fe8
    3858:	000035cd 	.word	0x000035cd
    385c:	20003fec 	.word	0x20003fec
    3860:	20003fd0 	.word	0x20003fd0
    3864:	00002939 	.word	0x00002939
    3868:	000032a5 	.word	0x000032a5
    386c:	00003721 	.word	0x00003721
    3870:	000029b5 	.word	0x000029b5

00003874 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3874:	b5f0      	push	{r4, r5, r6, r7, lr}
    3876:	4647      	mov	r7, r8
    3878:	b480      	push	{r7}
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    387a:	4d16      	ldr	r5, [pc, #88]	; (38d4 <prvIdleTask+0x60>)
		{
			vTaskSuspendAll();
    387c:	4f16      	ldr	r7, [pc, #88]	; (38d8 <prvIdleTask+0x64>)
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    387e:	4e17      	ldr	r6, [pc, #92]	; (38dc <prvIdleTask+0x68>)
    3880:	e01d      	b.n	38be <prvIdleTask+0x4a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    3882:	47b8      	blx	r7
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3884:	6834      	ldr	r4, [r6, #0]
			}
			( void ) xTaskResumeAll();
    3886:	4b16      	ldr	r3, [pc, #88]	; (38e0 <prvIdleTask+0x6c>)
    3888:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
    388a:	2c00      	cmp	r4, #0
    388c:	d017      	beq.n	38be <prvIdleTask+0x4a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    388e:	4b15      	ldr	r3, [pc, #84]	; (38e4 <prvIdleTask+0x70>)
    3890:	4798      	blx	r3
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    3892:	4b12      	ldr	r3, [pc, #72]	; (38dc <prvIdleTask+0x68>)
    3894:	68db      	ldr	r3, [r3, #12]
    3896:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3898:	1d20      	adds	r0, r4, #4
    389a:	4b13      	ldr	r3, [pc, #76]	; (38e8 <prvIdleTask+0x74>)
    389c:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
    389e:	4a13      	ldr	r2, [pc, #76]	; (38ec <prvIdleTask+0x78>)
    38a0:	6813      	ldr	r3, [r2, #0]
    38a2:	3b01      	subs	r3, #1
    38a4:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
    38a6:	4a0b      	ldr	r2, [pc, #44]	; (38d4 <prvIdleTask+0x60>)
    38a8:	6813      	ldr	r3, [r2, #0]
    38aa:	3b01      	subs	r3, #1
    38ac:	6013      	str	r3, [r2, #0]
				}
				taskEXIT_CRITICAL();
    38ae:	4b10      	ldr	r3, [pc, #64]	; (38f0 <prvIdleTask+0x7c>)
    38b0:	4798      	blx	r3
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    38b2:	6b20      	ldr	r0, [r4, #48]	; 0x30
    38b4:	4b0f      	ldr	r3, [pc, #60]	; (38f4 <prvIdleTask+0x80>)
    38b6:	4698      	mov	r8, r3
    38b8:	4798      	blx	r3
		vPortFree( pxTCB );
    38ba:	1c20      	adds	r0, r4, #0
    38bc:	47c0      	blx	r8
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    38be:	682b      	ldr	r3, [r5, #0]
    38c0:	2b00      	cmp	r3, #0
    38c2:	d1de      	bne.n	3882 <prvIdleTask+0xe>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    38c4:	4b0c      	ldr	r3, [pc, #48]	; (38f8 <prvIdleTask+0x84>)
    38c6:	681b      	ldr	r3, [r3, #0]
    38c8:	2b01      	cmp	r3, #1
    38ca:	d9f8      	bls.n	38be <prvIdleTask+0x4a>
			{
				taskYIELD();
    38cc:	4b0b      	ldr	r3, [pc, #44]	; (38fc <prvIdleTask+0x88>)
    38ce:	4798      	blx	r3
    38d0:	e7f5      	b.n	38be <prvIdleTask+0x4a>
    38d2:	46c0      	nop			; (mov r8, r8)
    38d4:	20003f28 	.word	0x20003f28
    38d8:	000035cd 	.word	0x000035cd
    38dc:	20003fbc 	.word	0x20003fbc
    38e0:	00003721 	.word	0x00003721
    38e4:	000029cd 	.word	0x000029cd
    38e8:	00002939 	.word	0x00002939
    38ec:	20003ff8 	.word	0x20003ff8
    38f0:	000029e5 	.word	0x000029e5
    38f4:	00002b6d 	.word	0x00002b6d
    38f8:	20003f58 	.word	0x20003f58
    38fc:	000029b5 	.word	0x000029b5

00003900 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3900:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3902:	4b25      	ldr	r3, [pc, #148]	; (3998 <vTaskSwitchContext+0x98>)
    3904:	681b      	ldr	r3, [r3, #0]
    3906:	2b00      	cmp	r3, #0
    3908:	d003      	beq.n	3912 <vTaskSwitchContext+0x12>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    390a:	2201      	movs	r2, #1
    390c:	4b23      	ldr	r3, [pc, #140]	; (399c <vTaskSwitchContext+0x9c>)
    390e:	601a      	str	r2, [r3, #0]
    3910:	e041      	b.n	3996 <vTaskSwitchContext+0x96>
	}
	else
	{
		xYieldPending = pdFALSE;
    3912:	2200      	movs	r2, #0
    3914:	4b21      	ldr	r3, [pc, #132]	; (399c <vTaskSwitchContext+0x9c>)
    3916:	601a      	str	r2, [r3, #0]
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    3918:	4b21      	ldr	r3, [pc, #132]	; (39a0 <vTaskSwitchContext+0xa0>)
    391a:	681b      	ldr	r3, [r3, #0]
    391c:	009a      	lsls	r2, r3, #2
    391e:	18d3      	adds	r3, r2, r3
    3920:	009b      	lsls	r3, r3, #2
    3922:	4a20      	ldr	r2, [pc, #128]	; (39a4 <vTaskSwitchContext+0xa4>)
    3924:	589b      	ldr	r3, [r3, r2]
    3926:	2b00      	cmp	r3, #0
    3928:	d116      	bne.n	3958 <vTaskSwitchContext+0x58>
    392a:	4b1d      	ldr	r3, [pc, #116]	; (39a0 <vTaskSwitchContext+0xa0>)
    392c:	681b      	ldr	r3, [r3, #0]
    392e:	2b00      	cmp	r3, #0
    3930:	d006      	beq.n	3940 <vTaskSwitchContext+0x40>
    3932:	4a1b      	ldr	r2, [pc, #108]	; (39a0 <vTaskSwitchContext+0xa0>)
    3934:	4c1b      	ldr	r4, [pc, #108]	; (39a4 <vTaskSwitchContext+0xa4>)
    3936:	1c10      	adds	r0, r2, #0
    3938:	e004      	b.n	3944 <vTaskSwitchContext+0x44>
    393a:	6803      	ldr	r3, [r0, #0]
    393c:	2b00      	cmp	r3, #0
    393e:	d101      	bne.n	3944 <vTaskSwitchContext+0x44>
    3940:	b672      	cpsid	i
    3942:	e7fe      	b.n	3942 <vTaskSwitchContext+0x42>
    3944:	6813      	ldr	r3, [r2, #0]
    3946:	3b01      	subs	r3, #1
    3948:	6013      	str	r3, [r2, #0]
    394a:	6813      	ldr	r3, [r2, #0]
    394c:	0099      	lsls	r1, r3, #2
    394e:	18cb      	adds	r3, r1, r3
    3950:	009b      	lsls	r3, r3, #2
    3952:	591b      	ldr	r3, [r3, r4]
    3954:	2b00      	cmp	r3, #0
    3956:	d0f0      	beq.n	393a <vTaskSwitchContext+0x3a>
    3958:	4b11      	ldr	r3, [pc, #68]	; (39a0 <vTaskSwitchContext+0xa0>)
    395a:	681b      	ldr	r3, [r3, #0]
    395c:	4c11      	ldr	r4, [pc, #68]	; (39a4 <vTaskSwitchContext+0xa4>)
    395e:	009a      	lsls	r2, r3, #2
    3960:	18d1      	adds	r1, r2, r3
    3962:	0089      	lsls	r1, r1, #2
    3964:	1861      	adds	r1, r4, r1
    3966:	6848      	ldr	r0, [r1, #4]
    3968:	6840      	ldr	r0, [r0, #4]
    396a:	6048      	str	r0, [r1, #4]
    396c:	18d2      	adds	r2, r2, r3
    396e:	0092      	lsls	r2, r2, #2
    3970:	3208      	adds	r2, #8
    3972:	18a2      	adds	r2, r4, r2
    3974:	4290      	cmp	r0, r2
    3976:	d105      	bne.n	3984 <vTaskSwitchContext+0x84>
    3978:	6841      	ldr	r1, [r0, #4]
    397a:	009a      	lsls	r2, r3, #2
    397c:	18d2      	adds	r2, r2, r3
    397e:	0092      	lsls	r2, r2, #2
    3980:	18a2      	adds	r2, r4, r2
    3982:	6051      	str	r1, [r2, #4]
    3984:	009a      	lsls	r2, r3, #2
    3986:	18d3      	adds	r3, r2, r3
    3988:	009b      	lsls	r3, r3, #2
    398a:	4a06      	ldr	r2, [pc, #24]	; (39a4 <vTaskSwitchContext+0xa4>)
    398c:	18d3      	adds	r3, r2, r3
    398e:	685b      	ldr	r3, [r3, #4]
    3990:	68da      	ldr	r2, [r3, #12]
    3992:	4b05      	ldr	r3, [pc, #20]	; (39a8 <vTaskSwitchContext+0xa8>)
    3994:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3996:	bd10      	pop	{r4, pc}
    3998:	20003fe8 	.word	0x20003fe8
    399c:	20004014 	.word	0x20004014
    39a0:	20004010 	.word	0x20004010
    39a4:	20003f58 	.word	0x20003f58
    39a8:	20003fd0 	.word	0x20003fd0

000039ac <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    39ac:	b538      	push	{r3, r4, r5, lr}
    39ae:	1c04      	adds	r4, r0, #0
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    39b0:	4b1f      	ldr	r3, [pc, #124]	; (3a30 <vTaskSuspend+0x84>)
    39b2:	4798      	blx	r3
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    39b4:	2c00      	cmp	r4, #0
    39b6:	d101      	bne.n	39bc <vTaskSuspend+0x10>
    39b8:	4b1e      	ldr	r3, [pc, #120]	; (3a34 <vTaskSuspend+0x88>)
    39ba:	681c      	ldr	r4, [r3, #0]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    39bc:	1d25      	adds	r5, r4, #4
    39be:	1c28      	adds	r0, r5, #0
    39c0:	4b1d      	ldr	r3, [pc, #116]	; (3a38 <vTaskSuspend+0x8c>)
    39c2:	4798      	blx	r3
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    39c4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    39c6:	2b00      	cmp	r3, #0
    39c8:	d003      	beq.n	39d2 <vTaskSuspend+0x26>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    39ca:	1c20      	adds	r0, r4, #0
    39cc:	3018      	adds	r0, #24
    39ce:	4b1a      	ldr	r3, [pc, #104]	; (3a38 <vTaskSuspend+0x8c>)
    39d0:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    39d2:	481a      	ldr	r0, [pc, #104]	; (3a3c <vTaskSuspend+0x90>)
    39d4:	1c29      	adds	r1, r5, #0
    39d6:	4b1a      	ldr	r3, [pc, #104]	; (3a40 <vTaskSuspend+0x94>)
    39d8:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();
    39da:	4b1a      	ldr	r3, [pc, #104]	; (3a44 <vTaskSuspend+0x98>)
    39dc:	4798      	blx	r3

		if( pxTCB == pxCurrentTCB )
    39de:	4b15      	ldr	r3, [pc, #84]	; (3a34 <vTaskSuspend+0x88>)
    39e0:	681b      	ldr	r3, [r3, #0]
    39e2:	429c      	cmp	r4, r3
    39e4:	d119      	bne.n	3a1a <vTaskSuspend+0x6e>
		{
			if( xSchedulerRunning != pdFALSE )
    39e6:	4b18      	ldr	r3, [pc, #96]	; (3a48 <vTaskSuspend+0x9c>)
    39e8:	681b      	ldr	r3, [r3, #0]
    39ea:	2b00      	cmp	r3, #0
    39ec:	d008      	beq.n	3a00 <vTaskSuspend+0x54>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
    39ee:	4b17      	ldr	r3, [pc, #92]	; (3a4c <vTaskSuspend+0xa0>)
    39f0:	681b      	ldr	r3, [r3, #0]
    39f2:	2b00      	cmp	r3, #0
    39f4:	d001      	beq.n	39fa <vTaskSuspend+0x4e>
    39f6:	b672      	cpsid	i
    39f8:	e7fe      	b.n	39f8 <vTaskSuspend+0x4c>
				portYIELD_WITHIN_API();
    39fa:	4b15      	ldr	r3, [pc, #84]	; (3a50 <vTaskSuspend+0xa4>)
    39fc:	4798      	blx	r3
    39fe:	e016      	b.n	3a2e <vTaskSuspend+0x82>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    3a00:	4b14      	ldr	r3, [pc, #80]	; (3a54 <vTaskSuspend+0xa8>)
    3a02:	681b      	ldr	r3, [r3, #0]
    3a04:	4a0d      	ldr	r2, [pc, #52]	; (3a3c <vTaskSuspend+0x90>)
    3a06:	6812      	ldr	r2, [r2, #0]
    3a08:	429a      	cmp	r2, r3
    3a0a:	d103      	bne.n	3a14 <vTaskSuspend+0x68>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3a0c:	2200      	movs	r2, #0
    3a0e:	4b09      	ldr	r3, [pc, #36]	; (3a34 <vTaskSuspend+0x88>)
    3a10:	601a      	str	r2, [r3, #0]
    3a12:	e00c      	b.n	3a2e <vTaskSuspend+0x82>
				}
				else
				{
					vTaskSwitchContext();
    3a14:	4b10      	ldr	r3, [pc, #64]	; (3a58 <vTaskSuspend+0xac>)
    3a16:	4798      	blx	r3
    3a18:	e009      	b.n	3a2e <vTaskSuspend+0x82>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    3a1a:	4b0b      	ldr	r3, [pc, #44]	; (3a48 <vTaskSuspend+0x9c>)
    3a1c:	681b      	ldr	r3, [r3, #0]
    3a1e:	2b00      	cmp	r3, #0
    3a20:	d005      	beq.n	3a2e <vTaskSuspend+0x82>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    3a22:	4b03      	ldr	r3, [pc, #12]	; (3a30 <vTaskSuspend+0x84>)
    3a24:	4798      	blx	r3
				{
					prvResetNextTaskUnblockTime();
    3a26:	4b0d      	ldr	r3, [pc, #52]	; (3a5c <vTaskSuspend+0xb0>)
    3a28:	4798      	blx	r3
				}
				taskEXIT_CRITICAL();
    3a2a:	4b06      	ldr	r3, [pc, #24]	; (3a44 <vTaskSuspend+0x98>)
    3a2c:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3a2e:	bd38      	pop	{r3, r4, r5, pc}
    3a30:	000029cd 	.word	0x000029cd
    3a34:	20003fd0 	.word	0x20003fd0
    3a38:	00002939 	.word	0x00002939
    3a3c:	20003ffc 	.word	0x20003ffc
    3a40:	000028f1 	.word	0x000028f1
    3a44:	000029e5 	.word	0x000029e5
    3a48:	20003f24 	.word	0x20003f24
    3a4c:	20003fe8 	.word	0x20003fe8
    3a50:	000029b5 	.word	0x000029b5
    3a54:	20003ff8 	.word	0x20003ff8
    3a58:	00003901 	.word	0x00003901
    3a5c:	00003279 	.word	0x00003279

00003a60 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3a60:	b538      	push	{r3, r4, r5, lr}
TickType_t xTimeToWake;

	configASSERT( pxEventList );
    3a62:	2800      	cmp	r0, #0
    3a64:	d101      	bne.n	3a6a <vTaskPlaceOnEventList+0xa>
    3a66:	b672      	cpsid	i
    3a68:	e7fe      	b.n	3a68 <vTaskPlaceOnEventList+0x8>
    3a6a:	1c0c      	adds	r4, r1, #0

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3a6c:	4d0b      	ldr	r5, [pc, #44]	; (3a9c <vTaskPlaceOnEventList+0x3c>)
    3a6e:	6829      	ldr	r1, [r5, #0]
    3a70:	3118      	adds	r1, #24
    3a72:	4b0b      	ldr	r3, [pc, #44]	; (3aa0 <vTaskPlaceOnEventList+0x40>)
    3a74:	4798      	blx	r3

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3a76:	6828      	ldr	r0, [r5, #0]
    3a78:	3004      	adds	r0, #4
    3a7a:	4b0a      	ldr	r3, [pc, #40]	; (3aa4 <vTaskPlaceOnEventList+0x44>)
    3a7c:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3a7e:	1c63      	adds	r3, r4, #1
    3a80:	d106      	bne.n	3a90 <vTaskPlaceOnEventList+0x30>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3a82:	4b06      	ldr	r3, [pc, #24]	; (3a9c <vTaskPlaceOnEventList+0x3c>)
    3a84:	6819      	ldr	r1, [r3, #0]
    3a86:	3104      	adds	r1, #4
    3a88:	4807      	ldr	r0, [pc, #28]	; (3aa8 <vTaskPlaceOnEventList+0x48>)
    3a8a:	4b08      	ldr	r3, [pc, #32]	; (3aac <vTaskPlaceOnEventList+0x4c>)
    3a8c:	4798      	blx	r3
    3a8e:	e004      	b.n	3a9a <vTaskPlaceOnEventList+0x3a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3a90:	4b07      	ldr	r3, [pc, #28]	; (3ab0 <vTaskPlaceOnEventList+0x50>)
    3a92:	6818      	ldr	r0, [r3, #0]
    3a94:	1820      	adds	r0, r4, r0
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a96:	4b07      	ldr	r3, [pc, #28]	; (3ab4 <vTaskPlaceOnEventList+0x54>)
    3a98:	4798      	blx	r3
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3a9a:	bd38      	pop	{r3, r4, r5, pc}
    3a9c:	20003fd0 	.word	0x20003fd0
    3aa0:	00002909 	.word	0x00002909
    3aa4:	00002939 	.word	0x00002939
    3aa8:	20003ffc 	.word	0x20003ffc
    3aac:	000028f1 	.word	0x000028f1
    3ab0:	20003fec 	.word	0x20003fec
    3ab4:	000032a5 	.word	0x000032a5

00003ab8 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
	{
    3ab8:	b538      	push	{r3, r4, r5, lr}
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
    3aba:	2800      	cmp	r0, #0
    3abc:	d101      	bne.n	3ac2 <vTaskPlaceOnEventListRestricted+0xa>
    3abe:	b672      	cpsid	i
    3ac0:	e7fe      	b.n	3ac0 <vTaskPlaceOnEventListRestricted+0x8>
    3ac2:	1c0c      	adds	r4, r1, #0

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3ac4:	4d07      	ldr	r5, [pc, #28]	; (3ae4 <vTaskPlaceOnEventListRestricted+0x2c>)
    3ac6:	6829      	ldr	r1, [r5, #0]
    3ac8:	3118      	adds	r1, #24
    3aca:	4b07      	ldr	r3, [pc, #28]	; (3ae8 <vTaskPlaceOnEventListRestricted+0x30>)
    3acc:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3ace:	6828      	ldr	r0, [r5, #0]
    3ad0:	3004      	adds	r0, #4
    3ad2:	4b06      	ldr	r3, [pc, #24]	; (3aec <vTaskPlaceOnEventListRestricted+0x34>)
    3ad4:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
    3ad6:	4b06      	ldr	r3, [pc, #24]	; (3af0 <vTaskPlaceOnEventListRestricted+0x38>)
    3ad8:	6818      	ldr	r0, [r3, #0]
    3ada:	1820      	adds	r0, r4, r0

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
    3adc:	4b05      	ldr	r3, [pc, #20]	; (3af4 <vTaskPlaceOnEventListRestricted+0x3c>)
    3ade:	4798      	blx	r3
	}
    3ae0:	bd38      	pop	{r3, r4, r5, pc}
    3ae2:	46c0      	nop			; (mov r8, r8)
    3ae4:	20003fd0 	.word	0x20003fd0
    3ae8:	000028f1 	.word	0x000028f1
    3aec:	00002939 	.word	0x00002939
    3af0:	20003fec 	.word	0x20003fec
    3af4:	000032a5 	.word	0x000032a5

00003af8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3af8:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3afa:	68c3      	ldr	r3, [r0, #12]
    3afc:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
    3afe:	2d00      	cmp	r5, #0
    3b00:	d101      	bne.n	3b06 <xTaskRemoveFromEventList+0xe>
    3b02:	b672      	cpsid	i
    3b04:	e7fe      	b.n	3b04 <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3b06:	1c2c      	adds	r4, r5, #0
    3b08:	3418      	adds	r4, #24
    3b0a:	1c20      	adds	r0, r4, #0
    3b0c:	4b14      	ldr	r3, [pc, #80]	; (3b60 <xTaskRemoveFromEventList+0x68>)
    3b0e:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3b10:	4b14      	ldr	r3, [pc, #80]	; (3b64 <xTaskRemoveFromEventList+0x6c>)
    3b12:	681b      	ldr	r3, [r3, #0]
    3b14:	2b00      	cmp	r3, #0
    3b16:	d113      	bne.n	3b40 <xTaskRemoveFromEventList+0x48>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3b18:	1d2c      	adds	r4, r5, #4
    3b1a:	1c20      	adds	r0, r4, #0
    3b1c:	4b10      	ldr	r3, [pc, #64]	; (3b60 <xTaskRemoveFromEventList+0x68>)
    3b1e:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    3b20:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    3b22:	4a11      	ldr	r2, [pc, #68]	; (3b68 <xTaskRemoveFromEventList+0x70>)
    3b24:	6812      	ldr	r2, [r2, #0]
    3b26:	4293      	cmp	r3, r2
    3b28:	d901      	bls.n	3b2e <xTaskRemoveFromEventList+0x36>
    3b2a:	4a0f      	ldr	r2, [pc, #60]	; (3b68 <xTaskRemoveFromEventList+0x70>)
    3b2c:	6013      	str	r3, [r2, #0]
    3b2e:	0098      	lsls	r0, r3, #2
    3b30:	18c3      	adds	r3, r0, r3
    3b32:	009b      	lsls	r3, r3, #2
    3b34:	480d      	ldr	r0, [pc, #52]	; (3b6c <xTaskRemoveFromEventList+0x74>)
    3b36:	18c0      	adds	r0, r0, r3
    3b38:	1c21      	adds	r1, r4, #0
    3b3a:	4b0d      	ldr	r3, [pc, #52]	; (3b70 <xTaskRemoveFromEventList+0x78>)
    3b3c:	4798      	blx	r3
    3b3e:	e003      	b.n	3b48 <xTaskRemoveFromEventList+0x50>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3b40:	480c      	ldr	r0, [pc, #48]	; (3b74 <xTaskRemoveFromEventList+0x7c>)
    3b42:	1c21      	adds	r1, r4, #0
    3b44:	4b0a      	ldr	r3, [pc, #40]	; (3b70 <xTaskRemoveFromEventList+0x78>)
    3b46:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b48:	4b0b      	ldr	r3, [pc, #44]	; (3b78 <xTaskRemoveFromEventList+0x80>)
    3b4a:	681b      	ldr	r3, [r3, #0]
    3b4c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    3b4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
    3b50:	2000      	movs	r0, #0
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b52:	429a      	cmp	r2, r3
    3b54:	d903      	bls.n	3b5e <xTaskRemoveFromEventList+0x66>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3b56:	2201      	movs	r2, #1
    3b58:	4b08      	ldr	r3, [pc, #32]	; (3b7c <xTaskRemoveFromEventList+0x84>)
    3b5a:	601a      	str	r2, [r3, #0]
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3b5c:	3001      	adds	r0, #1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    3b5e:	bd38      	pop	{r3, r4, r5, pc}
    3b60:	00002939 	.word	0x00002939
    3b64:	20003fe8 	.word	0x20003fe8
    3b68:	20004010 	.word	0x20004010
    3b6c:	20003f58 	.word	0x20003f58
    3b70:	000028f1 	.word	0x000028f1
    3b74:	20003fd4 	.word	0x20003fd4
    3b78:	20003fd0 	.word	0x20003fd0
    3b7c:	20004014 	.word	0x20004014

00003b80 <vTaskSetTimeOutState>:
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
    3b80:	2800      	cmp	r0, #0
    3b82:	d101      	bne.n	3b88 <vTaskSetTimeOutState+0x8>
    3b84:	b672      	cpsid	i
    3b86:	e7fe      	b.n	3b86 <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3b88:	4b03      	ldr	r3, [pc, #12]	; (3b98 <vTaskSetTimeOutState+0x18>)
    3b8a:	681b      	ldr	r3, [r3, #0]
    3b8c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    3b8e:	4b03      	ldr	r3, [pc, #12]	; (3b9c <vTaskSetTimeOutState+0x1c>)
    3b90:	681b      	ldr	r3, [r3, #0]
    3b92:	6043      	str	r3, [r0, #4]
}
    3b94:	4770      	bx	lr
    3b96:	46c0      	nop			; (mov r8, r8)
    3b98:	20003f1c 	.word	0x20003f1c
    3b9c:	20003fec 	.word	0x20003fec

00003ba0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3ba0:	b570      	push	{r4, r5, r6, lr}
BaseType_t xReturn;

	configASSERT( pxTimeOut );
    3ba2:	2800      	cmp	r0, #0
    3ba4:	d101      	bne.n	3baa <xTaskCheckForTimeOut+0xa>
    3ba6:	b672      	cpsid	i
    3ba8:	e7fe      	b.n	3ba8 <xTaskCheckForTimeOut+0x8>
	configASSERT( pxTicksToWait );
    3baa:	2900      	cmp	r1, #0
    3bac:	d101      	bne.n	3bb2 <xTaskCheckForTimeOut+0x12>
    3bae:	b672      	cpsid	i
    3bb0:	e7fe      	b.n	3bb0 <xTaskCheckForTimeOut+0x10>
    3bb2:	1c0d      	adds	r5, r1, #0
    3bb4:	1c04      	adds	r4, r0, #0

	taskENTER_CRITICAL();
    3bb6:	4b11      	ldr	r3, [pc, #68]	; (3bfc <xTaskCheckForTimeOut+0x5c>)
    3bb8:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3bba:	4b11      	ldr	r3, [pc, #68]	; (3c00 <xTaskCheckForTimeOut+0x60>)
    3bbc:	6819      	ldr	r1, [r3, #0]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    3bbe:	682b      	ldr	r3, [r5, #0]
    3bc0:	1c5a      	adds	r2, r3, #1
    3bc2:	d015      	beq.n	3bf0 <xTaskCheckForTimeOut+0x50>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3bc4:	4a0f      	ldr	r2, [pc, #60]	; (3c04 <xTaskCheckForTimeOut+0x64>)
    3bc6:	6812      	ldr	r2, [r2, #0]
    3bc8:	6820      	ldr	r0, [r4, #0]
    3bca:	4290      	cmp	r0, r2
    3bcc:	d003      	beq.n	3bd6 <xTaskCheckForTimeOut+0x36>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3bce:	2601      	movs	r6, #1
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3bd0:	6862      	ldr	r2, [r4, #4]
    3bd2:	4291      	cmp	r1, r2
    3bd4:	d20d      	bcs.n	3bf2 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3bd6:	6862      	ldr	r2, [r4, #4]
    3bd8:	1a88      	subs	r0, r1, r2
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    3bda:	2601      	movs	r6, #1
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3bdc:	4283      	cmp	r3, r0
    3bde:	d908      	bls.n	3bf2 <xTaskCheckForTimeOut+0x52>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3be0:	1a52      	subs	r2, r2, r1
    3be2:	18d3      	adds	r3, r2, r3
    3be4:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
    3be6:	1c20      	adds	r0, r4, #0
    3be8:	4b07      	ldr	r3, [pc, #28]	; (3c08 <xTaskCheckForTimeOut+0x68>)
    3bea:	4798      	blx	r3
			xReturn = pdFALSE;
    3bec:	2600      	movs	r6, #0
    3bee:	e000      	b.n	3bf2 <xTaskCheckForTimeOut+0x52>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    3bf0:	2600      	movs	r6, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    3bf2:	4b06      	ldr	r3, [pc, #24]	; (3c0c <xTaskCheckForTimeOut+0x6c>)
    3bf4:	4798      	blx	r3

	return xReturn;
}
    3bf6:	1c30      	adds	r0, r6, #0
    3bf8:	bd70      	pop	{r4, r5, r6, pc}
    3bfa:	46c0      	nop			; (mov r8, r8)
    3bfc:	000029cd 	.word	0x000029cd
    3c00:	20003fec 	.word	0x20003fec
    3c04:	20003f1c 	.word	0x20003f1c
    3c08:	00003b81 	.word	0x00003b81
    3c0c:	000029e5 	.word	0x000029e5

00003c10 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    3c10:	2201      	movs	r2, #1
    3c12:	4b01      	ldr	r3, [pc, #4]	; (3c18 <vTaskMissedYield+0x8>)
    3c14:	601a      	str	r2, [r3, #0]
}
    3c16:	4770      	bx	lr
    3c18:	20004014 	.word	0x20004014

00003c1c <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3c1c:	4b01      	ldr	r3, [pc, #4]	; (3c24 <xTaskGetCurrentTaskHandle+0x8>)
    3c1e:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
    3c20:	4770      	bx	lr
    3c22:	46c0      	nop			; (mov r8, r8)
    3c24:	20003fd0 	.word	0x20003fd0

00003c28 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    3c28:	4b05      	ldr	r3, [pc, #20]	; (3c40 <xTaskGetSchedulerState+0x18>)
    3c2a:	681b      	ldr	r3, [r3, #0]
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    3c2c:	2001      	movs	r0, #1

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    3c2e:	2b00      	cmp	r3, #0
    3c30:	d004      	beq.n	3c3c <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3c32:	4b04      	ldr	r3, [pc, #16]	; (3c44 <xTaskGetSchedulerState+0x1c>)
    3c34:	6818      	ldr	r0, [r3, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    3c36:	4243      	negs	r3, r0
    3c38:	4158      	adcs	r0, r3
    3c3a:	0040      	lsls	r0, r0, #1
			}
		}

		return xReturn;
	}
    3c3c:	4770      	bx	lr
    3c3e:	46c0      	nop			; (mov r8, r8)
    3c40:	20003f24 	.word	0x20003f24
    3c44:	20003fe8 	.word	0x20003fe8

00003c48 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    3c48:	b538      	push	{r3, r4, r5, lr}
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    3c4a:	2800      	cmp	r0, #0
    3c4c:	d032      	beq.n	3cb4 <vTaskPriorityInherit+0x6c>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    3c4e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    3c50:	4a19      	ldr	r2, [pc, #100]	; (3cb8 <vTaskPriorityInherit+0x70>)
    3c52:	6812      	ldr	r2, [r2, #0]
    3c54:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3c56:	4293      	cmp	r3, r2
    3c58:	d22c      	bcs.n	3cb4 <vTaskPriorityInherit+0x6c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3c5a:	6982      	ldr	r2, [r0, #24]
    3c5c:	2a00      	cmp	r2, #0
    3c5e:	db05      	blt.n	3c6c <vTaskPriorityInherit+0x24>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3c60:	4a15      	ldr	r2, [pc, #84]	; (3cb8 <vTaskPriorityInherit+0x70>)
    3c62:	6812      	ldr	r2, [r2, #0]
    3c64:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    3c66:	2205      	movs	r2, #5
    3c68:	1a52      	subs	r2, r2, r1
    3c6a:	6182      	str	r2, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3c6c:	009a      	lsls	r2, r3, #2
    3c6e:	18d3      	adds	r3, r2, r3
    3c70:	009b      	lsls	r3, r3, #2
    3c72:	4a12      	ldr	r2, [pc, #72]	; (3cbc <vTaskPriorityInherit+0x74>)
    3c74:	18d3      	adds	r3, r2, r3
    3c76:	6942      	ldr	r2, [r0, #20]
    3c78:	429a      	cmp	r2, r3
    3c7a:	d117      	bne.n	3cac <vTaskPriorityInherit+0x64>
    3c7c:	1c05      	adds	r5, r0, #0
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3c7e:	1d04      	adds	r4, r0, #4
    3c80:	1c20      	adds	r0, r4, #0
    3c82:	4b0f      	ldr	r3, [pc, #60]	; (3cc0 <vTaskPriorityInherit+0x78>)
    3c84:	4798      	blx	r3
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3c86:	4b0c      	ldr	r3, [pc, #48]	; (3cb8 <vTaskPriorityInherit+0x70>)
    3c88:	681b      	ldr	r3, [r3, #0]
    3c8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3c8c:	62eb      	str	r3, [r5, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
    3c8e:	4a0d      	ldr	r2, [pc, #52]	; (3cc4 <vTaskPriorityInherit+0x7c>)
    3c90:	6812      	ldr	r2, [r2, #0]
    3c92:	4293      	cmp	r3, r2
    3c94:	d901      	bls.n	3c9a <vTaskPriorityInherit+0x52>
    3c96:	4a0b      	ldr	r2, [pc, #44]	; (3cc4 <vTaskPriorityInherit+0x7c>)
    3c98:	6013      	str	r3, [r2, #0]
    3c9a:	0098      	lsls	r0, r3, #2
    3c9c:	18c0      	adds	r0, r0, r3
    3c9e:	0083      	lsls	r3, r0, #2
    3ca0:	4806      	ldr	r0, [pc, #24]	; (3cbc <vTaskPriorityInherit+0x74>)
    3ca2:	18c0      	adds	r0, r0, r3
    3ca4:	1c21      	adds	r1, r4, #0
    3ca6:	4b08      	ldr	r3, [pc, #32]	; (3cc8 <vTaskPriorityInherit+0x80>)
    3ca8:	4798      	blx	r3
    3caa:	e003      	b.n	3cb4 <vTaskPriorityInherit+0x6c>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3cac:	4b02      	ldr	r3, [pc, #8]	; (3cb8 <vTaskPriorityInherit+0x70>)
    3cae:	681b      	ldr	r3, [r3, #0]
    3cb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3cb2:	62c3      	str	r3, [r0, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3cb4:	bd38      	pop	{r3, r4, r5, pc}
    3cb6:	46c0      	nop			; (mov r8, r8)
    3cb8:	20003fd0 	.word	0x20003fd0
    3cbc:	20003f58 	.word	0x20003f58
    3cc0:	00002939 	.word	0x00002939
    3cc4:	20004010 	.word	0x20004010
    3cc8:	000028f1 	.word	0x000028f1

00003ccc <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    3ccc:	b538      	push	{r3, r4, r5, lr}
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3cce:	2800      	cmp	r0, #0
    3cd0:	d01e      	beq.n	3d10 <vTaskPriorityDisinherit+0x44>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3cd2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    3cd4:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    3cd6:	4293      	cmp	r3, r2
    3cd8:	d01a      	beq.n	3d10 <vTaskPriorityDisinherit+0x44>
    3cda:	1c04      	adds	r4, r0, #0
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3cdc:	1d05      	adds	r5, r0, #4
    3cde:	1c28      	adds	r0, r5, #0
    3ce0:	4b0c      	ldr	r3, [pc, #48]	; (3d14 <vTaskPriorityDisinherit+0x48>)
    3ce2:	4798      	blx	r3
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    3ce4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    3ce6:	62e3      	str	r3, [r4, #44]	; 0x2c

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3ce8:	69a2      	ldr	r2, [r4, #24]
    3cea:	2a00      	cmp	r2, #0
    3cec:	db02      	blt.n	3cf4 <vTaskPriorityDisinherit+0x28>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3cee:	2205      	movs	r2, #5
    3cf0:	1ad2      	subs	r2, r2, r3
    3cf2:	61a2      	str	r2, [r4, #24]
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddTaskToReadyList( pxTCB );
    3cf4:	4a08      	ldr	r2, [pc, #32]	; (3d18 <vTaskPriorityDisinherit+0x4c>)
    3cf6:	6812      	ldr	r2, [r2, #0]
    3cf8:	4293      	cmp	r3, r2
    3cfa:	d901      	bls.n	3d00 <vTaskPriorityDisinherit+0x34>
    3cfc:	4a06      	ldr	r2, [pc, #24]	; (3d18 <vTaskPriorityDisinherit+0x4c>)
    3cfe:	6013      	str	r3, [r2, #0]
    3d00:	0098      	lsls	r0, r3, #2
    3d02:	18c0      	adds	r0, r0, r3
    3d04:	0083      	lsls	r3, r0, #2
    3d06:	4805      	ldr	r0, [pc, #20]	; (3d1c <vTaskPriorityDisinherit+0x50>)
    3d08:	18c0      	adds	r0, r0, r3
    3d0a:	1c29      	adds	r1, r5, #0
    3d0c:	4b04      	ldr	r3, [pc, #16]	; (3d20 <vTaskPriorityDisinherit+0x54>)
    3d0e:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3d10:	bd38      	pop	{r3, r4, r5, pc}
    3d12:	46c0      	nop			; (mov r8, r8)
    3d14:	00002939 	.word	0x00002939
    3d18:	20004010 	.word	0x20004010
    3d1c:	20003f58 	.word	0x20003f58
    3d20:	000028f1 	.word	0x000028f1

00003d24 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    3d24:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    3d26:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3d28:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    3d2a:	4291      	cmp	r1, r2
    3d2c:	d80c      	bhi.n	3d48 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    3d2e:	1ad2      	subs	r2, r2, r3
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    3d30:	2401      	movs	r4, #1

	if( xNextExpiryTime <= xTimeNow )
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    3d32:	6983      	ldr	r3, [r0, #24]
    3d34:	429a      	cmp	r2, r3
    3d36:	d213      	bcs.n	3d60 <prvInsertTimerInActiveList+0x3c>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    3d38:	4b0a      	ldr	r3, [pc, #40]	; (3d64 <prvInsertTimerInActiveList+0x40>)
    3d3a:	681b      	ldr	r3, [r3, #0]
    3d3c:	1d01      	adds	r1, r0, #4
    3d3e:	1c18      	adds	r0, r3, #0
    3d40:	4b09      	ldr	r3, [pc, #36]	; (3d68 <prvInsertTimerInActiveList+0x44>)
    3d42:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    3d44:	2400      	movs	r4, #0
    3d46:	e00b      	b.n	3d60 <prvInsertTimerInActiveList+0x3c>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    3d48:	429a      	cmp	r2, r3
    3d4a:	d202      	bcs.n	3d52 <prvInsertTimerInActiveList+0x2e>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    3d4c:	2401      	movs	r4, #1
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    3d4e:	4299      	cmp	r1, r3
    3d50:	d206      	bcs.n	3d60 <prvInsertTimerInActiveList+0x3c>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3d52:	4b06      	ldr	r3, [pc, #24]	; (3d6c <prvInsertTimerInActiveList+0x48>)
    3d54:	681b      	ldr	r3, [r3, #0]
    3d56:	1d01      	adds	r1, r0, #4
    3d58:	1c18      	adds	r0, r3, #0
    3d5a:	4b03      	ldr	r3, [pc, #12]	; (3d68 <prvInsertTimerInActiveList+0x44>)
    3d5c:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    3d5e:	2400      	movs	r4, #0
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    3d60:	1c20      	adds	r0, r4, #0
    3d62:	bd10      	pop	{r4, pc}
    3d64:	2000404c 	.word	0x2000404c
    3d68:	00002909 	.word	0x00002909
    3d6c:	20004018 	.word	0x20004018

00003d70 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    3d70:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    3d72:	4b10      	ldr	r3, [pc, #64]	; (3db4 <prvCheckForValidListAndQueue+0x44>)
    3d74:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    3d76:	4b10      	ldr	r3, [pc, #64]	; (3db8 <prvCheckForValidListAndQueue+0x48>)
    3d78:	681b      	ldr	r3, [r3, #0]
    3d7a:	2b00      	cmp	r3, #0
    3d7c:	d116      	bne.n	3dac <prvCheckForValidListAndQueue+0x3c>
		{
			vListInitialise( &xActiveTimerList1 );
    3d7e:	4d0f      	ldr	r5, [pc, #60]	; (3dbc <prvCheckForValidListAndQueue+0x4c>)
    3d80:	1c28      	adds	r0, r5, #0
    3d82:	4e0f      	ldr	r6, [pc, #60]	; (3dc0 <prvCheckForValidListAndQueue+0x50>)
    3d84:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
    3d86:	4c0f      	ldr	r4, [pc, #60]	; (3dc4 <prvCheckForValidListAndQueue+0x54>)
    3d88:	1c20      	adds	r0, r4, #0
    3d8a:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
    3d8c:	4b0e      	ldr	r3, [pc, #56]	; (3dc8 <prvCheckForValidListAndQueue+0x58>)
    3d8e:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    3d90:	4b0e      	ldr	r3, [pc, #56]	; (3dcc <prvCheckForValidListAndQueue+0x5c>)
    3d92:	601c      	str	r4, [r3, #0]
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    3d94:	2002      	movs	r0, #2
    3d96:	210c      	movs	r1, #12
    3d98:	2200      	movs	r2, #0
    3d9a:	4b0d      	ldr	r3, [pc, #52]	; (3dd0 <prvCheckForValidListAndQueue+0x60>)
    3d9c:	4798      	blx	r3
			configASSERT( xTimerQueue );
    3d9e:	2800      	cmp	r0, #0
    3da0:	d002      	beq.n	3da8 <prvCheckForValidListAndQueue+0x38>
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    3da2:	4b05      	ldr	r3, [pc, #20]	; (3db8 <prvCheckForValidListAndQueue+0x48>)
    3da4:	6018      	str	r0, [r3, #0]
    3da6:	e001      	b.n	3dac <prvCheckForValidListAndQueue+0x3c>
			configASSERT( xTimerQueue );
    3da8:	b672      	cpsid	i
    3daa:	e7fe      	b.n	3daa <prvCheckForValidListAndQueue+0x3a>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3dac:	4b09      	ldr	r3, [pc, #36]	; (3dd4 <prvCheckForValidListAndQueue+0x64>)
    3dae:	4798      	blx	r3
}
    3db0:	bd70      	pop	{r4, r5, r6, pc}
    3db2:	46c0      	nop			; (mov r8, r8)
    3db4:	000029cd 	.word	0x000029cd
    3db8:	20004048 	.word	0x20004048
    3dbc:	2000401c 	.word	0x2000401c
    3dc0:	000028d1 	.word	0x000028d1
    3dc4:	20004030 	.word	0x20004030
    3dc8:	20004018 	.word	0x20004018
    3dcc:	2000404c 	.word	0x2000404c
    3dd0:	00002d91 	.word	0x00002d91
    3dd4:	000029e5 	.word	0x000029e5

00003dd8 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    3dd8:	b510      	push	{r4, lr}
    3dda:	b084      	sub	sp, #16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    3ddc:	4b0b      	ldr	r3, [pc, #44]	; (3e0c <xTimerCreateTimerTask+0x34>)
    3dde:	4798      	blx	r3

	if( xTimerQueue != NULL )
    3de0:	4b0b      	ldr	r3, [pc, #44]	; (3e10 <xTimerCreateTimerTask+0x38>)
    3de2:	681b      	ldr	r3, [r3, #0]
    3de4:	2b00      	cmp	r3, #0
    3de6:	d00c      	beq.n	3e02 <xTimerCreateTimerTask+0x2a>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    3de8:	2302      	movs	r3, #2
    3dea:	9300      	str	r3, [sp, #0]
    3dec:	2300      	movs	r3, #0
    3dee:	9301      	str	r3, [sp, #4]
    3df0:	9302      	str	r3, [sp, #8]
    3df2:	9303      	str	r3, [sp, #12]
    3df4:	4807      	ldr	r0, [pc, #28]	; (3e14 <xTimerCreateTimerTask+0x3c>)
    3df6:	4908      	ldr	r1, [pc, #32]	; (3e18 <xTimerCreateTimerTask+0x40>)
    3df8:	2250      	movs	r2, #80	; 0x50
    3dfa:	4c08      	ldr	r4, [pc, #32]	; (3e1c <xTimerCreateTimerTask+0x44>)
    3dfc:	47a0      	blx	r4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
    3dfe:	2800      	cmp	r0, #0
    3e00:	d101      	bne.n	3e06 <xTimerCreateTimerTask+0x2e>
    3e02:	b672      	cpsid	i
    3e04:	e7fe      	b.n	3e04 <xTimerCreateTimerTask+0x2c>
	return xReturn;
}
    3e06:	b004      	add	sp, #16
    3e08:	bd10      	pop	{r4, pc}
    3e0a:	46c0      	nop			; (mov r8, r8)
    3e0c:	00003d71 	.word	0x00003d71
    3e10:	20004048 	.word	0x20004048
    3e14:	00003f41 	.word	0x00003f41
    3e18:	00004fa4 	.word	0x00004fa4
    3e1c:	000032fd 	.word	0x000032fd

00003e20 <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3e20:	b510      	push	{r4, lr}
    3e22:	b084      	sub	sp, #16
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3e24:	4c13      	ldr	r4, [pc, #76]	; (3e74 <xTimerGenericCommand+0x54>)
    3e26:	6824      	ldr	r4, [r4, #0]
    3e28:	2c00      	cmp	r4, #0
    3e2a:	d01f      	beq.n	3e6c <xTimerGenericCommand+0x4c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    3e2c:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3e2e:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    3e30:	9003      	str	r0, [sp, #12]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3e32:	2905      	cmp	r1, #5
    3e34:	dc13      	bgt.n	3e5e <xTimerGenericCommand+0x3e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3e36:	4b10      	ldr	r3, [pc, #64]	; (3e78 <xTimerGenericCommand+0x58>)
    3e38:	4798      	blx	r3
    3e3a:	2802      	cmp	r0, #2
    3e3c:	d107      	bne.n	3e4e <xTimerGenericCommand+0x2e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3e3e:	4b0d      	ldr	r3, [pc, #52]	; (3e74 <xTimerGenericCommand+0x54>)
    3e40:	6818      	ldr	r0, [r3, #0]
    3e42:	a901      	add	r1, sp, #4
    3e44:	9a06      	ldr	r2, [sp, #24]
    3e46:	2300      	movs	r3, #0
    3e48:	4c0c      	ldr	r4, [pc, #48]	; (3e7c <xTimerGenericCommand+0x5c>)
    3e4a:	47a0      	blx	r4
    3e4c:	e00f      	b.n	3e6e <xTimerGenericCommand+0x4e>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3e4e:	4b09      	ldr	r3, [pc, #36]	; (3e74 <xTimerGenericCommand+0x54>)
    3e50:	6818      	ldr	r0, [r3, #0]
    3e52:	a901      	add	r1, sp, #4
    3e54:	2200      	movs	r2, #0
    3e56:	2300      	movs	r3, #0
    3e58:	4c08      	ldr	r4, [pc, #32]	; (3e7c <xTimerGenericCommand+0x5c>)
    3e5a:	47a0      	blx	r4
    3e5c:	e007      	b.n	3e6e <xTimerGenericCommand+0x4e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3e5e:	1c20      	adds	r0, r4, #0
    3e60:	a901      	add	r1, sp, #4
    3e62:	1c1a      	adds	r2, r3, #0
    3e64:	2300      	movs	r3, #0
    3e66:	4c06      	ldr	r4, [pc, #24]	; (3e80 <xTimerGenericCommand+0x60>)
    3e68:	47a0      	blx	r4
    3e6a:	e000      	b.n	3e6e <xTimerGenericCommand+0x4e>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3e6c:	2000      	movs	r0, #0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    3e6e:	b004      	add	sp, #16
    3e70:	bd10      	pop	{r4, pc}
    3e72:	46c0      	nop			; (mov r8, r8)
    3e74:	20004048 	.word	0x20004048
    3e78:	00003c29 	.word	0x00003c29
    3e7c:	00002de5 	.word	0x00002de5
    3e80:	00002fad 	.word	0x00002fad

00003e84 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    3e84:	b5f0      	push	{r4, r5, r6, r7, lr}
    3e86:	4657      	mov	r7, sl
    3e88:	464e      	mov	r6, r9
    3e8a:	4645      	mov	r5, r8
    3e8c:	b4e0      	push	{r5, r6, r7}
    3e8e:	b082      	sub	sp, #8
    3e90:	4681      	mov	r9, r0
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    3e92:	4b24      	ldr	r3, [pc, #144]	; (3f24 <prvSampleTimeNow+0xa0>)
    3e94:	4798      	blx	r3
    3e96:	4680      	mov	r8, r0

	if( xTimeNow < xLastTime )
    3e98:	4b23      	ldr	r3, [pc, #140]	; (3f28 <prvSampleTimeNow+0xa4>)
    3e9a:	681b      	ldr	r3, [r3, #0]
    3e9c:	4298      	cmp	r0, r3
    3e9e:	d233      	bcs.n	3f08 <prvSampleTimeNow+0x84>
    3ea0:	e023      	b.n	3eea <prvSampleTimeNow+0x66>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3ea2:	68db      	ldr	r3, [r3, #12]
    3ea4:	681a      	ldr	r2, [r3, #0]
    3ea6:	4692      	mov	sl, r2

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3ea8:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3eaa:	1d25      	adds	r5, r4, #4
    3eac:	1c28      	adds	r0, r5, #0
    3eae:	47b8      	blx	r7
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3eb0:	1c20      	adds	r0, r4, #0
    3eb2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3eb4:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3eb6:	69e3      	ldr	r3, [r4, #28]
    3eb8:	2b01      	cmp	r3, #1
    3eba:	d118      	bne.n	3eee <prvSampleTimeNow+0x6a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3ebc:	69a3      	ldr	r3, [r4, #24]
    3ebe:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
    3ec0:	4553      	cmp	r3, sl
    3ec2:	d907      	bls.n	3ed4 <prvSampleTimeNow+0x50>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3ec4:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3ec6:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3ec8:	4b18      	ldr	r3, [pc, #96]	; (3f2c <prvSampleTimeNow+0xa8>)
    3eca:	6818      	ldr	r0, [r3, #0]
    3ecc:	1c29      	adds	r1, r5, #0
    3ece:	4b18      	ldr	r3, [pc, #96]	; (3f30 <prvSampleTimeNow+0xac>)
    3ed0:	4798      	blx	r3
    3ed2:	e00c      	b.n	3eee <prvSampleTimeNow+0x6a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3ed4:	2300      	movs	r3, #0
    3ed6:	9300      	str	r3, [sp, #0]
    3ed8:	1c20      	adds	r0, r4, #0
    3eda:	2100      	movs	r1, #0
    3edc:	4652      	mov	r2, sl
    3ede:	4c15      	ldr	r4, [pc, #84]	; (3f34 <prvSampleTimeNow+0xb0>)
    3ee0:	47a0      	blx	r4
				configASSERT( xResult );
    3ee2:	2800      	cmp	r0, #0
    3ee4:	d103      	bne.n	3eee <prvSampleTimeNow+0x6a>
    3ee6:	b672      	cpsid	i
    3ee8:	e7fe      	b.n	3ee8 <prvSampleTimeNow+0x64>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3eea:	4e10      	ldr	r6, [pc, #64]	; (3f2c <prvSampleTimeNow+0xa8>)
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3eec:	4f12      	ldr	r7, [pc, #72]	; (3f38 <prvSampleTimeNow+0xb4>)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3eee:	6833      	ldr	r3, [r6, #0]
    3ef0:	681a      	ldr	r2, [r3, #0]
    3ef2:	2a00      	cmp	r2, #0
    3ef4:	d1d5      	bne.n	3ea2 <prvSampleTimeNow+0x1e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3ef6:	4a11      	ldr	r2, [pc, #68]	; (3f3c <prvSampleTimeNow+0xb8>)
    3ef8:	490c      	ldr	r1, [pc, #48]	; (3f2c <prvSampleTimeNow+0xa8>)
    3efa:	6810      	ldr	r0, [r2, #0]
    3efc:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
    3efe:	6013      	str	r3, [r2, #0]
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    3f00:	2301      	movs	r3, #1
    3f02:	464a      	mov	r2, r9
    3f04:	6013      	str	r3, [r2, #0]
    3f06:	e002      	b.n	3f0e <prvSampleTimeNow+0x8a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3f08:	2300      	movs	r3, #0
    3f0a:	464a      	mov	r2, r9
    3f0c:	6013      	str	r3, [r2, #0]
	}

	xLastTime = xTimeNow;
    3f0e:	4b06      	ldr	r3, [pc, #24]	; (3f28 <prvSampleTimeNow+0xa4>)
    3f10:	4642      	mov	r2, r8
    3f12:	601a      	str	r2, [r3, #0]

	return xTimeNow;
}
    3f14:	4640      	mov	r0, r8
    3f16:	b002      	add	sp, #8
    3f18:	bc1c      	pop	{r2, r3, r4}
    3f1a:	4690      	mov	r8, r2
    3f1c:	4699      	mov	r9, r3
    3f1e:	46a2      	mov	sl, r4
    3f20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3f22:	46c0      	nop			; (mov r8, r8)
    3f24:	000035dd 	.word	0x000035dd
    3f28:	20004044 	.word	0x20004044
    3f2c:	20004018 	.word	0x20004018
    3f30:	00002909 	.word	0x00002909
    3f34:	00003e21 	.word	0x00003e21
    3f38:	00002939 	.word	0x00002939
    3f3c:	2000404c 	.word	0x2000404c

00003f40 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3f40:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f42:	4657      	mov	r7, sl
    3f44:	464e      	mov	r6, r9
    3f46:	4645      	mov	r5, r8
    3f48:	b4e0      	push	{r5, r6, r7}
    3f4a:	b088      	sub	sp, #32
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3f4c:	4b52      	ldr	r3, [pc, #328]	; (4098 <prvTimerTask+0x158>)
    3f4e:	469a      	mov	sl, r3
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3f50:	4b52      	ldr	r3, [pc, #328]	; (409c <prvTimerTask+0x15c>)
    3f52:	4699      	mov	r9, r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3f54:	4b52      	ldr	r3, [pc, #328]	; (40a0 <prvTimerTask+0x160>)
    3f56:	4698      	mov	r8, r3
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3f58:	4653      	mov	r3, sl
    3f5a:	681b      	ldr	r3, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
    3f5c:	681a      	ldr	r2, [r3, #0]
    3f5e:	2a00      	cmp	r2, #0
    3f60:	d100      	bne.n	3f64 <prvTimerTask+0x24>
    3f62:	e08f      	b.n	4084 <prvTimerTask+0x144>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3f64:	68db      	ldr	r3, [r3, #12]
    3f66:	681d      	ldr	r5, [r3, #0]
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3f68:	4b4c      	ldr	r3, [pc, #304]	; (409c <prvTimerTask+0x15c>)
    3f6a:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3f6c:	a805      	add	r0, sp, #20
    3f6e:	4b4c      	ldr	r3, [pc, #304]	; (40a0 <prvTimerTask+0x160>)
    3f70:	4798      	blx	r3
    3f72:	1c04      	adds	r4, r0, #0
		if( xTimerListsWereSwitched == pdFALSE )
    3f74:	9b05      	ldr	r3, [sp, #20]
    3f76:	2b00      	cmp	r3, #0
    3f78:	d131      	bne.n	3fde <prvTimerTask+0x9e>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3f7a:	4285      	cmp	r5, r0
    3f7c:	d823      	bhi.n	3fc6 <prvTimerTask+0x86>
			{
				( void ) xTaskResumeAll();
    3f7e:	4b49      	ldr	r3, [pc, #292]	; (40a4 <prvTimerTask+0x164>)
    3f80:	4798      	blx	r3
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3f82:	4b45      	ldr	r3, [pc, #276]	; (4098 <prvTimerTask+0x158>)
    3f84:	681b      	ldr	r3, [r3, #0]
    3f86:	68db      	ldr	r3, [r3, #12]
    3f88:	68de      	ldr	r6, [r3, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3f8a:	1d30      	adds	r0, r6, #4
    3f8c:	4b46      	ldr	r3, [pc, #280]	; (40a8 <prvTimerTask+0x168>)
    3f8e:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3f90:	69f3      	ldr	r3, [r6, #28]
    3f92:	2b01      	cmp	r3, #1
    3f94:	d113      	bne.n	3fbe <prvTimerTask+0x7e>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3f96:	69b3      	ldr	r3, [r6, #24]
    3f98:	18e9      	adds	r1, r5, r3
    3f9a:	1c30      	adds	r0, r6, #0
    3f9c:	1c22      	adds	r2, r4, #0
    3f9e:	1c2b      	adds	r3, r5, #0
    3fa0:	4c42      	ldr	r4, [pc, #264]	; (40ac <prvTimerTask+0x16c>)
    3fa2:	47a0      	blx	r4
    3fa4:	2801      	cmp	r0, #1
    3fa6:	d10a      	bne.n	3fbe <prvTimerTask+0x7e>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3fa8:	2300      	movs	r3, #0
    3faa:	9300      	str	r3, [sp, #0]
    3fac:	1c30      	adds	r0, r6, #0
    3fae:	2100      	movs	r1, #0
    3fb0:	1c2a      	adds	r2, r5, #0
    3fb2:	4c3f      	ldr	r4, [pc, #252]	; (40b0 <prvTimerTask+0x170>)
    3fb4:	47a0      	blx	r4
			configASSERT( xResult );
    3fb6:	2800      	cmp	r0, #0
    3fb8:	d101      	bne.n	3fbe <prvTimerTask+0x7e>
    3fba:	b672      	cpsid	i
    3fbc:	e7fe      	b.n	3fbc <prvTimerTask+0x7c>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3fbe:	6a73      	ldr	r3, [r6, #36]	; 0x24
    3fc0:	1c30      	adds	r0, r6, #0
    3fc2:	4798      	blx	r3
    3fc4:	e00d      	b.n	3fe2 <prvTimerTask+0xa2>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    3fc6:	4b3b      	ldr	r3, [pc, #236]	; (40b4 <prvTimerTask+0x174>)
    3fc8:	6818      	ldr	r0, [r3, #0]
    3fca:	1b29      	subs	r1, r5, r4
    3fcc:	4b3a      	ldr	r3, [pc, #232]	; (40b8 <prvTimerTask+0x178>)
    3fce:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
    3fd0:	4b34      	ldr	r3, [pc, #208]	; (40a4 <prvTimerTask+0x164>)
    3fd2:	4798      	blx	r3
    3fd4:	2800      	cmp	r0, #0
    3fd6:	d104      	bne.n	3fe2 <prvTimerTask+0xa2>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    3fd8:	4b38      	ldr	r3, [pc, #224]	; (40bc <prvTimerTask+0x17c>)
    3fda:	4798      	blx	r3
    3fdc:	e001      	b.n	3fe2 <prvTimerTask+0xa2>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    3fde:	4b31      	ldr	r3, [pc, #196]	; (40a4 <prvTimerTask+0x164>)
    3fe0:	4798      	blx	r3
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3fe2:	4d34      	ldr	r5, [pc, #208]	; (40b4 <prvTimerTask+0x174>)
    3fe4:	4c36      	ldr	r4, [pc, #216]	; (40c0 <prvTimerTask+0x180>)
    3fe6:	e045      	b.n	4074 <prvTimerTask+0x134>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3fe8:	9b05      	ldr	r3, [sp, #20]
    3fea:	9303      	str	r3, [sp, #12]
    3fec:	2b00      	cmp	r3, #0
    3fee:	db41      	blt.n	4074 <prvTimerTask+0x134>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3ff0:	9e07      	ldr	r6, [sp, #28]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    3ff2:	6973      	ldr	r3, [r6, #20]
    3ff4:	2b00      	cmp	r3, #0
    3ff6:	d002      	beq.n	3ffe <prvTimerTask+0xbe>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3ff8:	1d30      	adds	r0, r6, #4
    3ffa:	4b2b      	ldr	r3, [pc, #172]	; (40a8 <prvTimerTask+0x168>)
    3ffc:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3ffe:	a804      	add	r0, sp, #16
    4000:	4b27      	ldr	r3, [pc, #156]	; (40a0 <prvTimerTask+0x160>)
    4002:	4798      	blx	r3
    4004:	1c03      	adds	r3, r0, #0

			switch( xMessage.xMessageID )
    4006:	9a05      	ldr	r2, [sp, #20]
    4008:	2a09      	cmp	r2, #9
    400a:	d833      	bhi.n	4074 <prvTimerTask+0x134>
    400c:	0092      	lsls	r2, r2, #2
    400e:	492d      	ldr	r1, [pc, #180]	; (40c4 <prvTimerTask+0x184>)
    4010:	588a      	ldr	r2, [r1, r2]
    4012:	4697      	mov	pc, r2
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    4014:	9a06      	ldr	r2, [sp, #24]
    4016:	69b0      	ldr	r0, [r6, #24]
    4018:	4684      	mov	ip, r0
    401a:	4462      	add	r2, ip
    401c:	1c11      	adds	r1, r2, #0
    401e:	1c30      	adds	r0, r6, #0
    4020:	1c1a      	adds	r2, r3, #0
    4022:	9b06      	ldr	r3, [sp, #24]
    4024:	4f21      	ldr	r7, [pc, #132]	; (40ac <prvTimerTask+0x16c>)
    4026:	47b8      	blx	r7
    4028:	2801      	cmp	r0, #1
    402a:	d123      	bne.n	4074 <prvTimerTask+0x134>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    402c:	1c30      	adds	r0, r6, #0
    402e:	6a73      	ldr	r3, [r6, #36]	; 0x24
    4030:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4032:	69f3      	ldr	r3, [r6, #28]
    4034:	2b01      	cmp	r3, #1
    4036:	d11d      	bne.n	4074 <prvTimerTask+0x134>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    4038:	69b3      	ldr	r3, [r6, #24]
    403a:	9906      	ldr	r1, [sp, #24]
    403c:	468c      	mov	ip, r1
    403e:	4463      	add	r3, ip
    4040:	1c1a      	adds	r2, r3, #0
    4042:	2300      	movs	r3, #0
    4044:	9300      	str	r3, [sp, #0]
    4046:	1c30      	adds	r0, r6, #0
    4048:	2100      	movs	r1, #0
    404a:	4e19      	ldr	r6, [pc, #100]	; (40b0 <prvTimerTask+0x170>)
    404c:	47b0      	blx	r6
							configASSERT( xResult );
    404e:	2800      	cmp	r0, #0
    4050:	d110      	bne.n	4074 <prvTimerTask+0x134>
    4052:	b672      	cpsid	i
    4054:	e7fe      	b.n	4054 <prvTimerTask+0x114>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    4056:	9906      	ldr	r1, [sp, #24]
    4058:	61b1      	str	r1, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    405a:	2900      	cmp	r1, #0
    405c:	d101      	bne.n	4062 <prvTimerTask+0x122>
    405e:	b672      	cpsid	i
    4060:	e7fe      	b.n	4060 <prvTimerTask+0x120>
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    4062:	1841      	adds	r1, r0, r1
    4064:	1c30      	adds	r0, r6, #0
    4066:	1c1a      	adds	r2, r3, #0
    4068:	4e10      	ldr	r6, [pc, #64]	; (40ac <prvTimerTask+0x16c>)
    406a:	47b0      	blx	r6
    406c:	e002      	b.n	4074 <prvTimerTask+0x134>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    406e:	1c30      	adds	r0, r6, #0
    4070:	4b15      	ldr	r3, [pc, #84]	; (40c8 <prvTimerTask+0x188>)
    4072:	4798      	blx	r3
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4074:	6828      	ldr	r0, [r5, #0]
    4076:	a905      	add	r1, sp, #20
    4078:	2200      	movs	r2, #0
    407a:	2300      	movs	r3, #0
    407c:	47a0      	blx	r4
    407e:	2800      	cmp	r0, #0
    4080:	d1b2      	bne.n	3fe8 <prvTimerTask+0xa8>
    4082:	e769      	b.n	3f58 <prvTimerTask+0x18>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    4084:	47c8      	blx	r9
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4086:	a805      	add	r0, sp, #20
    4088:	47c0      	blx	r8
    408a:	1c04      	adds	r4, r0, #0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    408c:	2500      	movs	r5, #0
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
    408e:	9b05      	ldr	r3, [sp, #20]
    4090:	2b00      	cmp	r3, #0
    4092:	d098      	beq.n	3fc6 <prvTimerTask+0x86>
    4094:	e7a3      	b.n	3fde <prvTimerTask+0x9e>
    4096:	46c0      	nop			; (mov r8, r8)
    4098:	20004018 	.word	0x20004018
    409c:	000035cd 	.word	0x000035cd
    40a0:	00003e85 	.word	0x00003e85
    40a4:	00003721 	.word	0x00003721
    40a8:	00002939 	.word	0x00002939
    40ac:	00003d25 	.word	0x00003d25
    40b0:	00003e21 	.word	0x00003e21
    40b4:	20004048 	.word	0x20004048
    40b8:	000031fd 	.word	0x000031fd
    40bc:	000029b5 	.word	0x000029b5
    40c0:	00003075 	.word	0x00003075
    40c4:	00004f7c 	.word	0x00004f7c
    40c8:	00002b6d 	.word	0x00002b6d

000040cc <cdc_rx_handler>:
 * to the sender.
 *
 * \param instance Instance number of SERCOM that generated interrupt.
 */
static void cdc_rx_handler(uint8_t instance)
{
    40cc:	b530      	push	{r4, r5, lr}
    40ce:	b083      	sub	sp, #12
	uint16_t data;
	uint8_t error_code;

	// Wait for synch to complete
#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	while (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY) {
    40d0:	4a18      	ldr	r2, [pc, #96]	; (4134 <cdc_rx_handler+0x68>)
    40d2:	8a13      	ldrh	r3, [r2, #16]
    40d4:	b21b      	sxth	r3, r3
    40d6:	2b00      	cmp	r3, #0
    40d8:	dbfb      	blt.n	40d2 <cdc_rx_handler+0x6>
	while (usart_hw->SYNCBUSY.reg) {
	}
#endif

	// Read and mask interrupt flag register
	interrupt_status = usart_hw->INTFLAG.reg;
    40da:	4b16      	ldr	r3, [pc, #88]	; (4134 <cdc_rx_handler+0x68>)
    40dc:	7b9c      	ldrb	r4, [r3, #14]
    40de:	b2e4      	uxtb	r4, r4

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    40e0:	0763      	lsls	r3, r4, #29
    40e2:	d524      	bpl.n	412e <cdc_rx_handler+0x62>
		// Check for errors
		error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    40e4:	4b13      	ldr	r3, [pc, #76]	; (4134 <cdc_rx_handler+0x68>)
    40e6:	8a1b      	ldrh	r3, [r3, #16]
    40e8:	b2db      	uxtb	r3, r3
		if (error_code) {
    40ea:	075a      	lsls	r2, r3, #29
    40ec:	d005      	beq.n	40fa <cdc_rx_handler+0x2e>
			// Only frame error and buffer overflow should be possible
			if (error_code &
    40ee:	2206      	movs	r2, #6
    40f0:	421a      	tst	r2, r3
    40f2:	d01c      	beq.n	412e <cdc_rx_handler+0x62>
					(SERCOM_USART_STATUS_FERR | SERCOM_USART_STATUS_BUFOVF)) {
				usart_hw->STATUS.reg =
    40f4:	4b0f      	ldr	r3, [pc, #60]	; (4134 <cdc_rx_handler+0x68>)
    40f6:	821a      	strh	r2, [r3, #16]
    40f8:	e019      	b.n	412e <cdc_rx_handler+0x62>
			} else {
				// Error: unknown failure
			}
		// All is fine, so push the received character into our queue
		} else {
			data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    40fa:	4b0e      	ldr	r3, [pc, #56]	; (4134 <cdc_rx_handler+0x68>)
    40fc:	8b1b      	ldrh	r3, [r3, #24]
    40fe:	466a      	mov	r2, sp
    4100:	1d91      	adds	r1, r2, #6
    4102:	05db      	lsls	r3, r3, #23
    4104:	0ddb      	lsrs	r3, r3, #23
    4106:	800b      	strh	r3, [r1, #0]

			if (!xQueueSendFromISR(terminal_in_queue, (uint8_t *)&data,
    4108:	4b0b      	ldr	r3, [pc, #44]	; (4138 <cdc_rx_handler+0x6c>)
    410a:	6818      	ldr	r0, [r3, #0]
    410c:	2200      	movs	r2, #0
    410e:	2300      	movs	r3, #0
    4110:	4d0a      	ldr	r5, [pc, #40]	; (413c <cdc_rx_handler+0x70>)
    4112:	47a8      	blx	r5
    4114:	2800      	cmp	r0, #0
    4116:	d00a      	beq.n	412e <cdc_rx_handler+0x62>
						NULL)) {
				// Error: could not enqueue character
			} else {
				// Echo back! Data reg. should empty fast since this is the
				// only place anything is sent.
				while (!(interrupt_status & SERCOM_USART_INTFLAG_DRE)) {
    4118:	07e3      	lsls	r3, r4, #31
    411a:	d404      	bmi.n	4126 <cdc_rx_handler+0x5a>
					interrupt_status = usart_hw->INTFLAG.reg;
    411c:	4905      	ldr	r1, [pc, #20]	; (4134 <cdc_rx_handler+0x68>)
						NULL)) {
				// Error: could not enqueue character
			} else {
				// Echo back! Data reg. should empty fast since this is the
				// only place anything is sent.
				while (!(interrupt_status & SERCOM_USART_INTFLAG_DRE)) {
    411e:	2201      	movs	r2, #1
					interrupt_status = usart_hw->INTFLAG.reg;
    4120:	7b8b      	ldrb	r3, [r1, #14]
						NULL)) {
				// Error: could not enqueue character
			} else {
				// Echo back! Data reg. should empty fast since this is the
				// only place anything is sent.
				while (!(interrupt_status & SERCOM_USART_INTFLAG_DRE)) {
    4122:	4213      	tst	r3, r2
    4124:	d0fc      	beq.n	4120 <cdc_rx_handler+0x54>
					interrupt_status = usart_hw->INTFLAG.reg;
				}
				usart_hw->DATA.reg = (uint8_t)data;
    4126:	466b      	mov	r3, sp
    4128:	799a      	ldrb	r2, [r3, #6]
    412a:	4b02      	ldr	r3, [pc, #8]	; (4134 <cdc_rx_handler+0x68>)
    412c:	831a      	strh	r2, [r3, #24]
			}
		}
	} else {
		// Error: only RX interrupt should be enabled
	}
}
    412e:	b003      	add	sp, #12
    4130:	bd30      	pop	{r4, r5, pc}
    4132:	46c0      	nop			; (mov r8, r8)
    4134:	42001400 	.word	0x42001400
    4138:	200040e0 	.word	0x200040e0
    413c:	00002fad 	.word	0x00002fad

00004140 <uart_task>:
 * anything to the display -- that is done by \ref terminal_task().
 *
 * \param params Parameters for the task. (Not used.)
 */
static void uart_task(void *params)
{
    4140:	b5f0      	push	{r4, r5, r6, r7, lr}
    4142:	465f      	mov	r7, fp
    4144:	4656      	mov	r6, sl
    4146:	464d      	mov	r5, r9
    4148:	4644      	mov	r4, r8
    414a:	b4f0      	push	{r4, r5, r6, r7}
    414c:	b083      	sub	sp, #12
	uint8_t *current_line_ptr;
	uint8_t *current_char_ptr;
	uint8_t current_column = 0;
    414e:	2600      	movs	r6, #0
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4150:	4b2e      	ldr	r3, [pc, #184]	; (420c <uart_task+0xcc>)
    4152:	469a      	mov	sl, r3
    4154:	2380      	movs	r3, #128	; 0x80
    4156:	015b      	lsls	r3, r3, #5
    4158:	9301      	str	r3, [sp, #4]
	for (;;) {
		// Show that task is executing
		oled1_set_led_state(&oled1, OLED1_LED1_ID, true);

		// Grab terminal mutex
		xSemaphoreTake(terminal_mutex, portMAX_DELAY);
    415a:	4b2d      	ldr	r3, [pc, #180]	; (4210 <uart_task+0xd0>)
    415c:	469b      	mov	fp, r3
    415e:	4653      	mov	r3, sl
    4160:	9a01      	ldr	r2, [sp, #4]
    4162:	615a      	str	r2, [r3, #20]
    4164:	465b      	mov	r3, fp
    4166:	6818      	ldr	r0, [r3, #0]
    4168:	2100      	movs	r1, #0
    416a:	2201      	movs	r2, #1
    416c:	4252      	negs	r2, r2
    416e:	2300      	movs	r3, #0
    4170:	4c28      	ldr	r4, [pc, #160]	; (4214 <uart_task+0xd4>)
    4172:	47a0      	blx	r4

		current_line_ptr = terminal_buffer[terminal_line_offset];
    4174:	4b28      	ldr	r3, [pc, #160]	; (4218 <uart_task+0xd8>)
    4176:	781d      	ldrb	r5, [r3, #0]
    4178:	2316      	movs	r3, #22
    417a:	435d      	muls	r5, r3
    417c:	4b27      	ldr	r3, [pc, #156]	; (421c <uart_task+0xdc>)
    417e:	195d      	adds	r5, r3, r5
		current_char_ptr = current_line_ptr + current_column;
    4180:	19ac      	adds	r4, r5, r6

		// Any characters queued? Handle them!
		while (xQueueReceive(terminal_in_queue, current_char_ptr, 0)) {
    4182:	4b27      	ldr	r3, [pc, #156]	; (4220 <uart_task+0xe0>)
    4184:	4698      	mov	r8, r3
    4186:	4f23      	ldr	r7, [pc, #140]	; (4214 <uart_task+0xd4>)
			default:
				// For all other characters, just move head to next char
				current_column++;
				if (current_column >= TERMINAL_COLUMNS) {
					current_column = 0;
					terminal_line_offset = (terminal_line_offset + 1)
    4188:	4b23      	ldr	r3, [pc, #140]	; (4218 <uart_task+0xd8>)
    418a:	4699      	mov	r9, r3

		current_line_ptr = terminal_buffer[terminal_line_offset];
		current_char_ptr = current_line_ptr + current_column;

		// Any characters queued? Handle them!
		while (xQueueReceive(terminal_in_queue, current_char_ptr, 0)) {
    418c:	e026      	b.n	41dc <uart_task+0x9c>
			/* Newline-handling is difficult because all terminal emulators
			 * seem to do it their own way. The method below seems to work
			 * with Putty and Realterm out of the box.
			 */
			switch (*current_char_ptr) {
    418e:	7823      	ldrb	r3, [r4, #0]
    4190:	2b0a      	cmp	r3, #10
    4192:	d021      	beq.n	41d8 <uart_task+0x98>
    4194:	2b0d      	cmp	r3, #13
    4196:	d10e      	bne.n	41b6 <uart_task+0x76>
			case '\r':
				// Replace \r with \0 and move head to next line
				*current_char_ptr = '\0';
    4198:	2300      	movs	r3, #0
    419a:	7023      	strb	r3, [r4, #0]

				current_column = 0;
				terminal_line_offset = (terminal_line_offset + 1)
    419c:	4b1e      	ldr	r3, [pc, #120]	; (4218 <uart_task+0xd8>)
    419e:	781c      	ldrb	r4, [r3, #0]
						% TERMINAL_BUFFER_LINES;
    41a0:	3401      	adds	r4, #1
    41a2:	2203      	movs	r2, #3
    41a4:	4014      	ands	r4, r2
			case '\r':
				// Replace \r with \0 and move head to next line
				*current_char_ptr = '\0';

				current_column = 0;
				terminal_line_offset = (terminal_line_offset + 1)
    41a6:	701c      	strb	r4, [r3, #0]
						% TERMINAL_BUFFER_LINES;
				current_line_ptr = terminal_buffer[terminal_line_offset];
    41a8:	2316      	movs	r3, #22
    41aa:	435c      	muls	r4, r3
    41ac:	4b1b      	ldr	r3, [pc, #108]	; (421c <uart_task+0xdc>)
    41ae:	191c      	adds	r4, r3, r4
				current_char_ptr = current_line_ptr + current_column;
    41b0:	1c25      	adds	r5, r4, #0
			switch (*current_char_ptr) {
			case '\r':
				// Replace \r with \0 and move head to next line
				*current_char_ptr = '\0';

				current_column = 0;
    41b2:	2600      	movs	r6, #0
				terminal_line_offset = (terminal_line_offset + 1)
						% TERMINAL_BUFFER_LINES;
				current_line_ptr = terminal_buffer[terminal_line_offset];
				current_char_ptr = current_line_ptr + current_column;
				break;
    41b4:	e010      	b.n	41d8 <uart_task+0x98>
				// For \n, do nothing -- it is replaced with \0 later
				break;

			default:
				// For all other characters, just move head to next char
				current_column++;
    41b6:	3601      	adds	r6, #1
    41b8:	b2f6      	uxtb	r6, r6
				if (current_column >= TERMINAL_COLUMNS) {
    41ba:	2e14      	cmp	r6, #20
    41bc:	d90b      	bls.n	41d6 <uart_task+0x96>
					current_column = 0;
					terminal_line_offset = (terminal_line_offset + 1)
    41be:	464b      	mov	r3, r9
    41c0:	781d      	ldrb	r5, [r3, #0]
							% TERMINAL_BUFFER_LINES;
    41c2:	3501      	adds	r5, #1
    41c4:	2303      	movs	r3, #3
    41c6:	401d      	ands	r5, r3
			default:
				// For all other characters, just move head to next char
				current_column++;
				if (current_column >= TERMINAL_COLUMNS) {
					current_column = 0;
					terminal_line_offset = (terminal_line_offset + 1)
    41c8:	464b      	mov	r3, r9
    41ca:	701d      	strb	r5, [r3, #0]
							% TERMINAL_BUFFER_LINES;
					current_line_ptr = terminal_buffer[terminal_line_offset];
    41cc:	2316      	movs	r3, #22
    41ce:	435d      	muls	r5, r3
    41d0:	4b12      	ldr	r3, [pc, #72]	; (421c <uart_task+0xdc>)
    41d2:	195d      	adds	r5, r3, r5

			default:
				// For all other characters, just move head to next char
				current_column++;
				if (current_column >= TERMINAL_COLUMNS) {
					current_column = 0;
    41d4:	2600      	movs	r6, #0
					terminal_line_offset = (terminal_line_offset + 1)
							% TERMINAL_BUFFER_LINES;
					current_line_ptr = terminal_buffer[terminal_line_offset];
				}
				current_char_ptr = current_line_ptr + current_column;
    41d6:	19ac      	adds	r4, r5, r6
			}

			// Set zero-terminator at head
			*current_char_ptr = '\0';
    41d8:	2300      	movs	r3, #0
    41da:	7023      	strb	r3, [r4, #0]

		current_line_ptr = terminal_buffer[terminal_line_offset];
		current_char_ptr = current_line_ptr + current_column;

		// Any characters queued? Handle them!
		while (xQueueReceive(terminal_in_queue, current_char_ptr, 0)) {
    41dc:	4643      	mov	r3, r8
    41de:	6818      	ldr	r0, [r3, #0]
    41e0:	1c21      	adds	r1, r4, #0
    41e2:	2200      	movs	r2, #0
    41e4:	2300      	movs	r3, #0
    41e6:	47b8      	blx	r7
    41e8:	2800      	cmp	r0, #0
    41ea:	d1d0      	bne.n	418e <uart_task+0x4e>

			// Set zero-terminator at head
			*current_char_ptr = '\0';
		}

		xSemaphoreGive(terminal_mutex);
    41ec:	4b08      	ldr	r3, [pc, #32]	; (4210 <uart_task+0xd0>)
    41ee:	6818      	ldr	r0, [r3, #0]
    41f0:	2100      	movs	r1, #0
    41f2:	2200      	movs	r2, #0
    41f4:	2300      	movs	r3, #0
    41f6:	4c0b      	ldr	r4, [pc, #44]	; (4224 <uart_task+0xe4>)
    41f8:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    41fa:	4653      	mov	r3, sl
    41fc:	2280      	movs	r2, #128	; 0x80
    41fe:	0152      	lsls	r2, r2, #5
    4200:	619a      	str	r2, [r3, #24]

		oled1_set_led_state(&oled1, OLED1_LED1_ID, false);

		vTaskDelay(UART_TASK_DELAY);
    4202:	2002      	movs	r0, #2
    4204:	4b08      	ldr	r3, [pc, #32]	; (4228 <uart_task+0xe8>)
    4206:	4798      	blx	r3
	}
    4208:	e7a9      	b.n	415e <uart_task+0x1e>
    420a:	46c0      	nop			; (mov r8, r8)
    420c:	41004400 	.word	0x41004400
    4210:	200040d0 	.word	0x200040d0
    4214:	00003075 	.word	0x00003075
    4218:	200040d9 	.word	0x200040d9
    421c:	20004050 	.word	0x20004050
    4220:	200040e0 	.word	0x200040e0
    4224:	00002de5 	.word	0x00002de5
    4228:	00003819 	.word	0x00003819

0000422c <about_task>:
 * animation.
 *
 * \param params Parameters for the task. (Not used.)
 */
static void about_task(void *params)
{
    422c:	b5f0      	push	{r4, r5, r6, r7, lr}
    422e:	465f      	mov	r7, fp
    4230:	4656      	mov	r6, sl
    4232:	464d      	mov	r5, r9
    4234:	4644      	mov	r4, r8
    4236:	b4f0      	push	{r4, r5, r6, r7}
    4238:	b085      	sub	sp, #20
	char c;
	gfx_coord_t x, y;
	uint8_t i, shift;

	const uint8_t max_shift = 8;
	shift = 1;
    423a:	2301      	movs	r3, #1
    423c:	9302      	str	r3, [sp, #8]
	} else {
		port_base->OUTCLR.reg = pin_mask;
    423e:	2380      	movs	r3, #128	; 0x80
    4240:	019b      	lsls	r3, r3, #6
    4242:	9303      	str	r3, [sp, #12]
    4244:	4b2e      	ldr	r3, [pc, #184]	; (4300 <about_task+0xd4>)
    4246:	9a03      	ldr	r2, [sp, #12]
    4248:	615a      	str	r2, [r3, #20]

	for (;;) {
		oled1_set_led_state(&oled1, OLED1_LED2_ID, true);

		xSemaphoreTake(display_mutex, portMAX_DELAY);
    424a:	4b2e      	ldr	r3, [pc, #184]	; (4304 <about_task+0xd8>)
    424c:	6818      	ldr	r0, [r3, #0]
    424e:	2100      	movs	r1, #0
    4250:	2201      	movs	r2, #1
    4252:	4252      	negs	r2, r2
    4254:	2300      	movs	r3, #0
    4256:	4c2c      	ldr	r4, [pc, #176]	; (4308 <about_task+0xdc>)
    4258:	47a0      	blx	r4

		// Print the about text in an expanding area
		for (i = 0; i < (sizeof(about_text) - 1); i++) {
			c = about_text[i];
			x = (((i % TERMINAL_COLUMNS) * SYSFONT_WIDTH) * shift
    425a:	9a02      	ldr	r2, [sp, #8]
    425c:	1c17      	adds	r7, r2, #0
					+ (CANVAS_WIDTH / 2) * (max_shift - shift))
    425e:	2308      	movs	r3, #8
    4260:	1a9b      	subs	r3, r3, r2
    4262:	019a      	lsls	r2, r3, #6
    4264:	4693      	mov	fp, r2
					/ max_shift;
			y = (((i / TERMINAL_COLUMNS) * SYSFONT_HEIGHT) * shift
					+ (CANVAS_HEIGHT / 2) * (max_shift - shift))
    4266:	009a      	lsls	r2, r3, #2
    4268:	18d2      	adds	r2, r2, r3
    426a:	0052      	lsls	r2, r2, #1
    426c:	4691      	mov	r9, r2
    426e:	4499      	add	r9, r3
    4270:	2500      	movs	r5, #0

		xSemaphoreTake(display_mutex, portMAX_DELAY);

		// Print the about text in an expanding area
		for (i = 0; i < (sizeof(about_text) - 1); i++) {
			c = about_text[i];
    4272:	4b26      	ldr	r3, [pc, #152]	; (430c <about_task+0xe0>)
    4274:	469a      	mov	sl, r3
			x = (((i % TERMINAL_COLUMNS) * SYSFONT_WIDTH) * shift
					+ (CANVAS_WIDTH / 2) * (max_shift - shift))
					/ max_shift;
			y = (((i / TERMINAL_COLUMNS) * SYSFONT_HEIGHT) * shift
    4276:	4b26      	ldr	r3, [pc, #152]	; (4310 <about_task+0xe4>)
    4278:	4698      	mov	r8, r3
    427a:	b2ee      	uxtb	r6, r5
					+ (CANVAS_HEIGHT / 2) * (max_shift - shift))
					/ max_shift;
			gfx_mono_draw_char(c, x, y, &sysfont);
    427c:	4653      	mov	r3, sl
    427e:	5ceb      	ldrb	r3, [r5, r3]
    4280:	9301      	str	r3, [sp, #4]
		xSemaphoreTake(display_mutex, portMAX_DELAY);

		// Print the about text in an expanding area
		for (i = 0; i < (sizeof(about_text) - 1); i++) {
			c = about_text[i];
			x = (((i % TERMINAL_COLUMNS) * SYSFONT_WIDTH) * shift
    4282:	1c30      	adds	r0, r6, #0
    4284:	2115      	movs	r1, #21
    4286:	4a23      	ldr	r2, [pc, #140]	; (4314 <about_task+0xe8>)
    4288:	4790      	blx	r2
    428a:	b2c9      	uxtb	r1, r1
    428c:	004b      	lsls	r3, r1, #1
    428e:	185b      	adds	r3, r3, r1
    4290:	005b      	lsls	r3, r3, #1
    4292:	437b      	muls	r3, r7
					+ (CANVAS_WIDTH / 2) * (max_shift - shift))
    4294:	445b      	add	r3, fp
					/ max_shift;
    4296:	17dc      	asrs	r4, r3, #31
    4298:	0f64      	lsrs	r4, r4, #29
    429a:	18e3      	adds	r3, r4, r3
    429c:	10db      	asrs	r3, r3, #3
			y = (((i / TERMINAL_COLUMNS) * SYSFONT_HEIGHT) * shift
					+ (CANVAS_HEIGHT / 2) * (max_shift - shift))
					/ max_shift;
			gfx_mono_draw_char(c, x, y, &sysfont);
    429e:	b2dc      	uxtb	r4, r3
		for (i = 0; i < (sizeof(about_text) - 1); i++) {
			c = about_text[i];
			x = (((i % TERMINAL_COLUMNS) * SYSFONT_WIDTH) * shift
					+ (CANVAS_WIDTH / 2) * (max_shift - shift))
					/ max_shift;
			y = (((i / TERMINAL_COLUMNS) * SYSFONT_HEIGHT) * shift
    42a0:	1c30      	adds	r0, r6, #0
    42a2:	2115      	movs	r1, #21
    42a4:	47c0      	blx	r8
    42a6:	b2c0      	uxtb	r0, r0
    42a8:	00c3      	lsls	r3, r0, #3
    42aa:	1a18      	subs	r0, r3, r0
    42ac:	4378      	muls	r0, r7
					+ (CANVAS_HEIGHT / 2) * (max_shift - shift))
    42ae:	4448      	add	r0, r9
					/ max_shift;
    42b0:	17c2      	asrs	r2, r0, #31
    42b2:	0f52      	lsrs	r2, r2, #29
    42b4:	1812      	adds	r2, r2, r0
    42b6:	10d0      	asrs	r0, r2, #3
			gfx_mono_draw_char(c, x, y, &sysfont);
    42b8:	b2c2      	uxtb	r2, r0
    42ba:	9801      	ldr	r0, [sp, #4]
    42bc:	1c21      	adds	r1, r4, #0
    42be:	4b16      	ldr	r3, [pc, #88]	; (4318 <about_task+0xec>)
    42c0:	4c16      	ldr	r4, [pc, #88]	; (431c <about_task+0xf0>)
    42c2:	47a0      	blx	r4
    42c4:	3501      	adds	r5, #1
		oled1_set_led_state(&oled1, OLED1_LED2_ID, true);

		xSemaphoreTake(display_mutex, portMAX_DELAY);

		// Print the about text in an expanding area
		for (i = 0; i < (sizeof(about_text) - 1); i++) {
    42c6:	2d3f      	cmp	r5, #63	; 0x3f
    42c8:	d1d7      	bne.n	427a <about_task+0x4e>
					+ (CANVAS_HEIGHT / 2) * (max_shift - shift))
					/ max_shift;
			gfx_mono_draw_char(c, x, y, &sysfont);
		}

		xSemaphoreGive(display_mutex);
    42ca:	4b0e      	ldr	r3, [pc, #56]	; (4304 <about_task+0xd8>)
    42cc:	6818      	ldr	r0, [r3, #0]
    42ce:	2100      	movs	r1, #0
    42d0:	2200      	movs	r2, #0
    42d2:	2300      	movs	r3, #0
    42d4:	4c12      	ldr	r4, [pc, #72]	; (4320 <about_task+0xf4>)
    42d6:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    42d8:	4b09      	ldr	r3, [pc, #36]	; (4300 <about_task+0xd4>)
    42da:	2280      	movs	r2, #128	; 0x80
    42dc:	0192      	lsls	r2, r2, #6
    42de:	619a      	str	r2, [r3, #24]

		oled1_set_led_state(&oled1, OLED1_LED2_ID, false);

		// Repeat task until we're displaying the text in full size
		if (shift < max_shift) {
    42e0:	9b02      	ldr	r3, [sp, #8]
    42e2:	2b07      	cmp	r3, #7
    42e4:	d806      	bhi.n	42f4 <about_task+0xc8>
			shift++;
    42e6:	3301      	adds	r3, #1
    42e8:	b2db      	uxtb	r3, r3
    42ea:	9302      	str	r3, [sp, #8]
			vTaskDelay(ABOUT_TASK_DELAY);
    42ec:	2006      	movs	r0, #6
    42ee:	4b0d      	ldr	r3, [pc, #52]	; (4324 <about_task+0xf8>)
    42f0:	4798      	blx	r3
    42f2:	e7a7      	b.n	4244 <about_task+0x18>
		} else {
			shift = 0;
			vTaskSuspend(NULL);
    42f4:	2000      	movs	r0, #0
    42f6:	4b0c      	ldr	r3, [pc, #48]	; (4328 <about_task+0xfc>)
    42f8:	4798      	blx	r3
		// Repeat task until we're displaying the text in full size
		if (shift < max_shift) {
			shift++;
			vTaskDelay(ABOUT_TASK_DELAY);
		} else {
			shift = 0;
    42fa:	2300      	movs	r3, #0
    42fc:	9302      	str	r3, [sp, #8]
    42fe:	e7a1      	b.n	4244 <about_task+0x18>
    4300:	41004400 	.word	0x41004400
    4304:	200040cc 	.word	0x200040cc
    4308:	00003075 	.word	0x00003075
    430c:	00004fc8 	.word	0x00004fc8
    4310:	00004aa9 	.word	0x00004aa9
    4314:	00004bb5 	.word	0x00004bb5
    4318:	20000008 	.word	0x20000008
    431c:	00000c1d 	.word	0x00000c1d
    4320:	00002de5 	.word	0x00002de5
    4324:	00003819 	.word	0x00003819
    4328:	000039ad 	.word	0x000039ad

0000432c <graph_task>:
 * is selected again.
 *
 * \param params Parameters for the task. (Not used.)
 */
static void graph_task(void *params)
{
    432c:	b5f0      	push	{r4, r5, r6, r7, lr}
    432e:	465f      	mov	r7, fp
    4330:	4656      	mov	r6, sl
    4332:	464d      	mov	r5, r9
    4334:	4644      	mov	r4, r8
    4336:	b4f0      	push	{r4, r5, r6, r7}
    4338:	b085      	sub	sp, #20
	gfx_coord_t x, y, old_y;
	uint8_t current_value;

	x = 0;
	current_value = graph_noise;
    433a:	4b31      	ldr	r3, [pc, #196]	; (4400 <graph_task+0xd4>)
    433c:	781d      	ldrb	r5, [r3, #0]
static void graph_task(void *params)
{
	gfx_coord_t x, y, old_y;
	uint8_t current_value;

	x = 0;
    433e:	2600      	movs	r6, #0
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4340:	4b30      	ldr	r3, [pc, #192]	; (4404 <graph_task+0xd8>)
    4342:	4698      	mov	r8, r3
    4344:	2380      	movs	r3, #128	; 0x80
    4346:	015b      	lsls	r3, r3, #5
    4348:	4699      	mov	r9, r3
    434a:	469b      	mov	fp, r3

		// Compute new noise sample and value of current graph sample
		graph_noise = (graph_noise * 173) + 1;
		current_value = ((uint16_t)graph_noise + current_value) / 2;

		xSemaphoreTake(display_mutex, portMAX_DELAY);
    434c:	4b2e      	ldr	r3, [pc, #184]	; (4408 <graph_task+0xdc>)
    434e:	469a      	mov	sl, r3
    4350:	4643      	mov	r3, r8
    4352:	465a      	mov	r2, fp
    4354:	615a      	str	r2, [r3, #20]

	for(;;) {
		oled1_set_led_state(&oled1, OLED1_LED1_ID, true);

		// Compute new noise sample and value of current graph sample
		graph_noise = (graph_noise * 173) + 1;
    4356:	4b2a      	ldr	r3, [pc, #168]	; (4400 <graph_task+0xd4>)
    4358:	781c      	ldrb	r4, [r3, #0]
    435a:	2353      	movs	r3, #83	; 0x53
    435c:	425b      	negs	r3, r3
    435e:	435c      	muls	r4, r3
    4360:	3401      	adds	r4, #1
    4362:	b2e4      	uxtb	r4, r4
    4364:	4b26      	ldr	r3, [pc, #152]	; (4400 <graph_task+0xd4>)
    4366:	701c      	strb	r4, [r3, #0]
		current_value = ((uint16_t)graph_noise + current_value) / 2;
    4368:	1964      	adds	r4, r4, r5
    436a:	1064      	asrs	r4, r4, #1
    436c:	b2e5      	uxtb	r5, r4

		xSemaphoreTake(display_mutex, portMAX_DELAY);
    436e:	4653      	mov	r3, sl
    4370:	6818      	ldr	r0, [r3, #0]
    4372:	2100      	movs	r1, #0
    4374:	2201      	movs	r2, #1
    4376:	4252      	negs	r2, r2
    4378:	2300      	movs	r3, #0
    437a:	4f24      	ldr	r7, [pc, #144]	; (440c <graph_task+0xe0>)
    437c:	47b8      	blx	r7

		// Scale graph value so it fits within the canvas
		y = CANVAS_GRAPH_Y_OFFSET
				+ ((uint16_t)CANVAS_HEIGHT * current_value) / 256;
    437e:	23ff      	movs	r3, #255	; 0xff
    4380:	401c      	ands	r4, r3
    4382:	0063      	lsls	r3, r4, #1
    4384:	191b      	adds	r3, r3, r4
    4386:	00db      	lsls	r3, r3, #3
    4388:	1b1c      	subs	r4, r3, r4
    438a:	17e3      	asrs	r3, r4, #31
    438c:	0e1b      	lsrs	r3, r3, #24
    438e:	191c      	adds	r4, r3, r4
    4390:	1224      	asrs	r4, r4, #8
		current_value = ((uint16_t)graph_noise + current_value) / 2;

		xSemaphoreTake(display_mutex, portMAX_DELAY);

		// Scale graph value so it fits within the canvas
		y = CANVAS_GRAPH_Y_OFFSET
    4392:	3420      	adds	r4, #32
    4394:	b2e4      	uxtb	r4, r4
				+ ((uint16_t)CANVAS_HEIGHT * current_value) / 256;

		// Clear previous graph point..
		gfx_mono_draw_vertical_line(x, CANVAS_GRAPH_Y_OFFSET, CANVAS_HEIGHT,
    4396:	1c30      	adds	r0, r6, #0
    4398:	2120      	movs	r1, #32
    439a:	2217      	movs	r2, #23
    439c:	2300      	movs	r3, #0
    439e:	4f1c      	ldr	r7, [pc, #112]	; (4410 <graph_task+0xe4>)
    43a0:	47b8      	blx	r7
				GFX_PIXEL_CLR);

		// ..and draw a continuous graph using lines
		if (x == 0) {
    43a2:	2e00      	cmp	r6, #0
    43a4:	d10d      	bne.n	43c2 <graph_task+0x96>
			gfx_mono_draw_pixel(x, y, GFX_PIXEL_SET);
    43a6:	2000      	movs	r0, #0
    43a8:	1c21      	adds	r1, r4, #0
    43aa:	2201      	movs	r2, #1
    43ac:	4b19      	ldr	r3, [pc, #100]	; (4414 <graph_task+0xe8>)
    43ae:	4798      	blx	r3
		} else {
			gfx_mono_draw_line(x - 1, old_y, x, y, GFX_PIXEL_SET);
		}

		xSemaphoreGive(display_mutex);
    43b0:	4b15      	ldr	r3, [pc, #84]	; (4408 <graph_task+0xdc>)
    43b2:	6818      	ldr	r0, [r3, #0]
    43b4:	2100      	movs	r1, #0
    43b6:	2200      	movs	r2, #0
    43b8:	2300      	movs	r3, #0
    43ba:	4e17      	ldr	r6, [pc, #92]	; (4418 <graph_task+0xec>)
    43bc:	47b0      	blx	r6

		old_y = y;
		if (++x >= CANVAS_WIDTH) {
    43be:	2601      	movs	r6, #1
    43c0:	e015      	b.n	43ee <graph_task+0xc2>

		// ..and draw a continuous graph using lines
		if (x == 0) {
			gfx_mono_draw_pixel(x, y, GFX_PIXEL_SET);
		} else {
			gfx_mono_draw_line(x - 1, old_y, x, y, GFX_PIXEL_SET);
    43c2:	1e70      	subs	r0, r6, #1
    43c4:	b2c0      	uxtb	r0, r0
    43c6:	2301      	movs	r3, #1
    43c8:	9300      	str	r3, [sp, #0]
    43ca:	9903      	ldr	r1, [sp, #12]
    43cc:	1c32      	adds	r2, r6, #0
    43ce:	1c23      	adds	r3, r4, #0
    43d0:	4f12      	ldr	r7, [pc, #72]	; (441c <graph_task+0xf0>)
    43d2:	47b8      	blx	r7
		}

		xSemaphoreGive(display_mutex);
    43d4:	4b0c      	ldr	r3, [pc, #48]	; (4408 <graph_task+0xdc>)
    43d6:	6818      	ldr	r0, [r3, #0]
    43d8:	2100      	movs	r1, #0
    43da:	2200      	movs	r2, #0
    43dc:	2300      	movs	r3, #0
    43de:	4f0e      	ldr	r7, [pc, #56]	; (4418 <graph_task+0xec>)
    43e0:	47b8      	blx	r7

		old_y = y;
		if (++x >= CANVAS_WIDTH) {
    43e2:	3601      	adds	r6, #1
    43e4:	b2f6      	uxtb	r6, r6
    43e6:	b273      	sxtb	r3, r6
			x = 0;
    43e8:	43db      	mvns	r3, r3
    43ea:	17db      	asrs	r3, r3, #31
    43ec:	401e      	ands	r6, r3
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    43ee:	4643      	mov	r3, r8
    43f0:	464a      	mov	r2, r9
    43f2:	619a      	str	r2, [r3, #24]
		}

		oled1_set_led_state(&oled1, OLED1_LED1_ID, false);

		vTaskDelay(GRAPH_TASK_DELAY);
    43f4:	200a      	movs	r0, #10
    43f6:	4b0a      	ldr	r3, [pc, #40]	; (4420 <graph_task+0xf4>)
    43f8:	4798      	blx	r3
			gfx_mono_draw_line(x - 1, old_y, x, y, GFX_PIXEL_SET);
		}

		xSemaphoreGive(display_mutex);

		old_y = y;
    43fa:	9403      	str	r4, [sp, #12]
		}

		oled1_set_led_state(&oled1, OLED1_LED1_ID, false);

		vTaskDelay(GRAPH_TASK_DELAY);
	}
    43fc:	e7a8      	b.n	4350 <graph_task+0x24>
    43fe:	46c0      	nop			; (mov r8, r8)
    4400:	20000020 	.word	0x20000020
    4404:	41004400 	.word	0x41004400
    4408:	200040cc 	.word	0x200040cc
    440c:	00003075 	.word	0x00003075
    4410:	00000a09 	.word	0x00000a09
    4414:	00000dd1 	.word	0x00000dd1
    4418:	00002de5 	.word	0x00002de5
    441c:	00000aa1 	.word	0x00000aa1
    4420:	00003819 	.word	0x00003819

00004424 <terminal_task>:
 * This task prints the terminal text buffer to the display.
 *
 * \param params Parameters for the task. (Not used.)
 */
static void terminal_task(void *params)
{
    4424:	b5f0      	push	{r4, r5, r6, r7, lr}
    4426:	4657      	mov	r7, sl
    4428:	464e      	mov	r6, r9
    442a:	4645      	mov	r5, r8
    442c:	b4e0      	push	{r5, r6, r7}
    442e:	b084      	sub	sp, #16
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4430:	2380      	movs	r3, #128	; 0x80
    4432:	019b      	lsls	r3, r3, #6
    4434:	4698      	mov	r8, r3
    4436:	4b32      	ldr	r3, [pc, #200]	; (4500 <terminal_task+0xdc>)
    4438:	4642      	mov	r2, r8
    443a:	615a      	str	r2, [r3, #20]

	for (;;) {
		oled1_set_led_state(&oled1, OLED1_LED2_ID, true);

		// Grab both display and terminal mutexes before doing anything
		xSemaphoreTake(display_mutex, portMAX_DELAY);
    443c:	2401      	movs	r4, #1
    443e:	4264      	negs	r4, r4
    4440:	4b30      	ldr	r3, [pc, #192]	; (4504 <terminal_task+0xe0>)
    4442:	6818      	ldr	r0, [r3, #0]
    4444:	2100      	movs	r1, #0
    4446:	1c22      	adds	r2, r4, #0
    4448:	2300      	movs	r3, #0
    444a:	4d2f      	ldr	r5, [pc, #188]	; (4508 <terminal_task+0xe4>)
    444c:	47a8      	blx	r5
		xSemaphoreTake(terminal_mutex, portMAX_DELAY);
    444e:	4b2f      	ldr	r3, [pc, #188]	; (450c <terminal_task+0xe8>)
    4450:	6818      	ldr	r0, [r3, #0]
    4452:	2100      	movs	r1, #0
    4454:	1c22      	adds	r2, r4, #0
    4456:	2300      	movs	r3, #0
    4458:	4c2b      	ldr	r4, [pc, #172]	; (4508 <terminal_task+0xe4>)
    445a:	47a0      	blx	r4

		y = (TERMINAL_LINES - 1) * (SYSFONT_HEIGHT + 1);
		current_line = terminal_line_offset;
    445c:	4b2c      	ldr	r3, [pc, #176]	; (4510 <terminal_task+0xec>)
    445e:	781b      	ldrb	r3, [r3, #0]
    4460:	4699      	mov	r9, r3

		// Grab both display and terminal mutexes before doing anything
		xSemaphoreTake(display_mutex, portMAX_DELAY);
		xSemaphoreTake(terminal_mutex, portMAX_DELAY);

		y = (TERMINAL_LINES - 1) * (SYSFONT_HEIGHT + 1);
    4462:	2310      	movs	r3, #16
    4464:	9303      	str	r3, [sp, #12]
				{
			x = 0;
			current_column = 0;

			// Print characters of string until zero terminator is encountered
			current_char = terminal_buffer[current_line][current_column];
    4466:	464f      	mov	r7, r9
    4468:	2316      	movs	r3, #22
    446a:	437b      	muls	r3, r7
    446c:	4a29      	ldr	r2, [pc, #164]	; (4514 <terminal_task+0xf0>)
    446e:	5c98      	ldrb	r0, [r3, r2]
			while (current_char != '\0') {
    4470:	2800      	cmp	r0, #0
    4472:	d015      	beq.n	44a0 <terminal_task+0x7c>
    4474:	2400      	movs	r4, #0
    4476:	2500      	movs	r5, #0
				gfx_mono_draw_char(current_char, x, y, &sysfont);
    4478:	4b27      	ldr	r3, [pc, #156]	; (4518 <terminal_task+0xf4>)
    447a:	469a      	mov	sl, r3

				// Move to next character on display and in buffer
				x += SYSFONT_WIDTH;
				current_column++;
				current_char = terminal_buffer[current_line][current_column];
    447c:	1c16      	adds	r6, r2, #0
			current_column = 0;

			// Print characters of string until zero terminator is encountered
			current_char = terminal_buffer[current_line][current_column];
			while (current_char != '\0') {
				gfx_mono_draw_char(current_char, x, y, &sysfont);
    447e:	1c29      	adds	r1, r5, #0
    4480:	9a03      	ldr	r2, [sp, #12]
    4482:	4b26      	ldr	r3, [pc, #152]	; (451c <terminal_task+0xf8>)
    4484:	47d0      	blx	sl

				// Move to next character on display and in buffer
				x += SYSFONT_WIDTH;
    4486:	3506      	adds	r5, #6
    4488:	b2ed      	uxtb	r5, r5
				current_column++;
    448a:	3401      	adds	r4, #1
    448c:	b2e4      	uxtb	r4, r4
				current_char = terminal_buffer[current_line][current_column];
    448e:	2316      	movs	r3, #22
    4490:	437b      	muls	r3, r7
    4492:	191b      	adds	r3, r3, r4
    4494:	5d98      	ldrb	r0, [r3, r6]
			x = 0;
			current_column = 0;

			// Print characters of string until zero terminator is encountered
			current_char = terminal_buffer[current_line][current_column];
			while (current_char != '\0') {
    4496:	2800      	cmp	r0, #0
    4498:	d1f1      	bne.n	447e <terminal_task+0x5a>
				current_column++;
				current_char = terminal_buffer[current_line][current_column];
			}

			// Erase remaining part of line on display
			if (current_column < TERMINAL_COLUMNS) {
    449a:	2c14      	cmp	r4, #20
    449c:	d80e      	bhi.n	44bc <terminal_task+0x98>
    449e:	e001      	b.n	44a4 <terminal_task+0x80>
		y = (TERMINAL_LINES - 1) * (SYSFONT_HEIGHT + 1);
		current_line = terminal_line_offset;

		for (printed_lines = 0; printed_lines < TERMINAL_LINES; printed_lines++)
				{
			x = 0;
    44a0:	2500      	movs	r5, #0
			current_column = 0;
    44a2:	2400      	movs	r4, #0
				current_char = terminal_buffer[current_line][current_column];
			}

			// Erase remaining part of line on display
			if (current_column < TERMINAL_COLUMNS) {
				gfx_mono_draw_filled_rect(x, y,
    44a4:	00a2      	lsls	r2, r4, #2
    44a6:	1aa2      	subs	r2, r4, r2
    44a8:	0052      	lsls	r2, r2, #1
    44aa:	3a80      	subs	r2, #128	; 0x80
    44ac:	b2d2      	uxtb	r2, r2
    44ae:	2300      	movs	r3, #0
    44b0:	9300      	str	r3, [sp, #0]
    44b2:	1c28      	adds	r0, r5, #0
    44b4:	9903      	ldr	r1, [sp, #12]
    44b6:	3307      	adds	r3, #7
    44b8:	4c19      	ldr	r4, [pc, #100]	; (4520 <terminal_task+0xfc>)
    44ba:	47a0      	blx	r4
						CANVAS_WIDTH - (current_column * SYSFONT_WIDTH),
						SYSFONT_HEIGHT, GFX_PIXEL_CLR);
			}

			// Move to previous line on display and in buffer
			y -= 1 + SYSFONT_HEIGHT;
    44bc:	9e03      	ldr	r6, [sp, #12]
    44be:	3e08      	subs	r6, #8
    44c0:	b2f3      	uxtb	r3, r6
    44c2:	1c19      	adds	r1, r3, #0
    44c4:	9303      	str	r3, [sp, #12]
			current_line += TERMINAL_BUFFER_LINES - 1;
    44c6:	464a      	mov	r2, r9
    44c8:	3203      	adds	r2, #3
			current_line %= TERMINAL_BUFFER_LINES;
    44ca:	2303      	movs	r3, #3
    44cc:	401a      	ands	r2, r3
    44ce:	4691      	mov	r9, r2
		xSemaphoreTake(terminal_mutex, portMAX_DELAY);

		y = (TERMINAL_LINES - 1) * (SYSFONT_HEIGHT + 1);
		current_line = terminal_line_offset;

		for (printed_lines = 0; printed_lines < TERMINAL_LINES; printed_lines++)
    44d0:	29f8      	cmp	r1, #248	; 0xf8
    44d2:	d1c8      	bne.n	4466 <terminal_task+0x42>
			y -= 1 + SYSFONT_HEIGHT;
			current_line += TERMINAL_BUFFER_LINES - 1;
			current_line %= TERMINAL_BUFFER_LINES;
		}

		xSemaphoreGive(terminal_mutex);
    44d4:	4b0d      	ldr	r3, [pc, #52]	; (450c <terminal_task+0xe8>)
    44d6:	6818      	ldr	r0, [r3, #0]
    44d8:	2100      	movs	r1, #0
    44da:	2200      	movs	r2, #0
    44dc:	2300      	movs	r3, #0
    44de:	4c11      	ldr	r4, [pc, #68]	; (4524 <terminal_task+0x100>)
    44e0:	47a0      	blx	r4
		xSemaphoreGive(display_mutex);
    44e2:	4b08      	ldr	r3, [pc, #32]	; (4504 <terminal_task+0xe0>)
    44e4:	6818      	ldr	r0, [r3, #0]
    44e6:	2100      	movs	r1, #0
    44e8:	2200      	movs	r2, #0
    44ea:	2300      	movs	r3, #0
    44ec:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    44ee:	4b04      	ldr	r3, [pc, #16]	; (4500 <terminal_task+0xdc>)
    44f0:	2280      	movs	r2, #128	; 0x80
    44f2:	0192      	lsls	r2, r2, #6
    44f4:	619a      	str	r2, [r3, #24]

		oled1_set_led_state(&oled1, OLED1_LED2_ID, false);

		vTaskDelay(TERMINAL_TASK_DELAY);
    44f6:	20c8      	movs	r0, #200	; 0xc8
    44f8:	4b0b      	ldr	r3, [pc, #44]	; (4528 <terminal_task+0x104>)
    44fa:	4798      	blx	r3
	}
    44fc:	e79b      	b.n	4436 <terminal_task+0x12>
    44fe:	46c0      	nop			; (mov r8, r8)
    4500:	41004400 	.word	0x41004400
    4504:	200040cc 	.word	0x200040cc
    4508:	00003075 	.word	0x00003075
    450c:	200040d0 	.word	0x200040d0
    4510:	200040d9 	.word	0x200040d9
    4514:	20004050 	.word	0x20004050
    4518:	00000c1d 	.word	0x00000c1d
    451c:	20000008 	.word	0x20000008
    4520:	00000be9 	.word	0x00000be9
    4524:	00002de5 	.word	0x00002de5
    4528:	00003819 	.word	0x00003819

0000452c <NRF_Task>:
	}
}


static void NRF_Task(void *params)
{
    452c:	b5f0      	push	{r4, r5, r6, r7, lr}
    452e:	b083      	sub	sp, #12
	
	//static uint8_t NRF_Recieve_Array[100];
	static uint8_t ArrayIn[50];
	//static uint8_t ArrayOut[50];
	uint8_t PayloadOut[5] = {'J', 'U', 'S', 'T', 'I'};
    4530:	4668      	mov	r0, sp
    4532:	4923      	ldr	r1, [pc, #140]	; (45c0 <NRF_Task+0x94>)
    4534:	2205      	movs	r2, #5
    4536:	4b23      	ldr	r3, [pc, #140]	; (45c4 <NRF_Task+0x98>)
    4538:	4798      	blx	r3
	static uint8_t XMitState = 0;	
	//static uint8_t SendNotGet = 1;
	//static uint8_t Serial_Recieve_Array[100];
	while(1)
	{
		xSemaphoreTake(display_mutex, portMAX_DELAY);
    453a:	4f23      	ldr	r7, [pc, #140]	; (45c8 <NRF_Task+0x9c>)
    453c:	4e23      	ldr	r6, [pc, #140]	; (45cc <NRF_Task+0xa0>)
		
		
		#if 1
		if(0 == XMitState)
    453e:	4d24      	ldr	r5, [pc, #144]	; (45d0 <NRF_Task+0xa4>)
	static uint8_t XMitState = 0;	
	//static uint8_t SendNotGet = 1;
	//static uint8_t Serial_Recieve_Array[100];
	while(1)
	{
		xSemaphoreTake(display_mutex, portMAX_DELAY);
    4540:	6838      	ldr	r0, [r7, #0]
    4542:	2100      	movs	r1, #0
    4544:	2201      	movs	r2, #1
    4546:	4252      	negs	r2, r2
    4548:	2300      	movs	r3, #0
    454a:	47b0      	blx	r6
		
		
		#if 1
		if(0 == XMitState)
    454c:	782b      	ldrb	r3, [r5, #0]
    454e:	2b00      	cmp	r3, #0
    4550:	d10f      	bne.n	4572 <NRF_Task+0x46>
		{
			Set_NRF24L_Tx_Mode();
    4552:	4b20      	ldr	r3, [pc, #128]	; (45d4 <NRF_Task+0xa8>)
    4554:	4798      	blx	r3
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Toggle pin output level */
	port_base->OUTTGL.reg = pin_mask;
    4556:	2280      	movs	r2, #128	; 0x80
    4558:	01d2      	lsls	r2, r2, #7
    455a:	4b1f      	ldr	r3, [pc, #124]	; (45d8 <NRF_Task+0xac>)
    455c:	61da      	str	r2, [r3, #28]
			port_pin_toggle_output_level(LED_0_PIN);
			SendNewPayload(PayloadOut, 5);
    455e:	4668      	mov	r0, sp
    4560:	2105      	movs	r1, #5
    4562:	4b1e      	ldr	r3, [pc, #120]	; (45dc <NRF_Task+0xb0>)
    4564:	4798      	blx	r3
			Clear_NRF_Int_Flags();
    4566:	4b1e      	ldr	r3, [pc, #120]	; (45e0 <NRF_Task+0xb4>)
    4568:	4798      	blx	r3
			XMitState = 1;
    456a:	2201      	movs	r2, #1
    456c:	4b18      	ldr	r3, [pc, #96]	; (45d0 <NRF_Task+0xa4>)
    456e:	701a      	strb	r2, [r3, #0]
    4570:	e01b      	b.n	45aa <NRF_Task+0x7e>
		}
		else if(1 == XMitState)
    4572:	2b01      	cmp	r3, #1
    4574:	d105      	bne.n	4582 <NRF_Task+0x56>
		{
			Set_NRF24L_Rx_Mode();
    4576:	4b1b      	ldr	r3, [pc, #108]	; (45e4 <NRF_Task+0xb8>)
    4578:	4798      	blx	r3
			XMitState = 2;
    457a:	2202      	movs	r2, #2
    457c:	4b14      	ldr	r3, [pc, #80]	; (45d0 <NRF_Task+0xa4>)
    457e:	701a      	strb	r2, [r3, #0]
    4580:	e013      	b.n	45aa <NRF_Task+0x7e>
		}
		else
		{
			if(0x0E == Read_Status())
    4582:	4b19      	ldr	r3, [pc, #100]	; (45e8 <NRF_Task+0xbc>)
    4584:	4798      	blx	r3
    4586:	280e      	cmp	r0, #14
    4588:	d104      	bne.n	4594 <NRF_Task+0x68>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    458a:	2280      	movs	r2, #128	; 0x80
    458c:	0212      	lsls	r2, r2, #8
    458e:	4b12      	ldr	r3, [pc, #72]	; (45d8 <NRF_Task+0xac>)
    4590:	619a      	str	r2, [r3, #24]
    4592:	e007      	b.n	45a4 <NRF_Task+0x78>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4594:	2280      	movs	r2, #128	; 0x80
    4596:	0212      	lsls	r2, r2, #8
    4598:	4b0f      	ldr	r3, [pc, #60]	; (45d8 <NRF_Task+0xac>)
    459a:	615a      	str	r2, [r3, #20]
				oled1_set_led_state(&oled1, OLED1_LED3_ID, false);
			}
			else
			{
				oled1_set_led_state(&oled1, OLED1_LED3_ID, true);
				ReadPayload(ArrayIn, 5);
    459c:	4813      	ldr	r0, [pc, #76]	; (45ec <NRF_Task+0xc0>)
    459e:	2105      	movs	r1, #5
    45a0:	4b13      	ldr	r3, [pc, #76]	; (45f0 <NRF_Task+0xc4>)
    45a2:	4798      	blx	r3
			}
			
			XMitState = 0;
    45a4:	2200      	movs	r2, #0
    45a6:	4b0a      	ldr	r3, [pc, #40]	; (45d0 <NRF_Task+0xa4>)
    45a8:	701a      	strb	r2, [r3, #0]
		}
		#endif

		xSemaphoreGive(display_mutex);
    45aa:	4b07      	ldr	r3, [pc, #28]	; (45c8 <NRF_Task+0x9c>)
    45ac:	6818      	ldr	r0, [r3, #0]
    45ae:	2100      	movs	r1, #0
    45b0:	2200      	movs	r2, #0
    45b2:	2300      	movs	r3, #0
    45b4:	4c0f      	ldr	r4, [pc, #60]	; (45f4 <NRF_Task+0xc8>)
    45b6:	47a0      	blx	r4
		vTaskDelay(NRF_TASK_DELAY);
    45b8:	2028      	movs	r0, #40	; 0x28
    45ba:	4b0f      	ldr	r3, [pc, #60]	; (45f8 <NRF_Task+0xcc>)
    45bc:	4798      	blx	r3
	}
    45be:	e7bf      	b.n	4540 <NRF_Task+0x14>
    45c0:	00004fac 	.word	0x00004fac
    45c4:	00004c6d 	.word	0x00004c6d
    45c8:	200040cc 	.word	0x200040cc
    45cc:	00003075 	.word	0x00003075
    45d0:	200040d8 	.word	0x200040d8
    45d4:	00000421 	.word	0x00000421
    45d8:	41004400 	.word	0x41004400
    45dc:	000005c1 	.word	0x000005c1
    45e0:	0000033d 	.word	0x0000033d
    45e4:	000003c5 	.word	0x000003c5
    45e8:	0000031d 	.word	0x0000031d
    45ec:	200040e4 	.word	0x200040e4
    45f0:	00000579 	.word	0x00000579
    45f4:	00002de5 	.word	0x00002de5
    45f8:	00003819 	.word	0x00003819

000045fc <main_task>:
 * - \ref about_task() "about"
 *
 * \param params Parameters for the task. (Not used.)
 */
static void main_task(void *params)
{
    45fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    45fe:	465f      	mov	r7, fp
    4600:	4656      	mov	r6, sl
    4602:	464d      	mov	r5, r9
    4604:	4644      	mov	r4, r8
    4606:	b4f0      	push	{r4, r5, r6, r7}
    4608:	b085      	sub	sp, #20
	bool graph_buffer_initialized = false;
	bool selection_changed = true;
	bool select_graph_buffer;
	enum menu_items current_selection = MENU_ITEM_GRAPH;
	gfx_coord_t x, y, display_y_offset;
	xTaskHandle temp_task_handle = NULL;
    460a:	2300      	movs	r3, #0
    460c:	4699      	mov	r9, r3
static void main_task(void *params)
{
	bool graph_buffer_initialized = false;
	bool selection_changed = true;
	bool select_graph_buffer;
	enum menu_items current_selection = MENU_ITEM_GRAPH;
    460e:	2700      	movs	r7, #0
 * \param params Parameters for the task. (Not used.)
 */
static void main_task(void *params)
{
	bool graph_buffer_initialized = false;
	bool selection_changed = true;
    4610:	2201      	movs	r2, #1
 *
 * \param params Parameters for the task. (Not used.)
 */
static void main_task(void *params)
{
	bool graph_buffer_initialized = false;
    4612:	2400      	movs	r4, #0
    4614:	4e5b      	ldr	r6, [pc, #364]	; (4784 <main_task+0x188>)
    4616:	2380      	movs	r3, #128	; 0x80
    4618:	021b      	lsls	r3, r3, #8
		}

		// If selection changed, handle the selection
		if (selection_changed) {
			// Wait for and take the display semaphore before doing any changes.
			xSemaphoreTake(display_mutex, portMAX_DELAY);
    461a:	495b      	ldr	r1, [pc, #364]	; (4788 <main_task+0x18c>)
    461c:	468a      	mov	sl, r1
    461e:	4649      	mov	r1, r9
    4620:	9103      	str	r1, [sp, #12]
    4622:	4699      	mov	r9, r3
    4624:	464b      	mov	r3, r9
    4626:	6173      	str	r3, [r6, #20]
		const uint8_t gpio_pin)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	return (port_base->IN.reg & pin_mask);
    4628:	6a33      	ldr	r3, [r6, #32]
	for(;;) {
		// Show that task is executing
		oled1_set_led_state(&oled1, OLED1_LED3_ID, true);

		// Check buttons to see if user changed the selection
		if (oled1_get_button_state(&oled1, OLED1_BUTTON1_ID)
    462a:	00db      	lsls	r3, r3, #3
    462c:	d403      	bmi.n	4636 <main_task+0x3a>
					&& (current_selection != MENU_ITEM_GRAPH)) {
    462e:	2f00      	cmp	r7, #0
    4630:	d000      	beq.n	4634 <main_task+0x38>
    4632:	e085      	b.n	4740 <main_task+0x144>
    4634:	e091      	b.n	475a <main_task+0x15e>
    4636:	6a33      	ldr	r3, [r6, #32]
			current_selection = MENU_ITEM_GRAPH;
			selection_changed = true;
		} 
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON2_ID)
    4638:	075b      	lsls	r3, r3, #29
    463a:	d403      	bmi.n	4644 <main_task+0x48>
		&& (current_selection != NRF_ITEM)) 
    463c:	2f04      	cmp	r7, #4
    463e:	d000      	beq.n	4642 <main_task+0x46>
    4640:	e080      	b.n	4744 <main_task+0x148>
    4642:	e08e      	b.n	4762 <main_task+0x166>
    4644:	6a33      	ldr	r3, [r6, #32]
			current_selection = MENU_ITEM_TERMINAL;
			selection_changed = true;
		}
		#endif
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON3_ID)
    4646:	071b      	lsls	r3, r3, #28
    4648:	d401      	bmi.n	464e <main_task+0x52>
					&& (current_selection != MENU_ITEM_ABOUT)) {
    464a:	2f02      	cmp	r7, #2
    464c:	d17c      	bne.n	4748 <main_task+0x14c>
			current_selection = MENU_ITEM_ABOUT;
			selection_changed = true;
		}

		// If selection changed, handle the selection
		if (selection_changed) {
    464e:	2a00      	cmp	r2, #0
    4650:	d06e      	beq.n	4730 <main_task+0x134>
			// Wait for and take the display semaphore before doing any changes.
			xSemaphoreTake(display_mutex, portMAX_DELAY);
    4652:	4653      	mov	r3, sl
    4654:	6818      	ldr	r0, [r3, #0]
    4656:	2100      	movs	r1, #0
    4658:	2201      	movs	r2, #1
    465a:	4252      	negs	r2, r2
    465c:	2300      	movs	r3, #0
    465e:	4d4b      	ldr	r5, [pc, #300]	; (478c <main_task+0x190>)
    4660:	47a8      	blx	r5

			// We can now safely suspend the previously resumed task
			if (temp_task_handle) {
    4662:	9b03      	ldr	r3, [sp, #12]
    4664:	2b00      	cmp	r3, #0
    4666:	d002      	beq.n	466e <main_task+0x72>
				vTaskSuspend(temp_task_handle);
    4668:	1c18      	adds	r0, r3, #0
    466a:	4b49      	ldr	r3, [pc, #292]	; (4790 <main_task+0x194>)
    466c:	4798      	blx	r3
				temp_task_handle = NULL;
			}

			// Select the new drawing task and corresponding display buffer
			switch (current_selection) {
    466e:	2f00      	cmp	r7, #0
    4670:	d009      	beq.n	4686 <main_task+0x8a>
    4672:	2f01      	cmp	r7, #1
    4674:	d103      	bne.n	467e <main_task+0x82>
			#endif
				
				
#if 1
			case MENU_ITEM_TERMINAL:
				temp_task_handle = terminal_task_handle;
    4676:	4b47      	ldr	r3, [pc, #284]	; (4794 <main_task+0x198>)
    4678:	681b      	ldr	r3, [r3, #0]
    467a:	9303      	str	r3, [sp, #12]
				//temp_task_handle = nrf_task_handle;
				select_graph_buffer = false;
				break;
    467c:	e06a      	b.n	4754 <main_task+0x158>
#endif

			default:
			case MENU_ITEM_ABOUT:
				temp_task_handle = about_task_handle;
    467e:	4b46      	ldr	r3, [pc, #280]	; (4798 <main_task+0x19c>)
    4680:	681b      	ldr	r3, [r3, #0]
    4682:	9303      	str	r3, [sp, #12]
    4684:	e066      	b.n	4754 <main_task+0x158>

			// Select and initialize display buffer to use.
			display_y_offset = select_graph_buffer ? CANVAS_GRAPH_Y_OFFSET : 0;

			// Draw the menu bar (only needs to be done once for graph)
			if (!select_graph_buffer || !graph_buffer_initialized) {
    4686:	2c00      	cmp	r4, #0
    4688:	d16f      	bne.n	476a <main_task+0x16e>
    468a:	2320      	movs	r3, #32
    468c:	4698      	mov	r8, r3
    468e:	2300      	movs	r3, #0
    4690:	9303      	str	r3, [sp, #12]
				// Clear the selected display buffer first
				gfx_mono_draw_filled_rect(0, display_y_offset,
    4692:	2300      	movs	r3, #0
    4694:	9300      	str	r3, [sp, #0]
    4696:	2000      	movs	r0, #0
    4698:	4641      	mov	r1, r8
    469a:	2280      	movs	r2, #128	; 0x80
    469c:	3320      	adds	r3, #32
    469e:	4c3f      	ldr	r4, [pc, #252]	; (479c <main_task+0x1a0>)
    46a0:	47a0      	blx	r4
						GFX_MONO_LCD_WIDTH, GFX_MONO_LCD_HEIGHT / 2,
						GFX_PIXEL_CLR);

				// Draw menu lines, each item with height MENU_HEIGHT pixels
				y = display_y_offset + CANVAS_HEIGHT;
    46a2:	4641      	mov	r1, r8
    46a4:	3117      	adds	r1, #23
				gfx_mono_draw_horizontal_line(0, y, GFX_MONO_LCD_WIDTH,
    46a6:	b2c9      	uxtb	r1, r1
    46a8:	2000      	movs	r0, #0
    46aa:	2280      	movs	r2, #128	; 0x80
    46ac:	2301      	movs	r3, #1
    46ae:	4c3c      	ldr	r4, [pc, #240]	; (47a0 <main_task+0x1a4>)
    46b0:	47a0      	blx	r4
						GFX_PIXEL_SET);

				x = MENU_ITEM_WIDTH;
				y++;
    46b2:	4644      	mov	r4, r8
    46b4:	3418      	adds	r4, #24
    46b6:	b2e4      	uxtb	r4, r4

				for (uint8_t i = 0; i < (MENU_NUM_ITEMS - 1); i++) {
					gfx_mono_draw_vertical_line(x, y, MENU_HEIGHT,
    46b8:	202a      	movs	r0, #42	; 0x2a
    46ba:	1c21      	adds	r1, r4, #0
    46bc:	2208      	movs	r2, #8
    46be:	2301      	movs	r3, #1
    46c0:	4d38      	ldr	r5, [pc, #224]	; (47a4 <main_task+0x1a8>)
    46c2:	47a8      	blx	r5
    46c4:	2055      	movs	r0, #85	; 0x55
    46c6:	1c21      	adds	r1, r4, #0
    46c8:	2208      	movs	r2, #8
    46ca:	2301      	movs	r3, #1
    46cc:	47a8      	blx	r5
							GFX_PIXEL_SET);
					x += 1 + MENU_ITEM_WIDTH;
				}

				// Highlight the current selection
				gfx_mono_draw_rect(current_selection * (1 + MENU_ITEM_WIDTH), y,
    46ce:	202b      	movs	r0, #43	; 0x2b
    46d0:	4378      	muls	r0, r7
    46d2:	b2c0      	uxtb	r0, r0
    46d4:	2301      	movs	r3, #1
    46d6:	9300      	str	r3, [sp, #0]
    46d8:	1c21      	adds	r1, r4, #0
    46da:	222a      	movs	r2, #42	; 0x2a
    46dc:	3307      	adds	r3, #7
    46de:	4c32      	ldr	r4, [pc, #200]	; (47a8 <main_task+0x1ac>)
    46e0:	47a0      	blx	r4
						MENU_ITEM_WIDTH, MENU_HEIGHT, GFX_PIXEL_SET);

				// Draw the menu item text
				x = (MENU_ITEM_WIDTH / 2) - ((5 * SYSFONT_WIDTH) / 2);
				y += (MENU_HEIGHT / 2) - (SYSFONT_HEIGHT / 2);
    46e2:	4643      	mov	r3, r8
    46e4:	3319      	adds	r3, #25
    46e6:	b2db      	uxtb	r3, r3
    46e8:	9302      	str	r3, [sp, #8]
    46ea:	4d30      	ldr	r5, [pc, #192]	; (47ac <main_task+0x1b0>)
				// Highlight the current selection
				gfx_mono_draw_rect(current_selection * (1 + MENU_ITEM_WIDTH), y,
						MENU_ITEM_WIDTH, MENU_HEIGHT, GFX_PIXEL_SET);

				// Draw the menu item text
				x = (MENU_ITEM_WIDTH / 2) - ((5 * SYSFONT_WIDTH) / 2);
    46ec:	2406      	movs	r4, #6
				y += (MENU_HEIGHT / 2) - (SYSFONT_HEIGHT / 2);

				for (uint8_t i = 0; i < MENU_NUM_ITEMS; i++) {
					gfx_mono_draw_string(menu_items_text[i], x, y, &sysfont);
    46ee:	4b30      	ldr	r3, [pc, #192]	; (47b0 <main_task+0x1b4>)
    46f0:	469b      	mov	fp, r3
    46f2:	1c28      	adds	r0, r5, #0
    46f4:	1c21      	adds	r1, r4, #0
    46f6:	9a02      	ldr	r2, [sp, #8]
    46f8:	4b2e      	ldr	r3, [pc, #184]	; (47b4 <main_task+0x1b8>)
    46fa:	47d8      	blx	fp
					x += 1 + MENU_ITEM_WIDTH;
    46fc:	342b      	adds	r4, #43	; 0x2b
    46fe:	b2e4      	uxtb	r4, r4
    4700:	3506      	adds	r5, #6

				// Draw the menu item text
				x = (MENU_ITEM_WIDTH / 2) - ((5 * SYSFONT_WIDTH) / 2);
				y += (MENU_HEIGHT / 2) - (SYSFONT_HEIGHT / 2);

				for (uint8_t i = 0; i < MENU_NUM_ITEMS; i++) {
    4702:	2c87      	cmp	r4, #135	; 0x87
    4704:	d1f5      	bne.n	46f2 <main_task+0xf6>
    4706:	2040      	movs	r0, #64	; 0x40
    4708:	4643      	mov	r3, r8
    470a:	4303      	orrs	r3, r0
    470c:	1c18      	adds	r0, r3, #0
    470e:	4b2a      	ldr	r3, [pc, #168]	; (47b8 <main_task+0x1bc>)
    4710:	4798      	blx	r3

			// Set display controller to output the new buffer
			ssd1306_set_display_start_line_address(display_y_offset);

			// We are done modifying the display, so give back the mutex
			xSemaphoreGive(display_mutex);
    4712:	4b1d      	ldr	r3, [pc, #116]	; (4788 <main_task+0x18c>)
    4714:	6818      	ldr	r0, [r3, #0]
    4716:	2100      	movs	r1, #0
    4718:	2200      	movs	r2, #0
    471a:	2300      	movs	r3, #0
    471c:	4c27      	ldr	r4, [pc, #156]	; (47bc <main_task+0x1c0>)
    471e:	47a0      	blx	r4

			selection_changed = false;

			// If a task handle was specified, resume it now
			if (temp_task_handle) {
    4720:	9803      	ldr	r0, [sp, #12]
    4722:	2800      	cmp	r0, #0
    4724:	d003      	beq.n	472e <main_task+0x132>
				vTaskResume(temp_task_handle);
    4726:	4b26      	ldr	r3, [pc, #152]	; (47c0 <main_task+0x1c4>)
    4728:	4798      	blx	r3
    472a:	2401      	movs	r4, #1
    472c:	e000      	b.n	4730 <main_task+0x134>
    472e:	2401      	movs	r4, #1
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4730:	2380      	movs	r3, #128	; 0x80
    4732:	021b      	lsls	r3, r3, #8
    4734:	61b3      	str	r3, [r6, #24]
		}

		// Show that task is done
		oled1_set_led_state(&oled1, OLED1_LED3_ID, false);

		vTaskDelay(MAIN_TASK_DELAY);
    4736:	2014      	movs	r0, #20
    4738:	4b22      	ldr	r3, [pc, #136]	; (47c4 <main_task+0x1c8>)
    473a:	4798      	blx	r3
    473c:	2200      	movs	r2, #0
	}
    473e:	e771      	b.n	4624 <main_task+0x28>
		oled1_set_led_state(&oled1, OLED1_LED3_ID, true);

		// Check buttons to see if user changed the selection
		if (oled1_get_button_state(&oled1, OLED1_BUTTON1_ID)
					&& (current_selection != MENU_ITEM_GRAPH)) {
			current_selection = MENU_ITEM_GRAPH;
    4740:	2700      	movs	r7, #0
    4742:	e786      	b.n	4652 <main_task+0x56>
		} 
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON2_ID)
		&& (current_selection != NRF_ITEM)) 
		{
			current_selection = NRF_ITEM;
    4744:	2704      	movs	r7, #4
    4746:	e784      	b.n	4652 <main_task+0x56>
		}
		#endif
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON3_ID)
					&& (current_selection != MENU_ITEM_ABOUT)) {
			current_selection = MENU_ITEM_ABOUT;
    4748:	2702      	movs	r7, #2
    474a:	e782      	b.n	4652 <main_task+0x56>
		} 
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON2_ID)
		&& (current_selection != NRF_ITEM)) 
		{
			current_selection = NRF_ITEM;
    474c:	2704      	movs	r7, #4
    474e:	e780      	b.n	4652 <main_task+0x56>
		}
		#endif
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON3_ID)
					&& (current_selection != MENU_ITEM_ABOUT)) {
			current_selection = MENU_ITEM_ABOUT;
    4750:	2702      	movs	r7, #2
    4752:	e77e      	b.n	4652 <main_task+0x56>
				temp_task_handle = about_task_handle;
				select_graph_buffer = false;
			}

			// Select and initialize display buffer to use.
			display_y_offset = select_graph_buffer ? CANVAS_GRAPH_Y_OFFSET : 0;
    4754:	2300      	movs	r3, #0
    4756:	4698      	mov	r8, r3
    4758:	e79b      	b.n	4692 <main_task+0x96>
		const uint8_t gpio_pin)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	return (port_base->IN.reg & pin_mask);
    475a:	6a33      	ldr	r3, [r6, #32]
					&& (current_selection != MENU_ITEM_GRAPH)) {
			current_selection = MENU_ITEM_GRAPH;
			selection_changed = true;
		} 
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON2_ID)
    475c:	075b      	lsls	r3, r3, #29
    475e:	d5f5      	bpl.n	474c <main_task+0x150>
    4760:	e770      	b.n	4644 <main_task+0x48>
    4762:	6a33      	ldr	r3, [r6, #32]
			current_selection = MENU_ITEM_TERMINAL;
			selection_changed = true;
		}
		#endif
		
		else if (oled1_get_button_state(&oled1, OLED1_BUTTON3_ID)
    4764:	071b      	lsls	r3, r3, #28
    4766:	d5f3      	bpl.n	4750 <main_task+0x154>
    4768:	e771      	b.n	464e <main_task+0x52>
    476a:	2060      	movs	r0, #96	; 0x60
    476c:	4b12      	ldr	r3, [pc, #72]	; (47b8 <main_task+0x1bc>)
    476e:	4798      	blx	r3

			// Set display controller to output the new buffer
			ssd1306_set_display_start_line_address(display_y_offset);

			// We are done modifying the display, so give back the mutex
			xSemaphoreGive(display_mutex);
    4770:	4b05      	ldr	r3, [pc, #20]	; (4788 <main_task+0x18c>)
    4772:	6818      	ldr	r0, [r3, #0]
    4774:	2100      	movs	r1, #0
    4776:	2200      	movs	r2, #0
    4778:	2300      	movs	r3, #0
    477a:	4d10      	ldr	r5, [pc, #64]	; (47bc <main_task+0x1c0>)
    477c:	47a8      	blx	r5
    477e:	2300      	movs	r3, #0
    4780:	9303      	str	r3, [sp, #12]
    4782:	e7d5      	b.n	4730 <main_task+0x134>
    4784:	41004400 	.word	0x41004400
    4788:	200040cc 	.word	0x200040cc
    478c:	00003075 	.word	0x00003075
    4790:	000039ad 	.word	0x000039ad
    4794:	200040d4 	.word	0x200040d4
    4798:	200040dc 	.word	0x200040dc
    479c:	00000be9 	.word	0x00000be9
    47a0:	00000929 	.word	0x00000929
    47a4:	00000a09 	.word	0x00000a09
    47a8:	00000b99 	.word	0x00000b99
    47ac:	00004fb4 	.word	0x00004fb4
    47b0:	00000cdd 	.word	0x00000cdd
    47b4:	20000008 	.word	0x20000008
    47b8:	00000645 	.word	0x00000645
    47bc:	00002de5 	.word	0x00002de5
    47c0:	000034e9 	.word	0x000034e9
    47c4:	00003819 	.word	0x00003819

000047c8 <demotasks_init>:
 * This function initializes the \ref oled1_xpro_io_group instance and the
 * \ref edbg_cdc_rx_group instance for reception, then creates all
 * the objects for FreeRTOS to run the demo.
 */
void demotasks_init(void)
{
    47c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    47ca:	4647      	mov	r7, r8
    47cc:	b480      	push	{r7}
    47ce:	b090      	sub	sp, #64	; 0x40
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
	config->powersave  = false;
    47d0:	ac04      	add	r4, sp, #16
    47d2:	2500      	movs	r5, #0
    47d4:	70a5      	strb	r5, [r4, #2]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    47d6:	4b75      	ldr	r3, [pc, #468]	; (49ac <demotasks_init+0x1e4>)
    47d8:	2280      	movs	r2, #128	; 0x80
    47da:	0152      	lsls	r2, r2, #5
    47dc:	619a      	str	r2, [r3, #24]
    47de:	2280      	movs	r2, #128	; 0x80
    47e0:	0192      	lsls	r2, r2, #6
    47e2:	619a      	str	r2, [r3, #24]
    47e4:	2280      	movs	r2, #128	; 0x80
    47e6:	0212      	lsls	r2, r2, #8
    47e8:	619a      	str	r2, [r3, #24]

	port_pin_set_output_level(oled1->led0_pin, !OLED1_LED_ACTIVE);
	port_pin_set_output_level(oled1->led1_pin, !OLED1_LED_ACTIVE);
	port_pin_set_output_level(oled1->led2_pin, !OLED1_LED_ACTIVE);

	pin_conf.direction  = PORT_PIN_DIR_OUTPUT_WTH_READBACK;
    47ea:	2302      	movs	r3, #2
    47ec:	7023      	strb	r3, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_NONE;
    47ee:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(oled1->led0_pin, &pin_conf);
    47f0:	200c      	movs	r0, #12
    47f2:	1c21      	adds	r1, r4, #0
    47f4:	4e6e      	ldr	r6, [pc, #440]	; (49b0 <demotasks_init+0x1e8>)
    47f6:	47b0      	blx	r6
	port_pin_set_config(oled1->led1_pin, &pin_conf);
    47f8:	200d      	movs	r0, #13
    47fa:	1c21      	adds	r1, r4, #0
    47fc:	47b0      	blx	r6
	port_pin_set_config(oled1->led2_pin, &pin_conf);
    47fe:	200f      	movs	r0, #15
    4800:	1c21      	adds	r1, r4, #0
    4802:	47b0      	blx	r6

	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    4804:	7025      	strb	r5, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    4806:	2701      	movs	r7, #1
    4808:	7067      	strb	r7, [r4, #1]
	port_pin_set_config(oled1->button0_pin, &pin_conf);
    480a:	201c      	movs	r0, #28
    480c:	1c21      	adds	r1, r4, #0
    480e:	47b0      	blx	r6
	port_pin_set_config(oled1->button1_pin, &pin_conf);
    4810:	2002      	movs	r0, #2
    4812:	1c21      	adds	r1, r4, #0
    4814:	47b0      	blx	r6
	port_pin_set_config(oled1->button2_pin, &pin_conf);
    4816:	2003      	movs	r0, #3
    4818:	1c21      	adds	r1, r4, #0
    481a:	47b0      	blx	r6
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    481c:	2380      	movs	r3, #128	; 0x80
    481e:	05db      	lsls	r3, r3, #23
    4820:	9304      	str	r3, [sp, #16]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    4822:	6065      	str	r5, [r4, #4]
	config->parity           = USART_PARITY_NONE;
    4824:	23ff      	movs	r3, #255	; 0xff
    4826:	8123      	strh	r3, [r4, #8]
	config->stopbits         = USART_STOPBITS_1;
    4828:	72a5      	strb	r5, [r4, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    482a:	72e5      	strb	r5, [r4, #11]
	config->baudrate         = 9600;
    482c:	2396      	movs	r3, #150	; 0x96
    482e:	019b      	lsls	r3, r3, #6
    4830:	6123      	str	r3, [r4, #16]
	config->receiver_enable  = true;
    4832:	7527      	strb	r7, [r4, #20]
	config->transmitter_enable = true;
    4834:	7567      	strb	r7, [r4, #21]
	config->clock_polarity_inverted = false;
    4836:	75a5      	strb	r5, [r4, #22]
	config->use_external_clock = false;
    4838:	75e5      	strb	r5, [r4, #23]
	config->ext_clock_freq   = 0;
    483a:	61a5      	str	r5, [r4, #24]
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    483c:	7725      	strb	r5, [r4, #28]
	config->generator_source = GCLK_GENERATOR_0;
    483e:	7765      	strb	r5, [r4, #29]
	struct usart_config config_struct;
	uint8_t instance_index;

	usart_get_config_defaults(&config_struct);

	config_struct.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    4840:	23c4      	movs	r3, #196	; 0xc4
    4842:	039b      	lsls	r3, r3, #14
    4844:	60e3      	str	r3, [r4, #12]
	config_struct.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    4846:	2301      	movs	r3, #1
    4848:	425b      	negs	r3, r3
    484a:	6223      	str	r3, [r4, #32]
	config_struct.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    484c:	6263      	str	r3, [r4, #36]	; 0x24
	config_struct.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    484e:	4b59      	ldr	r3, [pc, #356]	; (49b4 <demotasks_init+0x1ec>)
    4850:	62a3      	str	r3, [r4, #40]	; 0x28
	config_struct.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    4852:	4b59      	ldr	r3, [pc, #356]	; (49b8 <demotasks_init+0x1f0>)
    4854:	62e3      	str	r3, [r4, #44]	; 0x2c

	while (usart_init(usart, EDBG_CDC_MODULE, &config_struct) != STATUS_OK) {
    4856:	4e59      	ldr	r6, [pc, #356]	; (49bc <demotasks_init+0x1f4>)
    4858:	4d59      	ldr	r5, [pc, #356]	; (49c0 <demotasks_init+0x1f8>)
    485a:	4c5a      	ldr	r4, [pc, #360]	; (49c4 <demotasks_init+0x1fc>)
    485c:	1c30      	adds	r0, r6, #0
    485e:	1c29      	adds	r1, r5, #0
    4860:	aa04      	add	r2, sp, #16
    4862:	47a0      	blx	r4
    4864:	2800      	cmp	r0, #0
    4866:	d1f9      	bne.n	485c <demotasks_init+0x94>
		// Intentionally left empty
	}

	// Inject our own interrupt handler
	instance_index = _sercom_get_sercom_inst_index(EDBG_CDC_MODULE);
    4868:	4855      	ldr	r0, [pc, #340]	; (49c0 <demotasks_init+0x1f8>)
    486a:	4b57      	ldr	r3, [pc, #348]	; (49c8 <demotasks_init+0x200>)
    486c:	4798      	blx	r3
	_sercom_set_handler(instance_index, cdc_rx_handler);
    486e:	4957      	ldr	r1, [pc, #348]	; (49cc <demotasks_init+0x204>)
    4870:	4b57      	ldr	r3, [pc, #348]	; (49d0 <demotasks_init+0x208>)
    4872:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    4874:	4d51      	ldr	r5, [pc, #324]	; (49bc <demotasks_init+0x1f4>)
    4876:	682c      	ldr	r4, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    4878:	1c20      	adds	r0, r4, #0
    487a:	4b56      	ldr	r3, [pc, #344]	; (49d4 <demotasks_init+0x20c>)
    487c:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    487e:	231f      	movs	r3, #31
    4880:	4018      	ands	r0, r3
    4882:	3b1e      	subs	r3, #30
    4884:	4083      	lsls	r3, r0
    4886:	1c18      	adds	r0, r3, #0
    4888:	4b53      	ldr	r3, [pc, #332]	; (49d8 <demotasks_init+0x210>)
    488a:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    488c:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    488e:	8a13      	ldrh	r3, [r2, #16]
    4890:	0bdb      	lsrs	r3, r3, #15
    4892:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    4894:	b29b      	uxth	r3, r3
    4896:	2b00      	cmp	r3, #0
    4898:	d1f9      	bne.n	488e <demotasks_init+0xc6>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    489a:	6822      	ldr	r2, [r4, #0]
    489c:	3302      	adds	r3, #2
    489e:	4313      	orrs	r3, r2
    48a0:	6023      	str	r3, [r4, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    48a2:	4b46      	ldr	r3, [pc, #280]	; (49bc <demotasks_init+0x1f4>)
    48a4:	681a      	ldr	r2, [r3, #0]
	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    48a6:	8a13      	ldrh	r3, [r2, #16]
    48a8:	0bdb      	lsrs	r3, r3, #15
    48aa:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    48ac:	b29b      	uxth	r3, r3
    48ae:	2b00      	cmp	r3, #0
    48b0:	d1f9      	bne.n	48a6 <demotasks_init+0xde>
			module->receiver_enabled = true;
			break;

		case USART_TRANSCEIVER_TX:
			/* Enable TX */
			usart_hw->CTRLB.reg |= SERCOM_USART_CTRLB_TXEN;
    48b2:	6853      	ldr	r3, [r2, #4]
    48b4:	2180      	movs	r1, #128	; 0x80
    48b6:	0249      	lsls	r1, r1, #9
    48b8:	430b      	orrs	r3, r1
    48ba:	6053      	str	r3, [r2, #4]
			module->transmitter_enabled = true;
    48bc:	2101      	movs	r1, #1
    48be:	4b3f      	ldr	r3, [pc, #252]	; (49bc <demotasks_init+0x1f4>)
    48c0:	71d9      	strb	r1, [r3, #7]
	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    48c2:	8a13      	ldrh	r3, [r2, #16]
    48c4:	0bdb      	lsrs	r3, r3, #15
    48c6:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    48c8:	b29b      	uxth	r3, r3
    48ca:	2b00      	cmp	r3, #0
    48cc:	d1f9      	bne.n	48c2 <demotasks_init+0xfa>
	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    48ce:	8a13      	ldrh	r3, [r2, #16]
    48d0:	0bdb      	lsrs	r3, r3, #15
    48d2:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    48d4:	b29b      	uxth	r3, r3
    48d6:	2b00      	cmp	r3, #0
    48d8:	d1f9      	bne.n	48ce <demotasks_init+0x106>
	_usart_wait_for_sync(module);

	switch (transceiver_type) {
		case USART_TRANSCEIVER_RX:
			/* Enable RX */
			usart_hw->CTRLB.reg |= SERCOM_USART_CTRLB_RXEN;
    48da:	6853      	ldr	r3, [r2, #4]
    48dc:	2180      	movs	r1, #128	; 0x80
    48de:	0289      	lsls	r1, r1, #10
    48e0:	430b      	orrs	r3, r1
    48e2:	6053      	str	r3, [r2, #4]
			module->receiver_enabled = true;
    48e4:	2101      	movs	r1, #1
    48e6:	4b35      	ldr	r3, [pc, #212]	; (49bc <demotasks_init+0x1f4>)
    48e8:	7199      	strb	r1, [r3, #6]
	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
    48ea:	8a13      	ldrh	r3, [r2, #16]
    48ec:	0bdb      	lsrs	r3, r3, #15
    48ee:	03db      	lsls	r3, r3, #15
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    48f0:	b29b      	uxth	r3, r3
    48f2:	2b00      	cmp	r3, #0
    48f4:	d1f9      	bne.n	48ea <demotasks_init+0x122>
	usart_enable(usart);
	usart_enable_transceiver(usart, USART_TRANSCEIVER_TX);
	usart_enable_transceiver(usart, USART_TRANSCEIVER_RX);

	// ..and the RX Complete interrupt
	((SercomUsart *)EDBG_CDC_MODULE)->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
    48f6:	2204      	movs	r2, #4
    48f8:	4b31      	ldr	r3, [pc, #196]	; (49c0 <demotasks_init+0x1f8>)
    48fa:	735a      	strb	r2, [r3, #13]
	oled1_init(&oled1);

	// Configure SERCOM USART for reception from EDBG Virtual COM Port
	cdc_rx_init(&cdc_usart, &cdc_rx_handler);

	display_mutex  = xSemaphoreCreateMutex();
    48fc:	2001      	movs	r0, #1
    48fe:	4c37      	ldr	r4, [pc, #220]	; (49dc <demotasks_init+0x214>)
    4900:	47a0      	blx	r4
    4902:	4b37      	ldr	r3, [pc, #220]	; (49e0 <demotasks_init+0x218>)
    4904:	6018      	str	r0, [r3, #0]
	terminal_mutex = xSemaphoreCreateMutex();
    4906:	2001      	movs	r0, #1
    4908:	47a0      	blx	r4
    490a:	4b36      	ldr	r3, [pc, #216]	; (49e4 <demotasks_init+0x21c>)
    490c:	6018      	str	r0, [r3, #0]
	terminal_in_queue = xQueueCreate(64, sizeof(uint8_t));
    490e:	2040      	movs	r0, #64	; 0x40
    4910:	2101      	movs	r1, #1
    4912:	2200      	movs	r2, #0
    4914:	4b34      	ldr	r3, [pc, #208]	; (49e8 <demotasks_init+0x220>)
    4916:	4798      	blx	r3
    4918:	4b34      	ldr	r3, [pc, #208]	; (49ec <demotasks_init+0x224>)
    491a:	6018      	str	r0, [r3, #0]

	xTaskCreate(about_task,
    491c:	2601      	movs	r6, #1
    491e:	9600      	str	r6, [sp, #0]
    4920:	4b33      	ldr	r3, [pc, #204]	; (49f0 <demotasks_init+0x228>)
    4922:	4698      	mov	r8, r3
    4924:	9301      	str	r3, [sp, #4]
    4926:	2400      	movs	r4, #0
    4928:	9402      	str	r4, [sp, #8]
    492a:	9403      	str	r4, [sp, #12]
    492c:	4831      	ldr	r0, [pc, #196]	; (49f4 <demotasks_init+0x22c>)
    492e:	4932      	ldr	r1, [pc, #200]	; (49f8 <demotasks_init+0x230>)
    4930:	2264      	movs	r2, #100	; 0x64
    4932:	2300      	movs	r3, #0
    4934:	4d31      	ldr	r5, [pc, #196]	; (49fc <demotasks_init+0x234>)
    4936:	47a8      	blx	r5
			configMINIMAL_STACK_SIZE,
			NULL,
			ABOUT_TASK_PRIORITY,
			&about_task_handle);

	xTaskCreate(graph_task,
    4938:	9600      	str	r6, [sp, #0]
    493a:	9401      	str	r4, [sp, #4]
    493c:	9402      	str	r4, [sp, #8]
    493e:	9403      	str	r4, [sp, #12]
    4940:	482f      	ldr	r0, [pc, #188]	; (4a00 <demotasks_init+0x238>)
    4942:	4930      	ldr	r1, [pc, #192]	; (4a04 <demotasks_init+0x23c>)
    4944:	2264      	movs	r2, #100	; 0x64
    4946:	2300      	movs	r3, #0
    4948:	47a8      	blx	r5
			configMINIMAL_STACK_SIZE,
			NULL,
			GRAPH_TASK_PRIORITY,
			NULL);

	xTaskCreate(main_task,
    494a:	2302      	movs	r3, #2
    494c:	9300      	str	r3, [sp, #0]
    494e:	9401      	str	r4, [sp, #4]
    4950:	9402      	str	r4, [sp, #8]
    4952:	9403      	str	r4, [sp, #12]
    4954:	482c      	ldr	r0, [pc, #176]	; (4a08 <demotasks_init+0x240>)
    4956:	492d      	ldr	r1, [pc, #180]	; (4a0c <demotasks_init+0x244>)
    4958:	2264      	movs	r2, #100	; 0x64
    495a:	2300      	movs	r3, #0
    495c:	47a8      	blx	r5
			configMINIMAL_STACK_SIZE,
			NULL,
			MAIN_TASK_PRIORITY,
			NULL);

	xTaskCreate(terminal_task,
    495e:	9600      	str	r6, [sp, #0]
    4960:	4f2b      	ldr	r7, [pc, #172]	; (4a10 <demotasks_init+0x248>)
    4962:	9701      	str	r7, [sp, #4]
    4964:	9402      	str	r4, [sp, #8]
    4966:	9403      	str	r4, [sp, #12]
    4968:	482a      	ldr	r0, [pc, #168]	; (4a14 <demotasks_init+0x24c>)
    496a:	492b      	ldr	r1, [pc, #172]	; (4a18 <demotasks_init+0x250>)
    496c:	2264      	movs	r2, #100	; 0x64
    496e:	2300      	movs	r3, #0
    4970:	47a8      	blx	r5
			configMINIMAL_STACK_SIZE,
			NULL,
			TERMINAL_TASK_PRIORITY,
			&terminal_task_handle);

	xTaskCreate(uart_task,
    4972:	2303      	movs	r3, #3
    4974:	9300      	str	r3, [sp, #0]
    4976:	9401      	str	r4, [sp, #4]
    4978:	9402      	str	r4, [sp, #8]
    497a:	9403      	str	r4, [sp, #12]
    497c:	4827      	ldr	r0, [pc, #156]	; (4a1c <demotasks_init+0x254>)
    497e:	4928      	ldr	r1, [pc, #160]	; (4a20 <demotasks_init+0x258>)
    4980:	2264      	movs	r2, #100	; 0x64
    4982:	2300      	movs	r3, #0
    4984:	47a8      	blx	r5
			configMINIMAL_STACK_SIZE,
			NULL,
			UART_TASK_PRIORITY,
			NULL);

	xTaskCreate(NRF_Task,
    4986:	9600      	str	r6, [sp, #0]
    4988:	9401      	str	r4, [sp, #4]
    498a:	9402      	str	r4, [sp, #8]
    498c:	9403      	str	r4, [sp, #12]
    498e:	4825      	ldr	r0, [pc, #148]	; (4a24 <demotasks_init+0x25c>)
    4990:	4925      	ldr	r1, [pc, #148]	; (4a28 <demotasks_init+0x260>)
    4992:	2264      	movs	r2, #100	; 0x64
    4994:	2300      	movs	r3, #0
    4996:	47a8      	blx	r5
			NRF_TASK_PRIORITY,
			&nrf_task_handle);
#endif

	// Suspend these since the main task will control their execution
	vTaskSuspend(about_task_handle);
    4998:	4643      	mov	r3, r8
    499a:	6818      	ldr	r0, [r3, #0]
    499c:	4c23      	ldr	r4, [pc, #140]	; (4a2c <demotasks_init+0x264>)
    499e:	47a0      	blx	r4
	vTaskSuspend(terminal_task_handle);
    49a0:	6838      	ldr	r0, [r7, #0]
    49a2:	47a0      	blx	r4
	//vTaskSuspend(nrf_task_handle);
}
    49a4:	b010      	add	sp, #64	; 0x40
    49a6:	bc04      	pop	{r2}
    49a8:	4690      	mov	r8, r2
    49aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    49ac:	41004400 	.word	0x41004400
    49b0:	00000f3d 	.word	0x00000f3d
    49b4:	00180002 	.word	0x00180002
    49b8:	00190002 	.word	0x00190002
    49bc:	200040a8 	.word	0x200040a8
    49c0:	42001400 	.word	0x42001400
    49c4:	00001cc1 	.word	0x00001cc1
    49c8:	00001325 	.word	0x00001325
    49cc:	000040cd 	.word	0x000040cd
    49d0:	00001365 	.word	0x00001365
    49d4:	000013a1 	.word	0x000013a1
    49d8:	e000e100 	.word	0xe000e100
    49dc:	00002f55 	.word	0x00002f55
    49e0:	200040cc 	.word	0x200040cc
    49e4:	200040d0 	.word	0x200040d0
    49e8:	00002d91 	.word	0x00002d91
    49ec:	200040e0 	.word	0x200040e0
    49f0:	200040dc 	.word	0x200040dc
    49f4:	0000422d 	.word	0x0000422d
    49f8:	00005008 	.word	0x00005008
    49fc:	000032fd 	.word	0x000032fd
    4a00:	0000432d 	.word	0x0000432d
    4a04:	00005010 	.word	0x00005010
    4a08:	000045fd 	.word	0x000045fd
    4a0c:	00005018 	.word	0x00005018
    4a10:	200040d4 	.word	0x200040d4
    4a14:	00004425 	.word	0x00004425
    4a18:	00005020 	.word	0x00005020
    4a1c:	00004141 	.word	0x00004141
    4a20:	00005028 	.word	0x00005028
    4a24:	0000452d 	.word	0x0000452d
    4a28:	00005030 	.word	0x00005030
    4a2c:	000039ad 	.word	0x000039ad

00004a30 <main>:
#include <asf.h>
#include "demotasks.h"
#include "NRF24L01_DRIVER.h"

int main (void)
{
    4a30:	b570      	push	{r4, r5, r6, lr}
	system_init();
    4a32:	4b14      	ldr	r3, [pc, #80]	; (4a84 <main+0x54>)
    4a34:	4798      	blx	r3
	gfx_mono_init();
    4a36:	4b14      	ldr	r3, [pc, #80]	; (4a88 <main+0x58>)
    4a38:	4798      	blx	r3

	//delay_cycles_ms(1000);
	//delay_cycles_us(1000);
	
	configure_spi_master();
    4a3a:	4b14      	ldr	r3, [pc, #80]	; (4a8c <main+0x5c>)
    4a3c:	4798      	blx	r3
	
	delay_cycles_ms(100);
    4a3e:	2064      	movs	r0, #100	; 0x64
    4a40:	4e13      	ldr	r6, [pc, #76]	; (4a90 <main+0x60>)
    4a42:	47b0      	blx	r6
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Toggle pin output level */
	port_base->OUTTGL.reg = pin_mask;
    4a44:	4c13      	ldr	r4, [pc, #76]	; (4a94 <main+0x64>)
    4a46:	2580      	movs	r5, #128	; 0x80
    4a48:	01ed      	lsls	r5, r5, #7
    4a4a:	61e5      	str	r5, [r4, #28]
	port_pin_toggle_output_level(LED_0_PIN);
	delay_cycles_ms(100);
    4a4c:	2064      	movs	r0, #100	; 0x64
    4a4e:	47b0      	blx	r6
    4a50:	61e5      	str	r5, [r4, #28]
	port_pin_toggle_output_level(LED_0_PIN);
	delay_cycles_ms(100);
    4a52:	2064      	movs	r0, #100	; 0x64
    4a54:	47b0      	blx	r6
    4a56:	61e5      	str	r5, [r4, #28]
	port_pin_toggle_output_level(LED_0_PIN);
	delay_cycles_ms(100);
    4a58:	2064      	movs	r0, #100	; 0x64
    4a5a:	47b0      	blx	r6
    4a5c:	61e5      	str	r5, [r4, #28]
	port_pin_toggle_output_level(LED_0_PIN);
	delay_cycles_ms(100);
    4a5e:	2064      	movs	r0, #100	; 0x64
    4a60:	47b0      	blx	r6
    4a62:	61e5      	str	r5, [r4, #28]
	port_pin_toggle_output_level(LED_0_PIN);
	delay_cycles_ms(100);
    4a64:	2064      	movs	r0, #100	; 0x64
    4a66:	47b0      	blx	r6
    4a68:	61e5      	str	r5, [r4, #28]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4a6a:	2380      	movs	r3, #128	; 0x80
    4a6c:	035b      	lsls	r3, r3, #13
    4a6e:	61a3      	str	r3, [r4, #24]
	
	CE_ON;
	
	if(1 == SendNotGet)
	{
		Set_NRF24L_Tx_Mode();
    4a70:	4b09      	ldr	r3, [pc, #36]	; (4a98 <main+0x68>)
    4a72:	4798      	blx	r3
	else
	{
		Set_NRF24L_Rx_Mode();
	}
		
	Init_NRF24L_Reciever();
    4a74:	4b09      	ldr	r3, [pc, #36]	; (4a9c <main+0x6c>)
    4a76:	4798      	blx	r3
	
	// Initialize the demo..
	demotasks_init();
    4a78:	4b09      	ldr	r3, [pc, #36]	; (4aa0 <main+0x70>)
    4a7a:	4798      	blx	r3

	// ..and let FreeRTOS run tasks!
	vTaskStartScheduler();
    4a7c:	4b09      	ldr	r3, [pc, #36]	; (4aa4 <main+0x74>)
    4a7e:	4798      	blx	r3

	do {
		// Intentionally left empty
	} while (true);
    4a80:	e7fe      	b.n	4a80 <main+0x50>
    4a82:	46c0      	nop			; (mov r8, r8)
    4a84:	000027f9 	.word	0x000027f9
    4a88:	00000d81 	.word	0x00000d81
    4a8c:	0000014d 	.word	0x0000014d
    4a90:	000008d1 	.word	0x000008d1
    4a94:	41004400 	.word	0x41004400
    4a98:	00000421 	.word	0x00000421
    4a9c:	00000479 	.word	0x00000479
    4aa0:	000047c9 	.word	0x000047c9
    4aa4:	0000356d 	.word	0x0000356d

00004aa8 <__aeabi_uidiv>:
    4aa8:	2200      	movs	r2, #0
    4aaa:	0843      	lsrs	r3, r0, #1
    4aac:	428b      	cmp	r3, r1
    4aae:	d374      	bcc.n	4b9a <__aeabi_uidiv+0xf2>
    4ab0:	0903      	lsrs	r3, r0, #4
    4ab2:	428b      	cmp	r3, r1
    4ab4:	d35f      	bcc.n	4b76 <__aeabi_uidiv+0xce>
    4ab6:	0a03      	lsrs	r3, r0, #8
    4ab8:	428b      	cmp	r3, r1
    4aba:	d344      	bcc.n	4b46 <__aeabi_uidiv+0x9e>
    4abc:	0b03      	lsrs	r3, r0, #12
    4abe:	428b      	cmp	r3, r1
    4ac0:	d328      	bcc.n	4b14 <__aeabi_uidiv+0x6c>
    4ac2:	0c03      	lsrs	r3, r0, #16
    4ac4:	428b      	cmp	r3, r1
    4ac6:	d30d      	bcc.n	4ae4 <__aeabi_uidiv+0x3c>
    4ac8:	22ff      	movs	r2, #255	; 0xff
    4aca:	0209      	lsls	r1, r1, #8
    4acc:	ba12      	rev	r2, r2
    4ace:	0c03      	lsrs	r3, r0, #16
    4ad0:	428b      	cmp	r3, r1
    4ad2:	d302      	bcc.n	4ada <__aeabi_uidiv+0x32>
    4ad4:	1212      	asrs	r2, r2, #8
    4ad6:	0209      	lsls	r1, r1, #8
    4ad8:	d065      	beq.n	4ba6 <__aeabi_uidiv+0xfe>
    4ada:	0b03      	lsrs	r3, r0, #12
    4adc:	428b      	cmp	r3, r1
    4ade:	d319      	bcc.n	4b14 <__aeabi_uidiv+0x6c>
    4ae0:	e000      	b.n	4ae4 <__aeabi_uidiv+0x3c>
    4ae2:	0a09      	lsrs	r1, r1, #8
    4ae4:	0bc3      	lsrs	r3, r0, #15
    4ae6:	428b      	cmp	r3, r1
    4ae8:	d301      	bcc.n	4aee <__aeabi_uidiv+0x46>
    4aea:	03cb      	lsls	r3, r1, #15
    4aec:	1ac0      	subs	r0, r0, r3
    4aee:	4152      	adcs	r2, r2
    4af0:	0b83      	lsrs	r3, r0, #14
    4af2:	428b      	cmp	r3, r1
    4af4:	d301      	bcc.n	4afa <__aeabi_uidiv+0x52>
    4af6:	038b      	lsls	r3, r1, #14
    4af8:	1ac0      	subs	r0, r0, r3
    4afa:	4152      	adcs	r2, r2
    4afc:	0b43      	lsrs	r3, r0, #13
    4afe:	428b      	cmp	r3, r1
    4b00:	d301      	bcc.n	4b06 <__aeabi_uidiv+0x5e>
    4b02:	034b      	lsls	r3, r1, #13
    4b04:	1ac0      	subs	r0, r0, r3
    4b06:	4152      	adcs	r2, r2
    4b08:	0b03      	lsrs	r3, r0, #12
    4b0a:	428b      	cmp	r3, r1
    4b0c:	d301      	bcc.n	4b12 <__aeabi_uidiv+0x6a>
    4b0e:	030b      	lsls	r3, r1, #12
    4b10:	1ac0      	subs	r0, r0, r3
    4b12:	4152      	adcs	r2, r2
    4b14:	0ac3      	lsrs	r3, r0, #11
    4b16:	428b      	cmp	r3, r1
    4b18:	d301      	bcc.n	4b1e <__aeabi_uidiv+0x76>
    4b1a:	02cb      	lsls	r3, r1, #11
    4b1c:	1ac0      	subs	r0, r0, r3
    4b1e:	4152      	adcs	r2, r2
    4b20:	0a83      	lsrs	r3, r0, #10
    4b22:	428b      	cmp	r3, r1
    4b24:	d301      	bcc.n	4b2a <__aeabi_uidiv+0x82>
    4b26:	028b      	lsls	r3, r1, #10
    4b28:	1ac0      	subs	r0, r0, r3
    4b2a:	4152      	adcs	r2, r2
    4b2c:	0a43      	lsrs	r3, r0, #9
    4b2e:	428b      	cmp	r3, r1
    4b30:	d301      	bcc.n	4b36 <__aeabi_uidiv+0x8e>
    4b32:	024b      	lsls	r3, r1, #9
    4b34:	1ac0      	subs	r0, r0, r3
    4b36:	4152      	adcs	r2, r2
    4b38:	0a03      	lsrs	r3, r0, #8
    4b3a:	428b      	cmp	r3, r1
    4b3c:	d301      	bcc.n	4b42 <__aeabi_uidiv+0x9a>
    4b3e:	020b      	lsls	r3, r1, #8
    4b40:	1ac0      	subs	r0, r0, r3
    4b42:	4152      	adcs	r2, r2
    4b44:	d2cd      	bcs.n	4ae2 <__aeabi_uidiv+0x3a>
    4b46:	09c3      	lsrs	r3, r0, #7
    4b48:	428b      	cmp	r3, r1
    4b4a:	d301      	bcc.n	4b50 <__aeabi_uidiv+0xa8>
    4b4c:	01cb      	lsls	r3, r1, #7
    4b4e:	1ac0      	subs	r0, r0, r3
    4b50:	4152      	adcs	r2, r2
    4b52:	0983      	lsrs	r3, r0, #6
    4b54:	428b      	cmp	r3, r1
    4b56:	d301      	bcc.n	4b5c <__aeabi_uidiv+0xb4>
    4b58:	018b      	lsls	r3, r1, #6
    4b5a:	1ac0      	subs	r0, r0, r3
    4b5c:	4152      	adcs	r2, r2
    4b5e:	0943      	lsrs	r3, r0, #5
    4b60:	428b      	cmp	r3, r1
    4b62:	d301      	bcc.n	4b68 <__aeabi_uidiv+0xc0>
    4b64:	014b      	lsls	r3, r1, #5
    4b66:	1ac0      	subs	r0, r0, r3
    4b68:	4152      	adcs	r2, r2
    4b6a:	0903      	lsrs	r3, r0, #4
    4b6c:	428b      	cmp	r3, r1
    4b6e:	d301      	bcc.n	4b74 <__aeabi_uidiv+0xcc>
    4b70:	010b      	lsls	r3, r1, #4
    4b72:	1ac0      	subs	r0, r0, r3
    4b74:	4152      	adcs	r2, r2
    4b76:	08c3      	lsrs	r3, r0, #3
    4b78:	428b      	cmp	r3, r1
    4b7a:	d301      	bcc.n	4b80 <__aeabi_uidiv+0xd8>
    4b7c:	00cb      	lsls	r3, r1, #3
    4b7e:	1ac0      	subs	r0, r0, r3
    4b80:	4152      	adcs	r2, r2
    4b82:	0883      	lsrs	r3, r0, #2
    4b84:	428b      	cmp	r3, r1
    4b86:	d301      	bcc.n	4b8c <__aeabi_uidiv+0xe4>
    4b88:	008b      	lsls	r3, r1, #2
    4b8a:	1ac0      	subs	r0, r0, r3
    4b8c:	4152      	adcs	r2, r2
    4b8e:	0843      	lsrs	r3, r0, #1
    4b90:	428b      	cmp	r3, r1
    4b92:	d301      	bcc.n	4b98 <__aeabi_uidiv+0xf0>
    4b94:	004b      	lsls	r3, r1, #1
    4b96:	1ac0      	subs	r0, r0, r3
    4b98:	4152      	adcs	r2, r2
    4b9a:	1a41      	subs	r1, r0, r1
    4b9c:	d200      	bcs.n	4ba0 <__aeabi_uidiv+0xf8>
    4b9e:	4601      	mov	r1, r0
    4ba0:	4152      	adcs	r2, r2
    4ba2:	4610      	mov	r0, r2
    4ba4:	4770      	bx	lr
    4ba6:	e7ff      	b.n	4ba8 <__aeabi_uidiv+0x100>
    4ba8:	b501      	push	{r0, lr}
    4baa:	2000      	movs	r0, #0
    4bac:	f000 f80c 	bl	4bc8 <__aeabi_idiv0>
    4bb0:	bd02      	pop	{r1, pc}
    4bb2:	46c0      	nop			; (mov r8, r8)

00004bb4 <__aeabi_uidivmod>:
    4bb4:	2900      	cmp	r1, #0
    4bb6:	d0f7      	beq.n	4ba8 <__aeabi_uidiv+0x100>
    4bb8:	b503      	push	{r0, r1, lr}
    4bba:	f7ff ff75 	bl	4aa8 <__aeabi_uidiv>
    4bbe:	bc0e      	pop	{r1, r2, r3}
    4bc0:	4342      	muls	r2, r0
    4bc2:	1a89      	subs	r1, r1, r2
    4bc4:	4718      	bx	r3
    4bc6:	46c0      	nop			; (mov r8, r8)

00004bc8 <__aeabi_idiv0>:
    4bc8:	4770      	bx	lr
    4bca:	46c0      	nop			; (mov r8, r8)

00004bcc <__aeabi_lmul>:
    4bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
    4bce:	464f      	mov	r7, r9
    4bd0:	4646      	mov	r6, r8
    4bd2:	0405      	lsls	r5, r0, #16
    4bd4:	0c2d      	lsrs	r5, r5, #16
    4bd6:	1c2c      	adds	r4, r5, #0
    4bd8:	b4c0      	push	{r6, r7}
    4bda:	0417      	lsls	r7, r2, #16
    4bdc:	0c16      	lsrs	r6, r2, #16
    4bde:	0c3f      	lsrs	r7, r7, #16
    4be0:	4699      	mov	r9, r3
    4be2:	0c03      	lsrs	r3, r0, #16
    4be4:	437c      	muls	r4, r7
    4be6:	4375      	muls	r5, r6
    4be8:	435f      	muls	r7, r3
    4bea:	4373      	muls	r3, r6
    4bec:	197d      	adds	r5, r7, r5
    4bee:	0c26      	lsrs	r6, r4, #16
    4bf0:	19ad      	adds	r5, r5, r6
    4bf2:	469c      	mov	ip, r3
    4bf4:	42af      	cmp	r7, r5
    4bf6:	d903      	bls.n	4c00 <__aeabi_lmul+0x34>
    4bf8:	2380      	movs	r3, #128	; 0x80
    4bfa:	025b      	lsls	r3, r3, #9
    4bfc:	4698      	mov	r8, r3
    4bfe:	44c4      	add	ip, r8
    4c00:	464b      	mov	r3, r9
    4c02:	4351      	muls	r1, r2
    4c04:	4343      	muls	r3, r0
    4c06:	0424      	lsls	r4, r4, #16
    4c08:	0c2e      	lsrs	r6, r5, #16
    4c0a:	0c24      	lsrs	r4, r4, #16
    4c0c:	042d      	lsls	r5, r5, #16
    4c0e:	4466      	add	r6, ip
    4c10:	192c      	adds	r4, r5, r4
    4c12:	1859      	adds	r1, r3, r1
    4c14:	1989      	adds	r1, r1, r6
    4c16:	1c20      	adds	r0, r4, #0
    4c18:	bc0c      	pop	{r2, r3}
    4c1a:	4690      	mov	r8, r2
    4c1c:	4699      	mov	r9, r3
    4c1e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004c20 <__libc_init_array>:
    4c20:	4b0e      	ldr	r3, [pc, #56]	; (4c5c <__libc_init_array+0x3c>)
    4c22:	b570      	push	{r4, r5, r6, lr}
    4c24:	2500      	movs	r5, #0
    4c26:	1c1e      	adds	r6, r3, #0
    4c28:	4c0d      	ldr	r4, [pc, #52]	; (4c60 <__libc_init_array+0x40>)
    4c2a:	1ae4      	subs	r4, r4, r3
    4c2c:	10a4      	asrs	r4, r4, #2
    4c2e:	42a5      	cmp	r5, r4
    4c30:	d004      	beq.n	4c3c <__libc_init_array+0x1c>
    4c32:	00ab      	lsls	r3, r5, #2
    4c34:	58f3      	ldr	r3, [r6, r3]
    4c36:	4798      	blx	r3
    4c38:	3501      	adds	r5, #1
    4c3a:	e7f8      	b.n	4c2e <__libc_init_array+0xe>
    4c3c:	f000 f9fa 	bl	5034 <_init>
    4c40:	4b08      	ldr	r3, [pc, #32]	; (4c64 <__libc_init_array+0x44>)
    4c42:	2500      	movs	r5, #0
    4c44:	1c1e      	adds	r6, r3, #0
    4c46:	4c08      	ldr	r4, [pc, #32]	; (4c68 <__libc_init_array+0x48>)
    4c48:	1ae4      	subs	r4, r4, r3
    4c4a:	10a4      	asrs	r4, r4, #2
    4c4c:	42a5      	cmp	r5, r4
    4c4e:	d004      	beq.n	4c5a <__libc_init_array+0x3a>
    4c50:	00ab      	lsls	r3, r5, #2
    4c52:	58f3      	ldr	r3, [r6, r3]
    4c54:	4798      	blx	r3
    4c56:	3501      	adds	r5, #1
    4c58:	e7f8      	b.n	4c4c <__libc_init_array+0x2c>
    4c5a:	bd70      	pop	{r4, r5, r6, pc}
    4c5c:	00005040 	.word	0x00005040
    4c60:	00005040 	.word	0x00005040
    4c64:	00005040 	.word	0x00005040
    4c68:	00005044 	.word	0x00005044

00004c6c <memcpy>:
    4c6c:	2300      	movs	r3, #0
    4c6e:	b510      	push	{r4, lr}
    4c70:	4293      	cmp	r3, r2
    4c72:	d003      	beq.n	4c7c <memcpy+0x10>
    4c74:	5ccc      	ldrb	r4, [r1, r3]
    4c76:	54c4      	strb	r4, [r0, r3]
    4c78:	3301      	adds	r3, #1
    4c7a:	e7f9      	b.n	4c70 <memcpy+0x4>
    4c7c:	bd10      	pop	{r4, pc}
	...

00004c80 <sysfont_glyphs>:
    4c80:	0000 0000 0000 2000 2020 2020 2000 5050     .......     . PP
    4c90:	0050 0000 5000 f850 f850 5050 7820 70a0     P....PP.P.PP x.p
    4ca0:	f028 c020 10c8 4020 1898 9060 40a0 90a8     (. ... @..`..@..
    4cb0:	6068 4020 0000 0000 2010 4040 2040 4010     h` @..... @@@ .@
    4cc0:	1020 1010 4020 5000 f820 5020 0000 2020      ... @.P . P..  
    4cd0:	20f8 0020 0000 0000 2060 0040 0000 00f8     .  .....` @.....
    4ce0:	0000 0000 0000 6000 0060 1008 4020 0080     .......``... @..
    4cf0:	8870 a898 88c8 2070 2060 2020 7020 8870     p.....p `    pp.
    4d00:	1008 4020 f8f8 2010 0810 7088 3010 9050     .. @... ...p.0P.
    4d10:	10f8 f810 f080 0808 7088 4030 f080 8888     .........p0@....
    4d20:	f870 1008 4020 4040 8870 7088 8888 7070     p... @@@p..p..pp
    4d30:	8888 0878 6010 6000 0060 6060 0000 6060     ..x..`.``.``..``
    4d40:	6000 4020 1008 4020 1020 0008 f800 f800     .` @.. @ .......
    4d50:	0000 4080 1020 4020 7080 0888 2010 2000     ...@ . @.p... . 
    4d60:	8870 6808 a8a8 7070 8888 f888 8888 88f0     p..h..pp........
    4d70:	f088 8888 70f0 8088 8080 7088 90e0 8888     .....p.....p....
    4d80:	9088 f8e0 8080 80f0 f880 80f8 e080 8080     ................
    4d90:	7080 8088 9880 7088 8888 f888 8888 7088     .p.....p.......p
    4da0:	2020 2020 7020 1038 1010 9010 8860 a090          p8.....`...
    4db0:	a0c0 8890 8080 8080 8080 88f8 a8d8 8888     ................
    4dc0:	8888 8888 a8c8 8898 7088 8888 8888 7088     .........p.....p
    4dd0:	88f0 f088 8080 7080 8888 a888 6890 88f0     .......p.....h..
    4de0:	f088 90a0 7888 8080 0870 f008 20f8 2020     .....x..p....   
    4df0:	2020 8820 8888 8888 7088 8888 8888 5088        ......p.....P
    4e00:	8820 8888 a8a8 88d8 8888 2050 8850 8888      .........P P...
    4e10:	5088 2020 2020 08f8 2010 8040 38f8 2020     .P    ... @..8  
    4e20:	2020 3820 8000 2040 0810 e000 2020 2020        8..@ ....    
    4e30:	e020 5020 0088 0000 0000 0000 0000 f800      . P............
    4e40:	2040 0010 0000 0000 7000 7808 7888 8080     @ .......p.x.x..
    4e50:	c8b0 8888 00f0 7000 8080 7088 0808 9868     .......p...p..h.
    4e60:	8888 0078 7000 f888 7080 4830 e040 4040     ..x..p...p0H@.@@
    4e70:	0040 7800 7888 3008 8080 c8b0 8888 2088     @..x.x.0....... 
    4e80:	6000 2020 7020 0010 1030 9010 4060 4840     .`   p..0...`@@H
    4e90:	6050 4850 2060 2020 2020 0070 d000 a8a8     P`PH`     p.....
    4ea0:	8888 0000 c8b0 8888 0088 7000 8888 7088     ...........p...p
    4eb0:	0000 88f0 80f0 0080 6800 7898 0808 0000     .........h.x....
    4ec0:	c8b0 8080 0080 7000 7080 f008 4040 40e0     .......p.p..@@.@
    4ed0:	4840 0030 8800 8888 6898 0000 8888 5088     @H0......h.....P
    4ee0:	0020 8800 a888 50a8 0000 5088 5020 0088      ......P...P P..
    4ef0:	8800 7888 7008 0000 10f8 4020 10f8 2020     ...x.p.... @..  
    4f00:	2040 1020 2020 2020 2020 4020 2020 2010     @  .       @  . 
    4f10:	4020 0000 0800 4200 0c00 4200 1000 4200      @.....B...B...B
    4f20:	1400 4200 1800 4200 1c00 4200 0807 0a09     ...B...B...B....
    4f30:	0c0b 0000 205e 0000 205a 0000 205a 0000     ....^ ..Z ..Z ..
    4f40:	20a8 0000 20a8 0000 2074 0000 2064 0000     . ... ..t ..d ..
    4f50:	207a 0000 22b4 0000 2294 0000 2294 0000     z ..."..."..."..
    4f60:	2304 0000 22a6 0000 22c2 0000 2298 0000     .#..."..."..."..
    4f70:	22d0 0000 4449 454c 0000 0000 4014 0000     ."..IDLE.....@..
    4f80:	4014 0000 4014 0000 4074 0000 4056 0000     .@...@..t@..V@..
    4f90:	406e 0000 4014 0000 4014 0000 4074 0000     n@...@...@..t@..
    4fa0:	4056 0000 6d54 2072 7653 0063 554a 5453     V@..Tmr Svc.JUST
    4fb0:	0049 0000                                   I...

00004fb4 <menu_items_text>:
    4fb4:	7247 7061 0068 6554 6d72 002e 6241 756f     Graph.Term..Abou
    4fc4:	0074 0000                                   t...

00004fc8 <about_text>:
    4fc8:	7246 6565 5452 534f 5620 2e38 2e30 2031     FreeRTOS V8.0.1 
    4fd8:	6564 6f6d 202e 2020 2020 2020 2020 2020     demo.           
    4fe8:	2020 2020 2020 2020 2020 7355 2065 4443               Use CD
    4ff8:	2043 7461 3920 362e 6b20 6142 6475 002e     C at 9.6 kBaud..
    5008:	6241 756f 0074 0000 7247 7061 0068 0000     About...Graph...
    5018:	614d 6e69 0000 0000 6554 6d72 002e 0000     Main....Term....
    5028:	4155 5452 0000 0000 524e 0046               UART....NRF.

00005034 <_init>:
    5034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5036:	46c0      	nop			; (mov r8, r8)
    5038:	bcf8      	pop	{r3, r4, r5, r6, r7}
    503a:	bc08      	pop	{r3}
    503c:	469e      	mov	lr, r3
    503e:	4770      	bx	lr

00005040 <__init_array_start>:
    5040:	000000cd 	.word	0x000000cd

00005044 <_fini>:
    5044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5046:	46c0      	nop			; (mov r8, r8)
    5048:	bcf8      	pop	{r3, r4, r5, r6, r7}
    504a:	bc08      	pop	{r3}
    504c:	469e      	mov	lr, r3
    504e:	4770      	bx	lr

00005050 <__fini_array_start>:
    5050:	000000a5 	.word	0x000000a5
